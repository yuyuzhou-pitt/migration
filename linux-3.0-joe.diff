diff -Nurp linux/drivers/rtc/#interface.c# linux-3.0/drivers/rtc/#interface.c#
--- linux/drivers/rtc/#interface.c#	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/drivers/rtc/#interface.c#	2014-02-19 21:03:24.419264577 -0500
@@ -0,0 +1,890 @@
+/*
+ * RTC subsystem, interface functions
+ *
+ * Copyright (C) 2005 Tower Technologies
+ * Author: Alessandro Zummo <a.zummo@towertech.it>
+ *
+ * based on arch/arm/common/rtctime.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/rtc.h>
+#include <linux/sched.h>
+#include <linux/log2.h>
+#include <linux/workqueue.h>
+
+static int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer);
+static void rtc_timer_remove(struct rtc_device *rtc, struct rtc_timer *timer);
+
+static int __rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)
+{
+	int err;
+	if (!rtc->ops)
+		err = -ENODEV;
+	else if (!rtc->ops->read_time)
+		err = -EINVAL;
+	else {
+		memset(tm, 0, sizeof(struct rtc_time));
+		err = rtc->ops->read_time(rtc->dev.parent, tm);
+	}
+	return err;
+}
+
+int rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)
+{
+	int err;
+
+	err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+
+	err = __rtc_read_time(rtc, tm);
+	mutex_unlock(&rtc->ops_lock);
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_read_time);
+
+int rtc_set_time(struct rtc_device *rtc, struct rtc_time *tm)
+{
+	int err;
+
+	err = rtc_valid_tm(tm);
+	if (err != 0)
+		return err;
+
+	err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+
+	if (!rtc->ops)
+		err = -ENODEV;
+	else if (rtc->ops->set_time)
+		err = rtc->ops->set_time(rtc->dev.parent, tm);
+	else if (rtc->ops->set_mmss) {
+		unsigned long secs;
+		err = rtc_tm_to_time(tm, &secs);
+		if (err == 0)
+			err = rtc->ops->set_mmss(rtc->dev.parent, secs);
+	} else
+		err = -EINVAL;
+
+	mutex_unlock(&rtc->ops_lock);
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_set_time);
+
+int rtc_set_mmss(struct rtc_device *rtc, unsigned long secs)
+{
+	int err;
+
+	err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+
+	if (!rtc->ops)
+		err = -ENODEV;
+	else if (rtc->ops->set_mmss)
+		err = rtc->ops->set_mmss(rtc->dev.parent, secs);
+	else if (rtc->ops->read_time && rtc->ops->set_time) {
+		struct rtc_time new, old;
+
+		err = rtc->ops->read_time(rtc->dev.parent, &old);
+		if (err == 0) {
+			rtc_time_to_tm(secs, &new);
+
+			/*
+			 * avoid writing when we're going to change the day of
+			 * the month. We will retry in the next minute. This
+			 * basically means that if the RTC must not drift
+			 * by more than 1 minute in 11 minutes.
+			 */
+			if (!((old.tm_hour == 23 && old.tm_min == 59) ||
+				(new.tm_hour == 23 && new.tm_min == 59)))
+				err = rtc->ops->set_time(rtc->dev.parent,
+						&new);
+		}
+	}
+	else
+		err = -EINVAL;
+
+	mutex_unlock(&rtc->ops_lock);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_set_mmss);
+
+static int rtc_read_alarm_internal(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
+{
+	int err;
+
+	err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+
+	if (rtc->ops == NULL)
+		err = -ENODEV;
+	else if (!rtc->ops->read_alarm)
+		err = -EINVAL;
+	else {
+		memset(alarm, 0, sizeof(struct rtc_wkalrm));
+		err = rtc->ops->read_alarm(rtc->dev.parent, alarm);
+	}
+
+	mutex_unlock(&rtc->ops_lock);
+	return err;
+}
+
+int __rtc_read_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
+{
+	int err;
+	struct rtc_time before, now;
+	int first_time = 1;
+	unsigned long t_now, t_alm;
+	enum { none, day, month, year } missing = none;
+	unsigned days;
+
+	/* The lower level RTC driver may return -1 in some fields,
+	 * creating invalid alarm->time values, for reasons like:
+	 *
+	 *   - The hardware may not be capable of filling them in;
+	 *     many alarms match only on time-of-day fields, not
+	 *     day/month/year calendar data.
+	 *
+	 *   - Some hardware uses illegal values as "wildcard" match
+	 *     values, which non-Linux firmware (like a BIOS) may try
+	 *     to set up as e.g. "alarm 15 minutes after each hour".
+	 *     Linux uses only oneshot alarms.
+	 *
+	 * When we see that here, we deal with it by using values from
+	 * a current RTC timestamp for any missing (-1) values.  The
+	 * RTC driver prevents "periodic alarm" modes.
+	 *
+	 * But this can be racey, because some fields of the RTC timestamp
+	 * may have wrapped in the interval since we read the RTC alarm,
+	 * which would lead to us inserting inconsistent values in place
+	 * of the -1 fields.
+	 *
+	 * Reading the alarm and timestamp in the reverse sequence
+	 * would have the same race condition, and not solve the issue.
+	 *
+	 * So, we must first read the RTC timestamp,
+	 * then read the RTC alarm value,
+	 * and then read a second RTC timestamp.
+	 *
+	 * If any fields of the second timestamp have changed
+	 * when compared with the first timestamp, then we know
+	 * our timestamp may be inconsistent with that used by
+	 * the low-level rtc_read_alarm_internal() function.
+	 *
+	 * So, when the two timestamps disagree, we just loop and do
+	 * the process again to get a fully consistent set of values.
+	 *
+	 * This could all instead be done in the lower level driver,
+	 * but since more than one lower level RTC implementation needs it,
+	 * then it's probably best best to do it here instead of there..
+	 */
+
+	/* Get the "before" timestamp */
+	err = rtc_read_time(rtc, &before);
+	if (err < 0)
+		return err;
+	do {
+		if (!first_time)
+			memcpy(&before, &now, sizeof(struct rtc_time));
+		first_time = 0;
+
+		/* get the RTC alarm values, which may be incomplete */
+		err = rtc_read_alarm_internal(rtc, alarm);
+		if (err)
+			return err;
+
+		/* full-function RTCs won't have such missing fields */
+		if (rtc_valid_tm(&alarm->time) == 0)
+			return 0;
+
+		/* get the "after" timestamp, to detect wrapped fields */
+		err = rtc_read_time(rtc, &now);
+		if (err < 0)
+			return err;
+
+		/* note that tm_sec is a "don't care" value here: */
+	} while (   before.tm_min   != now.tm_min
+		 || before.tm_hour  != now.tm_hour
+		 || before.tm_mon   != now.tm_mon
+		 || before.tm_year  != now.tm_year);
+
+	/* Fill in the missing alarm fields using the timestamp; we
+	 * know there's at least one since alarm->time is invalid.
+	 */
+	if (alarm->time.tm_sec == -1)
+		alarm->time.tm_sec = now.tm_sec;
+	if (alarm->time.tm_min == -1)
+		alarm->time.tm_min = now.tm_min;
+	if (alarm->time.tm_hour == -1)
+		alarm->time.tm_hour = now.tm_hour;
+
+	/* For simplicity, only support date rollover for now */
+	if (alarm->time.tm_mday == -1) {
+		alarm->time.tm_mday = now.tm_mday;
+		missing = day;
+	}
+	if (alarm->time.tm_mon == -1) {
+		alarm->time.tm_mon = now.tm_mon;
+		if (missing == none)
+			missing = month;
+	}
+	if (alarm->time.tm_year == -1) {
+		alarm->time.tm_year = now.tm_year;
+		if (missing == none)
+			missing = year;
+	}
+
+	/* with luck, no rollover is needed */
+	rtc_tm_to_time(&now, &t_now);
+	rtc_tm_to_time(&alarm->time, &t_alm);
+	if (t_now < t_alm)
+		goto done;
+
+	switch (missing) {
+
+	/* 24 hour rollover ... if it's now 10am Monday, an alarm that
+	 * that will trigger at 5am will do so at 5am Tuesday, which
+	 * could also be in the next month or year.  This is a common
+	 * case, especially for PCs.
+	 */
+	case day:
+		dev_dbg(&rtc->dev, "alarm rollover: %s\n", "day");
+		t_alm += 24 * 60 * 60;
+		rtc_time_to_tm(t_alm, &alarm->time);
+		break;
+
+	/* Month rollover ... if it's the 31th, an alarm on the 3rd will
+	 * be next month.  An alarm matching on the 30th, 29th, or 28th
+	 * may end up in the month after that!  Many newer PCs support
+	 * this type of alarm.
+	 */
+	case month:
+		dev_dbg(&rtc->dev, "alarm rollover: %s\n", "month");
+		do {
+			if (alarm->time.tm_mon < 11)
+				alarm->time.tm_mon++;
+			else {
+				alarm->time.tm_mon = 0;
+				alarm->time.tm_year++;
+			}
+			days = rtc_month_days(alarm->time.tm_mon,
+					alarm->time.tm_year);
+		} while (days < alarm->time.tm_mday);
+		break;
+
+	/* Year rollover ... easy except for leap years! */
+	case year:
+		dev_dbg(&rtc->dev, "alarm rollover: %s\n", "year");
+		do {
+			alarm->time.tm_year++;
+		} while (rtc_valid_tm(&alarm->time) != 0);
+		break;
+
+	default:
+		dev_warn(&rtc->dev, "alarm rollover not handled\n");
+	}
+
+done:
+	return 0;
+}
+
+int rtc_read_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
+{
+	int err;
+
+	err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+	if (rtc->ops == NULL)
+		err = -ENODEV;
+	else if (!rtc->ops->read_alarm)
+		err = -EINVAL;
+	else {
+		memset(alarm, 0, sizeof(struct rtc_wkalrm));
+		alarm->enabled = rtc->aie_timer.enabled;
+		alarm->time = rtc_ktime_to_tm(rtc->aie_timer.node.expires);
+	}
+	mutex_unlock(&rtc->ops_lock);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_read_alarm);
+
+static int __rtc_set_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
+{
+	struct rtc_time tm;
+	long now, scheduled;
+	int err;
+
+	err = rtc_valid_tm(&alarm->time);
+	if (err)
+		return err;
+	rtc_tm_to_time(&alarm->time, &scheduled);
+
+	/* Make sure we're not setting alarms in the past */
+	err = __rtc_read_time(rtc, &tm);
+	rtc_tm_to_time(&tm, &now);
+	if (scheduled <= now)
+		return -ETIME;
+	/*
+	 * XXX - We just checked to make sure the alarm time is not
+	 * in the past, but there is still a race window where if
+	 * the is alarm set for the next second and the second ticks
+	 * over right here, before we set the alarm.
+	 */
+
+	if (!rtc->ops)
+		err = -ENODEV;
+	else if (!rtc->ops->set_alarm)
+		err = -EINVAL;
+	else
+		err = rtc->ops->set_alarm(rtc->dev.parent, alarm);
+
+	return err;
+}
+
+int rtc_set_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
+{
+	int err;
+
+	err = rtc_valid_tm(&alarm->time);
+	if (err != 0)
+		return err;
+
+	err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+	if (rtc->aie_timer.enabled) {
+		rtc_timer_remove(rtc, &rtc->aie_timer);
+	}
+	rtc->aie_timer.node.expires = rtc_tm_to_ktime(alarm->time);
+	rtc->aie_timer.period = ktime_set(0, 0);
+	if (alarm->enabled) {
+		err = rtc_timer_enqueue(rtc, &rtc->aie_timer);
+	}
+	mutex_unlock(&rtc->ops_lock);
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_set_alarm);
+
+/* Called once per device from rtc_device_register */
+int rtc_initialize_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
+{
+	int err;
+
+	err = rtc_valid_tm(&alarm->time);
+	if (err != 0)
+		return err;
+
+	err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+
+	rtc->aie_timer.node.expires = rtc_tm_to_ktime(alarm->time);
+	rtc->aie_timer.period = ktime_set(0, 0);
+	if (alarm->enabled) {
+		rtc->aie_timer.enabled = 1;
+		timerqueue_add(&rtc->timerqueue, &rtc->aie_timer.node);
+	}
+	mutex_unlock(&rtc->ops_lock);
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_initialize_alarm);
+
+
+
+int rtc_alarm_irq_enable(struct rtc_device *rtc, unsigned int enabled)
+{
+	int err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+
+	if (rtc->aie_timer.enabled != enabled) {
+		if (enabled)
+			err = rtc_timer_enqueue(rtc, &rtc->aie_timer);
+		else
+			rtc_timer_remove(rtc, &rtc->aie_timer);
+	}
+
+	if (err)
+		/* nothing */;
+	else if (!rtc->ops)
+		err = -ENODEV;
+	else if (!rtc->ops->alarm_irq_enable)
+		err = -EINVAL;
+	else
+		err = rtc->ops->alarm_irq_enable(rtc->dev.parent, enabled);
+
+	mutex_unlock(&rtc->ops_lock);
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_alarm_irq_enable);
+
+int rtc_update_irq_enable(struct rtc_device *rtc, unsigned int enabled)
+{
+	int err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+
+#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL
+	if (enabled == 0 && rtc->uie_irq_active) {
+		mutex_unlock(&rtc->ops_lock);
+		return rtc_dev_update_irq_enable_emul(rtc, 0);
+	}
+#endif
+	/* make sure we're changing state */
+	if (rtc->uie_rtctimer.enabled == enabled)
+		goto out;
+
+	if (enabled) {
+		struct rtc_time tm;
+		ktime_t now, onesec;
+
+		__rtc_read_time(rtc, &tm);
+		onesec = ktime_set(1, 0);
+		now = rtc_tm_to_ktime(tm);
+		rtc->uie_rtctimer.node.expires = ktime_add(now, onesec);
+		rtc->uie_rtctimer.period = ktime_set(1, 0);
+		err = rtc_timer_enqueue(rtc, &rtc->uie_rtctimer);
+	} else
+		rtc_timer_remove(rtc, &rtc->uie_rtctimer);
+
+out:
+	mutex_unlock(&rtc->ops_lock);
+#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL
+	/*
+	 * Enable emulation if the driver did not provide
+	 * the update_irq_enable function pointer or if returned
+	 * -EINVAL to signal that it has been configured without
+	 * interrupts or that are not available at the moment.
+	 */
+	if (err == -EINVAL)
+		err = rtc_dev_update_irq_enable_emul(rtc, enabled);
+#endif
+	return err;
+
+}
+EXPORT_SYMBOL_GPL(rtc_update_irq_enable);
+
+
+/**
+ * rtc_handle_legacy_irq - AIE, UIE and PIE event hook
+ * @rtc: pointer to the rtc device
+ *
+ * This function is called when an AIE, UIE or PIE mode interrupt
+ * has occurred (or been emulated).
+ *
+ * Triggers the registered irq_task function callback.
+ */
+void rtc_handle_legacy_irq(struct rtc_device *rtc, int num, int mode)
+{
+	unsigned long flags;
+
+	/* mark one irq of the appropriate mode */
+	spin_lock_irqsave(&rtc->irq_lock, flags);
+	rtc->irq_data = (rtc->irq_data + (num << 8)) | (RTC_IRQF|mode);
+	spin_unlock_irqrestore(&rtc->irq_lock, flags);
+
+	/* call the task func */
+	spin_lock_irqsave(&rtc->irq_task_lock, flags);
+	if (rtc->irq_task)
+		rtc->irq_task->func(rtc->irq_task->private_data);
+	spin_unlock_irqrestore(&rtc->irq_task_lock, flags);
+
+	wake_up_interruptible(&rtc->irq_queue);
+	kill_fasync(&rtc->async_queue, SIGIO, POLL_IN);
+}
+
+
+/**
+ * rtc_aie_update_irq - AIE mode rtctimer hook
+ * @private: pointer to the rtc_device
+ *
+ * This functions is called when the aie_timer expires.
+ */
+void rtc_aie_update_irq(void *private)
+{
+	struct rtc_device *rtc = (struct rtc_device *)private;
+	rtc_handle_legacy_irq(rtc, 1, RTC_AF);
+}
+
+
+/**
+ * rtc_uie_update_irq - UIE mode rtctimer hook
+ * @private: pointer to the rtc_device
+ *
+ * This functions is called when the uie_timer expires.
+ */
+void rtc_uie_update_irq(void *private)
+{
+	struct rtc_device *rtc = (struct rtc_device *)private;
+	rtc_handle_legacy_irq(rtc, 1,  RTC_UF);
+}
+
+
+/**
+ * rtc_pie_update_irq - PIE mode hrtimer hook
+ * @timer: pointer to the pie mode hrtimer
+ *
+ * This function is used to emulate PIE mode interrupts
+ * using an hrtimer. This function is called when the periodic
+ * hrtimer expires.
+ */
+enum hrtimer_restart rtc_pie_update_irq(struct hrtimer *timer)
+{
+	struct rtc_device *rtc;
+	ktime_t period;
+	int count;
+	rtc = container_of(timer, struct rtc_device, pie_timer);
+
+	period = ktime_set(0, NSEC_PER_SEC/rtc->irq_freq);
+	count = hrtimer_forward_now(timer, period);
+
+	rtc_handle_legacy_irq(rtc, count, RTC_PF);
+
+	return HRTIMER_RESTART;
+}
+
+/**
+ * rtc_update_irq - Triggered when a RTC interrupt occurs.
+ * @rtc: the rtc device
+ * @num: how many irqs are being reported (usually one)
+ * @events: mask of RTC_IRQF with one or more of RTC_PF, RTC_AF, RTC_UF
+ * Context: any
+ */
+void rtc_update_irq(struct rtc_device *rtc,
+		unsigned long num, unsigned long events)
+{
+	schedule_work(&rtc->irqwork)sEA;
+}
+EXPORT_SYMBOL_GPL(rtc_update_irq);
+
+static int __rtc_match(struct device *dev, void *data)
+{
+	char *name = (char *)data;
+
+	if (strcmp(dev_name(dev), name) == 0)
+		return 1;
+	return 0;
+}
+
+struct rtc_device *rtc_class_open(char *name)
+{
+	struct device *dev;
+	struct rtc_device *rtc = NULL;
+
+	dev = class_find_device(rtc_class, NULL, name, __rtc_match);
+	if (dev)
+		rtc = to_rtc_device(dev);
+
+	if (rtc) {
+		if (!try_module_get(rtc->owner)) {
+			put_device(dev);
+			rtc = NULL;
+		}
+	}
+
+	return rtc;
+}
+EXPORT_SYMBOL_GPL(rtc_class_open);
+
+void rtc_class_close(struct rtc_device *rtc)
+{
+	module_put(rtc->owner);
+	put_device(&rtc->dev);
+}
+EXPORT_SYMBOL_GPL(rtc_class_close);
+
+int rtc_irq_register(struct rtc_device *rtc, struct rtc_task *task)
+{
+	int retval = -EBUSY;
+
+	if (task == NULL || task->func == NULL)
+		return -EINVAL;
+
+	/* Cannot register while the char dev is in use */
+	if (test_and_set_bit_lock(RTC_DEV_BUSY, &rtc->flags))
+		return -EBUSY;
+
+	spin_lock_irq(&rtc->irq_task_lock);
+	if (rtc->irq_task == NULL) {
+		rtc->irq_task = task;
+		retval = 0;
+	}
+	spin_unlock_irq(&rtc->irq_task_lock);
+
+	clear_bit_unlock(RTC_DEV_BUSY, &rtc->flags);
+
+	return retval;
+}
+EXPORT_SYMBOL_GPL(rtc_irq_register);
+
+void rtc_irq_unregister(struct rtc_device *rtc, struct rtc_task *task)
+{
+	spin_lock_irq(&rtc->irq_task_lock);
+	if (rtc->irq_task == task)
+		rtc->irq_task = NULL;
+	spin_unlock_irq(&rtc->irq_task_lock);
+}
+EXPORT_SYMBOL_GPL(rtc_irq_unregister);
+
+/**
+ * rtc_irq_set_state - enable/disable 2^N Hz periodic IRQs
+ * @rtc: the rtc device
+ * @task: currently registered with rtc_irq_register()
+ * @enabled: true to enable periodic IRQs
+ * Context: any
+ *
+ * Note that rtc_irq_set_freq() should previously have been used to
+ * specify the desired frequency of periodic IRQ task->func() callbacks.
+ */
+int rtc_irq_set_state(struct rtc_device *rtc, struct rtc_task *task, int enabled)
+{
+	int err = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rtc->irq_task_lock, flags);
+	if (rtc->irq_task != NULL && task == NULL)
+		err = -EBUSY;
+	if (rtc->irq_task != task)
+		err = -EACCES;
+
+	if (enabled) {
+		ktime_t period = ktime_set(0, NSEC_PER_SEC/rtc->irq_freq);
+		hrtimer_start(&rtc->pie_timer, period, HRTIMER_MODE_REL);
+	} else {
+		hrtimer_cancel(&rtc->pie_timer);
+	}
+	rtc->pie_enabled = enabled;
+	spin_unlock_irqrestore(&rtc->irq_task_lock, flags);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_irq_set_state);
+
+/**
+ * rtc_irq_set_freq - set 2^N Hz periodic IRQ frequency for IRQ
+ * @rtc: the rtc device
+ * @task: currently registered with rtc_irq_register()
+ * @freq: positive frequency with which task->func() will be called
+ * Context: any
+ *
+ * Note that rtc_irq_set_state() is used to enable or disable the
+ * periodic IRQs.
+ */
+int rtc_irq_set_freq(struct rtc_device *rtc, struct rtc_task *task, int freq)
+{
+	int err = 0;
+	unsigned long flags;
+
+	if (freq <= 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&rtc->irq_task_lock, flags);
+	if (rtc->irq_task != NULL && task == NULL)
+		err = -EBUSY;
+	if (rtc->irq_task != task)
+		err = -EACCES;
+	if (err == 0) {
+		rtc->irq_freq = freq;
+		if (rtc->pie_enabled) {
+			ktime_t period;
+			hrtimer_cancel(&rtc->pie_timer);
+			period = ktime_set(0, NSEC_PER_SEC/rtc->irq_freq);
+			hrtimer_start(&rtc->pie_timer, period,
+					HRTIMER_MODE_REL);
+		}
+	}
+	spin_unlock_irqrestore(&rtc->irq_task_lock, flags);
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_irq_set_freq);
+
+/**
+ * rtc_timer_enqueue - Adds a rtc_timer to the rtc_device timerqueue
+ * @rtc rtc device
+ * @timer timer being added.
+ *
+ * Enqueues a timer onto the rtc devices timerqueue and sets
+ * the next alarm event appropriately.
+ *
+ * Sets the enabled bit on the added timer.
+ *
+ * Must hold ops_lock for proper serialization of timerqueue
+ */
+static int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer)
+{
+	timer->enabled = 1;
+	timerqueue_add(&rtc->timerqueue, &timer->node);
+	if (&timer->node == timerqueue_getnext(&rtc->timerqueue)) {
+		struct rtc_wkalrm alarm;
+		int err;
+		alarm.time = rtc_ktime_to_tm(timer->node.expires);
+		alarm.enabled = 1;
+		err = __rtc_set_alarm(rtc, &alarm);
+		if (err == -ETIME)
+			schedule_work(&rtc->irqwork);
+		else if (err) {
+			timerqueue_del(&rtc->timerqueue, &timer->node);
+			timer->enabled = 0;
+			return err;
+		}
+	}
+	return 0;
+}
+
+/**
+ * rtc_timer_remove - Removes a rtc_timer from the rtc_device timerqueue
+ * @rtc rtc device
+ * @timer timer being removed.
+ *
+ * Removes a timer onto the rtc devices timerqueue and sets
+ * the next alarm event appropriately.
+ *
+ * Clears the enabled bit on the removed timer.
+ *
+ * Must hold ops_lock for proper serialization of timerqueue
+ */
+static void rtc_timer_remove(struct rtc_device *rtc, struct rtc_timer *timer)
+{
+	struct timerqueue_node *next = timerqueue_getnext(&rtc->timerqueue);
+	timerqueue_del(&rtc->timerqueue, &timer->node);
+	timer->enabled = 0;
+	if (next == &timer->node) {
+		struct rtc_wkalrm alarm;
+		int err;
+		next = timerqueue_getnext(&rtc->timerqueue);
+		if (!next)
+			return;
+		alarm.time = rtc_ktime_to_tm(next->expires);
+		alarm.enabled = 1;
+		err = __rtc_set_alarm(rtc, &alarm);
+		if (err == -ETIME)
+			schedule_work(&rtc->irqwork);
+	}
+}
+
+/**
+ * rtc_timer_do_work - Expires rtc timers
+ * @rtc rtc device
+ * @timer timer being removed.
+ *
+ * Expires rtc timers. Reprograms next alarm event if needed.
+ * Called via worktask.
+ *
+ * Serializes access to timerqueue via ops_lock mutex
+ */
+void rtc_timer_do_work(struct work_struct *work)
+{
+	struct rtc_timer *timer;
+	struct timerqueue_node *next;
+	ktime_t now;
+	struct rtc_time tm;
+
+	struct rtc_device *rtc =
+		container_of(work, struct rtc_device, irqwork);
+
+	mutex_lock(&rtc->ops_lock);
+again:
+	__rtc_read_time(rtc, &tm);
+	now = rtc_tm_to_ktime(tm);
+	while ((next = timerqueue_getnext(&rtc->timerqueue))) {
+		if (next->expires.tv64 > now.tv64)
+			break;
+
+		/* expire timer */
+		timer = container_of(next, struct rtc_timer, node);
+		timerqueue_del(&rtc->timerqueue, &timer->node);
+		timer->enabled = 0;
+		if (timer->task.func)
+			timer->task.func(timer->task.private_data);
+
+		/* Re-add/fwd periodic timers */
+		if (ktime_to_ns(timer->period)) {
+			timer->node.expires = ktime_add(timer->node.expires,
+							timer->period);
+			timer->enabled = 1;
+			timerqueue_add(&rtc->timerqueue, &timer->node);
+		}
+	}
+
+	/* Set next alarm */
+	if (next) {
+		struct rtc_wkalrm alarm;
+		int err;
+		alarm.time = rtc_ktime_to_tm(next->expires);
+		alarm.enabled = 1;
+		err = __rtc_set_alarm(rtc, &alarm);
+		if (err == -ETIME)
+			goto again;
+	}
+
+	mutex_unlock(&rtc->ops_lock);
+}
+
+
+/* rtc_timer_init - Initializes an rtc_timer
+ * @timer: timer to be intiialized
+ * @f: function pointer to be called when timer fires
+ * @data: private data passed to function pointer
+ *
+ * Kernel interface to initializing an rtc_timer.
+ */
+void rtc_timer_init(struct rtc_timer *timer, void (*f)(void* p), void* data)
+{
+	timerqueue_init(&timer->node);
+	timer->enabled = 0;
+	timer->task.func = f;
+	timer->task.private_data = data;
+}
+
+/* rtc_timer_start - Sets an rtc_timer to fire in the future
+ * @ rtc: rtc device to be used
+ * @ timer: timer being set
+ * @ expires: time at which to expire the timer
+ * @ period: period that the timer will recur
+ *
+ * Kernel interface to set an rtc_timer
+ */
+int rtc_timer_start(struct rtc_device *rtc, struct rtc_timer* timer,
+			ktime_t expires, ktime_t period)
+{
+	int ret = 0;
+	mutex_lock(&rtc->ops_lock);
+	if (timer->enabled)
+		rtc_timer_remove(rtc, timer);
+
+	timer->node.expires = expires;
+	timer->period = period;
+
+	ret = rtc_timer_enqueue(rtc, timer);
+
+	mutex_unlock(&rtc->ops_lock);
+	return ret;
+}
+
+/* rtc_timer_cancel - Stops an rtc_timer
+ * @ rtc: rtc device to be used
+ * @ timer: timer being set
+ *
+ * Kernel interface to cancel an rtc_timer
+ */
+int rtc_timer_cancel(struct rtc_device *rtc, struct rtc_timer* timer)
+{
+	int ret = 0;
+	mutex_lock(&rtc->ops_lock);
+	if (timer->enabled)
+		rtc_timer_remove(rtc, timer);
+	mutex_unlock(&rtc->ops_lock);
+	return ret;
+}
+
+
diff -Nurp linux/drivers/rtc/#rtc-cmos.c# linux-3.0/drivers/rtc/#rtc-cmos.c#
--- linux/drivers/rtc/#rtc-cmos.c#	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/drivers/rtc/#rtc-cmos.c#	2014-02-19 21:03:24.431264848 -0500
@@ -0,0 +1,1194 @@
+/*
+ * RTC class driver for "CMOS RTC":  PCs, ACPI, etc
+ *
+ * Copyright (C) 1996 Paul Gortmaker (drivers/char/rtc.c)
+ * Copyright (C) 2006 David Brownell (convert to new framework)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ * The original "cmos clock" chip was an MC146818 chip, now obsolete.
+ * That defined the register interface now provided by all PCs, some
+ * non-PC systems, and incorporated into ACPI.  Modern PC chipsets
+ * integrate an MC146818 clone in their southbridge, and boards use
+ * that instead of discrete clones like the DS12887 or M48T86.  There
+ * are also clones that connect using the LPC bus.
+ *
+ * That register API is also used directly by various other drivers
+ * (notably for integrated NVRAM), infrastructure (x86 has code to
+ * bypass the RTC framework, directly reading the RTC during boot
+ * and updating minutes/seconds for systems using NTP synch) and
+ * utilities (like userspace 'hwclock', if no /dev node exists).
+ *
+ * So **ALL** calls to CMOS_READ and CMOS_WRITE must be done with
+ * interrupts disabled, holding the global rtc_lock, to exclude those
+ * other drivers and utilities on correctly configured systems.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/mod_devicetable.h>
+#include <linux/log2.h>
+#include <linux/pm.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+
+/* this is for "generic access to PC-style RTC" using CMOS_READ/CMOS_WRITE */
+#include <asm-generic/rtc.h>
+
+struct cmos_rtc {
+	struct rtc_device	*rtc;
+	struct device		*dev;
+	int			irq;
+	struct resource		*iomem;
+
+	void			(*wake_on)(struct device *);
+	void			(*wake_off)(struct device *);
+
+	u8			enabled_wake;
+	u8			suspend_ctrl;
+
+	/* newer hardware extends the original register set */
+	u8			day_alrm;
+	u8			mon_alrm;
+	u8			century;
+};
+
+/* both platform and pnp busses use negative numbers for invalid irqs */
+#define is_valid_irq(n)		((n) > 0)
+
+static const char driver_name[] = "rtc_cmos";
+
+/* The RTC_INTR register may have e.g. RTC_PF set even if RTC_PIE is clear;
+ * always mask it against the irq enable bits in RTC_CONTROL.  Bit values
+ * are the same: PF==PIE, AF=AIE, UF=UIE; so RTC_IRQMASK works with both.
+ */
+#define	RTC_IRQMASK	(RTC_PF | RTC_AF | RTC_UF)
+
+static inline int is_intr(u8 rtc_intr)
+{
+	if (!(rtc_intr & RTC_IRQF))
+		return 0;
+	return rtc_intr & RTC_IRQMASK;
+}
+
+/*----------------------------------------------------------------*/
+
+/* Much modern x86 hardware has HPETs (10+ MHz timers) which, because
+ * many BIOS programmers don't set up "sane mode" IRQ routing, are mostly
+ * used in a broken "legacy replacement" mode.  The breakage includes
+ * HPET #1 hijacking the IRQ for this RTC, and being unavailable for
+ * other (better) use.
+ *
+ * When that broken mode is in use, platform glue provides a partial
+ * emulation of hardware RTC IRQ facilities using HPET #1.  We don't
+ * want to use HPET for anything except those IRQs though...
+ */
+#ifdef CONFIG_HPET_EMULATE_RTC
+#include <asm/hpet.h>
+#else
+
+static inline int is_hpet_enabled(void)
+{
+	return 0;
+}
+
+static inline int hpet_mask_rtc_irq_bit(unsigned long mask)
+{
+	return 0;
+}
+
+static inline int hpet_set_rtc_irq_bit(unsigned long mask)
+{
+	return 0;
+}
+
+static inline int
+hpet_set_alarm_time(unsigned char hrs, unsigned char min, unsigned char sec)
+{
+	return 0;
+}
+
+static inline int hpet_set_periodic_freq(unsigned long freq)
+{
+	return 0;
+}
+
+static inline int hpet_rtc_dropped_irq(void)
+{
+	return 0;
+}
+
+static inline int hpet_rtc_timer_init(void)
+{
+	return 0;
+}
+
+extern irq_handler_t hpet_rtc_interrupt;
+
+static inline int hpet_register_irq_handler(irq_handler_t handler)
+{
+	return 0;
+}
+
+static inline int hpet_unregister_irq_handler(irq_handler_t handler)
+{
+	return 0;
+}
+
+#endif
+
+/*----------------------------------------------------------------*/
+
+#ifdef RTC_PORT
+
+/* Most newer x86 systems have two register banks, the first used
+ * for RTC and NVRAM and the second only for NVRAM.  Caller must
+ * own rtc_lock ... and we won't worry about access during NMI.
+ */
+#define can_bank2	true
+
+static inline unsigned char cmos_read_bank2(unsigned char addr)
+{
+	outb(addr, RTC_PORT(2));
+	return inb(RTC_PORT(3));
+}
+
+static inline void cmos_write_bank2(unsigned char val, unsigned char addr)
+{
+	outb(addr, RTC_PORT(2));
+	outb(val, RTC_PORT(2));
+}
+
+#else
+
+#define can_bank2	false
+
+static inline unsigned char cmos_read_bank2(unsigned char addr)
+{
+	return 0;
+}
+
+static inline void cmos_write_bank2(unsigned char val, unsigned char addr)
+{
+}
+
+#endif
+
+/*----------------------------------------------------------------*/
+
+static int cmos_read_time(struct device *dev, struct rtc_time *t)
+{
+	/* REVISIT:  if the clock has a "century" register, use
+	 * that instead of the heuristic in get_rtc_time().
+	 * That'll make Y3K compatility (year > 2070) easy!
+	 */
+	get_rtc_time(t);
+	return 0;
+}
+
+static int cmos_set_time(struct device *dev, struct rtc_time *t)
+{
+	/* REVISIT:  set the "century" register if available
+	 *
+	 * NOTE: this ignores the issue whereby updating the seconds
+	 * takes effect exactly 500ms after we write the register.
+	 * (Also queueing and other delays before we get this far.)
+	 */
+	return set_rtc_time(t);
+}
+
+static int cmos_read_alarm(struct device *dev, struct rtc_wkalrm *t)
+{
+	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
+	unsigned char	rtc_control;
+
+	if (!is_valid_irq(cmos->irq))
+		return -EIO;
+
+	/* Basic alarms only support hour, minute, and seconds fields.
+	 * Some also support day and month, for alarms up to a year in
+	 * the future.
+	 */
+	t->time.tm_mday = -1;
+	t->time.tm_mon = -1;
+
+	spin_lock_irq(&rtc_lock);
+	t->time.tm_sec = CMOS_READ(RTC_SECONDS_ALARM);
+	t->time.tm_min = CMOS_READ(RTC_MINUTES_ALARM);
+	t->time.tm_hour = CMOS_READ(RTC_HOURS_ALARM);
+
+	if (cmos->day_alrm) {
+		/* ignore upper bits on readback per ACPI spec */
+		t->time.tm_mday = CMOS_READ(cmos->day_alrm) & 0x3f;
+		if (!t->time.tm_mday)
+			t->time.tm_mday = -1;
+
+		if (cmos->mon_alrm) {
+			t->time.tm_mon = CMOS_READ(cmos->mon_alrm);
+			if (!t->time.tm_mon)
+				t->time.tm_mon = -1;
+		}
+	}
+
+	rtc_control = CMOS_READ(RTC_CONTROL);
+	spin_unlock_irq(&rtc_lock);
+
+	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		if (((unsigned)t->time.tm_sec) < 0x60)
+			t->time.tm_sec = bcd2bin(t->time.tm_sec);
+		else
+			t->time.tm_sec = -1;
+		if (((unsigned)t->time.tm_min) < 0x60)
+			t->time.tm_min = bcd2bin(t->time.tm_min);
+		else
+			t->time.tm_min = -1;
+		if (((unsigned)t->time.tm_hour) < 0x24)
+			t->time.tm_hour = bcd2bin(t->time.tm_hour);
+		else
+			t->time.tm_hour = -1;
+
+		if (cmos->day_alrm) {
+			if (((unsigned)t->time.tm_mday) <= 0x31)
+				t->time.tm_mday = bcd2bin(t->time.tm_mday);
+			else
+				t->time.tm_mday = -1;
+
+			if (cmos->mon_alrm) {
+				if (((unsigned)t->time.tm_mon) <= 0x12)
+					t->time.tm_mon = bcd2bin(t->time.tm_mon)-1;
+				else
+					t->time.tm_mon = -1;
+			}
+		}
+	}
+	t->time.tm_year = -1;
+
+	t->enabled = !!(rtc_control & RTC_AIE);
+	t->pending = 0;
+
+	return 0;
+}
+
+static void cmos_checkintr(struct cmos_rtc *cmos, unsigned char rtc_control)
+{
+	unsigned char	rtc_intr;
+
+	/* NOTE after changing RTC_xIE bits we always read INTR_FLAGS;
+	 * allegedly some older rtcs need that to handle irqs properly
+	 */
+	rtc_intr = CMOS_READ(RTC_INTR_FLAGS);
+
+	if (is_hpet_enabled())
+		return;
+
+	rtc_intr &= (rtc_control & RTC_IRQMASK) | RTC_IRQF;
+	if (is_intr(rtc_intr))
+		rtc_update_irq(cmos->rtc, 1, rtc_intr);
+}
+
+static void cmos_irq_enable(struct cmos_rtc *cmos, unsigned char mask)
+{
+	unsigned char	rtc_control;
+
+	/* flush any pending IRQ status, notably for update irqs,
+	 * before we enable new IRQs
+	 */
+	rtc_control = CMOS_READ(RTC_CONTROL);
+	cmos_checkintr(cmos, rtc_control);
+
+	rtc_control |= mask;
+	CMOS_WRITE(rtc_control, RTC_CONTROL);
+	hpet_set_rtc_irq_bit(mask);
+
+	cmos_checkintr(cmos, rtc_control);
+}
+
+static void cmos_irq_disable(struct cmos_rtc *cmos, unsigned char mask)
+{
+	unsigned char	rtc_control;
+
+	rtc_control = CMOS_READ(RTC_CONTROL);
+	rtc_control &= ~mask;
+	CMOS_WRITE(rtc_control, RTC_CONTROL);
+	hpet_mask_rtc_irq_bit(mask);
+
+	cmos_checkintr(cmos, rtc_control);
+}
+
+static int cmos_set_alarm(struct device *dev, struct rtc_wkalrm *t)
+{
+	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
+       unsigned char   mon, mday, hrs, min, sec, rtc_control;
+
+	if (!is_valid_irq(cmos->irq))
+		return -EIO;
+
+	mon = t->time.tm_mon + 1;
+	mday = t->time.tm_mday;
+	hrs = t->time.tm_hour;
+	min = t->time.tm_min;
+	sec = t->time.tm_sec;
+
+	rtc_control = CMOS_READ(RTC_CONTROL);
+	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		/* Writing 0xff means "don't care" or "match all".  */
+		mon = (mon <= 12) ? bin2bcd(mon) : 0xff;
+		mday = (mday >= 1 && mday <= 31) ? bin2bcd(mday) : 0xff;
+		hrs = (hrs < 24) ? bin2bcd(hrs) : 0xff;
+		min = (min < 60) ? bin2bcd(min) : 0xff;
+		sec = (sec < 60) ? bin2bcd(sec) : 0xff;
+	}
+
+	spin_lock_irq(&rtc_lock);
+
+	/* next rtc irq must not be from previous alarm setting */
+	cmos_irq_disable(cmos, RTC_AIE);
+
+	/* update alarm */
+	CMOS_WRITE(hrs, RTC_HOURS_ALARM);
+	CMOS_WRITE(min, RTC_MINUTES_ALARM);
+	CMOS_WRITE(sec, RTC_SECONDS_ALARM);
+
+	/* the system may support an "enhanced" alarm */
+	if (cmos->day_alrm) {
+		CMOS_WRITE(mday, cmos->day_alrm);
+		if (cmos->mon_alrm)
+			CMOS_WRITE(mon, cmos->mon_alrm);
+	}
+
+	/* FIXME the HPET alarm glue currently ignores day_alrm
+	 * and mon_alrm ...
+	 */
+	hpet_set_alarm_time(t->time.tm_hour, t->time.tm_min, t->time.tm_sec);
+
+	if (t->enabled)
+		cmos_irq_enable(cmos, RTC_AIE);
+
+	spin_unlock_irq(&rtc_lock);
+
+	return 0;
+}
+
+static int cmos_alarm_irq_enable(struct device *dev, unsigned int enabled)
+{
+	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
+	unsigned long	flags;
+
+	if (!is_valid_irq(cmos->irq))
+		return -EINVAL;
+
+	spin_lock_irqsave(&rtc_lock, flags);
+
+	if (enabled)
+		cmos_irq_enable(cmos, RTC_AIE);
+	else
+		cmos_irq_disable(cmos, RTC_AIE);
+
+	spin_unlock_irqrestore(&rtc_lock, flags);
+	return 0;
+}
+
+#if defined(CONFIG_RTC_INTF_PROC) || defined(CONFIG_RTC_INTF_PROC_MODULE)
+
+static int cmos_procfs(struct device *dev, struct seq_file *seq)
+{
+	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
+	unsigned char	rtc_control, valid;
+
+	spin_lock_irq(&rtc_lock);
+	rtc_control = CMOS_READ(RTC_CONTROL);
+	valid = CMOS_READ(RTC_VALID);
+	spin_unlock_irq(&rtc_lock);
+
+	/* NOTE:  at least ICH6 reports battery status using a different
+	 * (non-RTC) bit; and SQWE is ignored on many current systems.
+	 */
+	return seq_printf(seq,
+			"periodic_IRQ\t: %s\n"
+			"update_IRQ\t: %s\n"
+			"HPET_emulated\t: %s\n"
+			// "square_wave\t: %s\n"
+			"BCD\t\t: %s\n"
+			"DST_enable\t: %s\n"
+			"periodic_freq\t: %d\n"
+			"batt_status\t: %s\n",
+			(rtc_control & RTC_PIE) ? "yes" : "no",
+			(rtc_control & RTC_UIE) ? "yes" : "no",
+			is_hpet_enabled() ? "yes" : "no",
+			// (rtc_control & RTC_SQWE) ? "yes" : "no",
+			(rtc_control & RTC_DM_BINARY) ? "no" : "yes",
+			(rtc_control & RTC_DST_EN) ? "yes" : "no",
+			cmos->rtc->irq_freq,
+			(valid & RTC_VRT) ? "okay" : "dead");
+}
+
+#else
+#define	cmos_procfs	NULL
+#endif
+
+static const struct rtc_class_ops cmos_rtc_ops = {
+	.read_time		= cmos_read_time,
+	.set_time		= cmos_set_time,
+	.read_alarm		= cmos_read_alarm,
+	.set_alarm		= cmos_set_alarm,
+	.proc			= cmos_procfs,
+	.alarm_irq_enable	= cmos_alarm_irq_enable,
+};
+
+/*----------------------------------------------------------------*/
+
+/*
+ * All these chips have at least 64 bytes of address space, shared by
+ * RTC registers and NVRAM.  Most of those bytes of NVRAM are used
+ * by boot firmware.  Modern chips have 128 or 256 bytes.
+ */
+
+#define NVRAM_OFFSET	(RTC_REG_D + 1)
+
+static ssize_t
+cmos_nvram_read(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	int	retval;
+
+	if (unlikely(off >= attr->size))
+		return 0;
+	if (unlikely(off < 0))
+		return -EINVAL;
+	if ((off + count) > attr->size)
+		count = attr->size - off;
+
+	off += NVRAM_OFFSET;
+	spin_lock_irq(&rtc_lock);
+	for (retval = 0; count; count--, off++, retval++) {
+		if (off < 128)
+			*buf++ = CMOS_READ(off);
+		else if (can_bank2)
+			*buf++ = cmos_read_bank2(off);
+		else
+			break;
+	}
+	spin_unlock_irq(&rtc_lock);
+
+	return retval;
+}
+
+static ssize_t
+cmos_nvram_write(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct cmos_rtc	*cmos;
+	int		retval;
+
+	cmos = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	if (unlikely(off >= attr->size))
+		return -EFBIG;
+	if (unlikely(off < 0))
+		return -EINVAL;
+	if ((off + count) > attr->size)
+		count = attr->size - off;
+
+	/* NOTE:  on at least PCs and Ataris, the boot firmware uses a
+	 * checksum on part of the NVRAM data.  That's currently ignored
+	 * here.  If userspace is smart enough to know what fields of
+	 * NVRAM to update, updating checksums is also part of its job.
+	 */
+	off += NVRAM_OFFSET;
+	spin_lock_irq(&rtc_lock);
+	for (retval = 0; count; count--, off++, retval++) {
+		/* don't trash RTC registers */
+		if (off == cmos->day_alrm
+				|| off == cmos->mon_alrm
+				|| off == cmos->century)
+			buf++;
+		else if (off < 128)
+			CMOS_WRITE(*buf++, off);
+		else if (can_bank2)
+			cmos_write_bank2(*buf++, off);
+		else
+			break;
+	}
+	spin_unlock_irq(&rtc_lock);
+
+	return retval;
+}
+
+static struct bin_attribute nvram = {
+	.attr = {
+		.name	= "nvram",
+		.mode	= S_IRUGO | S_IWUSR,
+	},
+
+	.read	= cmos_nvram_read,
+	.write	= cmos_nvram_write,
+	/* size gets set up later */
+};
+
+/*----------------------------------------------------------------*/
+
+static struct cmos_rtc	cmos_rtc;
+
+static irqreturn_t cmos_interrupt(int irq, void *p)
+{
+	u8		irqstat;
+	u8		rtc_control;
+
+	spin_lock(&rtc_lock);
+
+	/* When the HPET interrupt handler calls us, the interrupt
+	 * status is passed as arg1 instead of the irq number.  But
+	 * always clear irq status, even when HPET is in the way.
+	 *
+	 * Note that HPET and RTC are almost certainly out of phase,
+	 * giving different IRQ status ...
+	 */
+	irqstat = CMOS_READ(RTC_INTR_FLAGS);
+	rtc_control = CMOS_READ(RTC_CONTROL);
+	if (is_hpet_enabled())
+		irqstat = (unsigned long)irq & 0xF0;
+	irqstat &= (rtc_control & RTC_IRQMASK) | RTC_IRQF;
+
+	/* All Linux RTC alarms should be treated as if they were oneshot.
+	 * Similar code may be needed in system wakeup paths, in case the
+	 * alarm woke the system.
+	 */
+	if (irqstat & RTC_AIE) {
+		rtc_control &= ~RTC_AIE;
+		CMOS_WRITE(rtc_control, RTC_CONTROL);
+		hpet_mask_rtc_irq_bit(RTC_AIE);
+
+		CMOS_READ(RTC_INTR_FLAGS);
+	}
+	spin_unlock(&rtc_lock);
+
+	if (is_intr(irqstat)) {
+		rtc_update_irq(p, 1, irqstat);
+		return IRQ_HANDLED;
+	} else
+		return IRQ_NONE;
+}
+
+#ifdef	CONFIG_PNP
+#define	INITSECTION
+
+#else
+#define	INITSECTION	__init
+#endif
+
+static int INITSECTION
+cmos_do_probe(struct device *dev, struct resource *ports, int rtc_irq)
+{
+	struct cmos_rtc_board_info	*info = dev->platform_data;
+	int				retval = 0;
+	unsigned char			rtc_control;
+	unsigned			address_space;
+
+	/* there can be only one ... */
+	if (cmos_rtc.dev)
+		return -EBUSY;
+
+	if (!ports)
+		return -ENODEV;
+
+	/* Claim I/O ports ASAP, minimizing conflict with legacy driver.
+	 *
+	 * REVISIT non-x86 systems may instead use memory space resources
+	 * (needing ioremap etc), not i/o space resources like this ...
+	 */
+	ports = request_region(ports->start,
+			ports->end + 1 - ports->start,
+			driver_name);
+	if (!ports) {
+		dev_dbg(dev, "i/o registers already in use\n");
+		return -EBUSY;
+	}
+
+	cmos_rtc.irq = rtc_irq;
+	cmos_rtc.iomem = ports;
+
+	/* Heuristic to deduce NVRAM size ... do what the legacy NVRAM
+	 * driver did, but don't reject unknown configs.   Old hardware
+	 * won't address 128 bytes.  Newer chips have multiple banks,
+	 * though they may not be listed in one I/O resource.
+	 */
+#if	defined(CONFIG_ATARI)
+	address_space = 64;
+#elif defined(__i386__) || defined(__x86_64__) || defined(__arm__) \
+			|| defined(__sparc__) || defined(__mips__) \
+			|| defined(__powerpc__)
+	address_space = 128;
+#else
+#warning Assuming 128 bytes of RTC+NVRAM address space, not 64 bytes.
+	address_space = 128;
+#endif
+	if (can_bank2 && ports->end > (ports->start + 1))
+		address_space = 256;
+
+	/* For ACPI systems extension info comes from the FADT.  On others,
+	 * board specific setup provides it as appropriate.  Systems where
+	 * the alarm IRQ isn't automatically a wakeup IRQ (like ACPI, and
+	 * some almost-clones) can provide hooks to make that behave.
+	 *
+	 * Note that ACPI doesn't preclude putting these registers into
+	 * "extended" areas of the chip, including some that we won't yet
+	 * expect CMOS_READ and friends to handle.
+	 */
+	if (info) {
+		if (info->rtc_day_alarm && info->rtc_day_alarm < 128)
+			cmos_rtc.day_alrm = info->rtc_day_alarm;
+		if (info->rtc_mon_alarm && info->rtc_mon_alarm < 128)
+			cmos_rtc.mon_alrm = info->rtc_mon_alarm;
+		if (info->rtc_century && info->rtc_century < 128)
+			cmos_rtc.century = info->rtc_century;
+
+		if (info->wake_on && info->wake_off) {
+			cmos_rtc.wake_on = info->wake_on;
+			cmos_rtc.wake_off = info->wake_off;
+		}
+	}
+
+	cmos_rtc.dev = dev;
+	dev_set_drvdata(dev, &cmos_rtc);
+
+	cmos_rtc.rtc = rtc_device_register(driver_name, dev,
+				&cmos_rtc_ops, THIS_MODULE);
+	if (IS_ERR(cmos_rtc.rtc)) {
+		retval = PTR_ERR(cmos_rtc.rtc);
+		goto cleanup0;
+	}
+
+	rename_region(ports, dev_name(&cmos_rtc.rtc->dev));
+
+	spin_lock_irq(&rtc_lock);
+
+	/* force periodic irq to CMOS reset default of 1024Hz;
+	 *
+	 * REVISIT it's been reported that at least one x86_64 ALI mobo
+	 * doesn't use 32KHz here ... for portability we might need to
+	 * do something about other clock frequencies.
+	 */
+	cmos_rtc.rtc->irq_freq = 1024;
+	hpet_set_periodic_freq(cmos_rtc.rtc->irq_freq);
+	CMOS_WRITE(RTC_REF_CLCK_32KHZ | 0x06, RTC_FREQ_SELECT);
+
+	/* disable irqs */
+	cmos_irq_disable(&cmos_rtc, RTC_PIE | RTC_AIE | RTC_UIE);
+
+	rtc_control = CMOS_READ(RTC_CONTROL);
+
+	spin_unlock_irq(&rtc_lock);
+
+	/* FIXME:
+	 * <asm-generic/rtc.h> doesn't know 12-hour mode either.
+	 */
+       if (is_valid_irq(rtc_irq) && !(rtc_control & RTC_24H)) {
+		dev_warn(dev, "only 24-hr supported\n");
+		retval = -ENXIO;
+		goto cleanup1;
+	}
+
+	if (is_valid_irq(rtc_irq)) {
+		irq_handler_t rtc_cmos_int_handler;
+
+		if (is_hpet_enabled()) {
+			int err;
+
+			rtc_cmos_int_handler = hpet_rtc_interrupt;
+			err = hpet_register_irq_handler(cmos_interrupt);
+			if (err != 0) {
+				printk(KERN_WARNING "hpet_register_irq_handler "
+						" failed in rtc_init().");
+				goto cleanup1;
+			}
+		} else
+			rtc_cmos_int_handler = cmos_interrupt;
+
+		retval = request_irq(rtc_irq, rtc_cmos_int_handler,
+				IRQF_DISABLED, dev_name(&cmos_rtc.rtc->dev),
+				cmos_rtc.rtc);
+		if (retval < 0) {
+			dev_dbg(dev, "IRQ %d is already in use\n", rtc_irq);
+			goto cleanup1;
+		}
+	}
+	hpet_rtc_timer_init();
+
+	/* export at least the first block of NVRAM */
+	nvram.size = address_space - NVRAM_OFFSET;
+	retval = sysfs_create_bin_file(&dev->kobj, &nvram);
+	if (retval < 0) {
+		dev_dbg(dev, "can't create nvram file? %d\n", retval);
+		goto cleanup2;
+	}
+
+	pr_info("%s: %s%s, %zd bytes nvram%s\n",
+		dev_name(&cmos_rtc.rtc->dev),
+		!is_valid_irq(rtc_irq) ? "no alarms" :
+			cmos_rtc.mon_alrm ? "alarms up to one year" :
+			cmos_rtc.day_alrm ? "alarms up to one month" :
+			"alarms up to one day",
+		cmos_rtc.century ? ", y3k" : "",
+		nvram.size,
+		is_hpet_enabled() ? ", hpet irqs" : "");
+
+	return 0;
+
+cleanup2:
+	if (is_valid_irq(rtc_irq))
+		free_irq(rtc_irq, cmos_rtc.rtc);
+cleanup1:
+	cmos_rtc.dev = NULL;
+	rtc_device_unregister(cmos_rtc.rtc);
+cleanup0:
+	release_region(ports->start, ports->end + 1 - ports->start);
+	return retval;
+}
+
+static void cmos_do_shutdown(void)
+{
+	spin_lock_irq(&rtc_lock);
+	cmos_irq_disable(&cmos_rtc, RTC_IRQMASK);
+	spin_unlock_irq(&rtc_lock);
+}
+
+static void __exit cmos_do_remove(struct device *dev)
+{
+	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
+	struct resource *ports;
+
+	cmos_do_shutdown();
+
+	sysfs_remove_bin_file(&dev->kobj, &nvram);
+
+	if (is_valid_irq(cmos->irq)) {
+		free_irq(cmos->irq, cmos->rtc);
+		hpet_unregister_irq_handler(cmos_interrupt);
+	}
+
+	rtc_device_unregister(cmos->rtc);
+	cmos->rtc = NULL;
+
+	ports = cmos->iomem;
+	release_region(ports->start, ports->end + 1 - ports->start);
+	cmos->iomem = NULL;
+
+	cmos->dev = NULL;
+	dev_set_drvdata(dev, NULL);
+}
+
+#ifdef	CONFIG_PM
+
+static int cmos_suspend(struct device *dev)
+{
+	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
+	unsigned char	tmp;
+
+	/* only the alarm might be a wakeup event source */
+	spin_lock_irq(&rtc_lock);
+	cmos->suspend_ctrl = tmp = CMOS_READ(RTC_CONTROL);
+	if (tmp & (RTC_PIE|RTC_AIE|RTC_UIE)) {
+		unsigned char	mask;
+
+		if (device_may_wakeup(dev))
+			mask = RTC_IRQMASK & ~RTC_AIE;
+		else
+			mask = RTC_IRQMASK;
+		tmp &= ~mask;
+		CMOS_WRITE(tmp, RTC_CONTROL);
+
+		/* shut down hpet emulation - we don't need it for alarm */
+		hpet_mask_rtc_irq_bit(RTC_PIE|RTC_AIE|RTC_UIE);
+		cmos_checkintr(cmos, tmp);
+	}
+	spin_unlock_irq(&rtc_lock);
+
+	if (tmp & RTC_AIE) {
+		cmos->enabled_wake = 1;
+		if (cmos->wake_on)
+			cmos->wake_on(dev);
+		else
+			enable_irq_wake(cmos->irq);
+	}
+
+	pr_debug("%s: suspend%s, ctrl %02x\n",
+			dev_name(&cmos_rtc.rtc->dev),
+			(tmp & RTC_AIE) ? ", alarm may wake" : "",
+			tmp);
+
+	return 0;
+}
+
+/* We want RTC alarms to wake us from e.g. ACPI G2/S5 "soft off", even
+ * after a detour through G3 "mechanical off", although the ACPI spec
+ * says wakeup should only work from G1/S4 "hibernate".  To most users,
+ * distinctions between S4 and S5 are pointless.  So when the hardware
+ * allows, don't draw that distinction.
+ */
+static inline int cmos_poweroff(struct device *dev)
+{
+	return cmos_suspend(dev);
+}
+
+static int cmos_resume(struct device *dev)
+{
+	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
+	unsigned char	tmp = cmos->suspend_ctrl;
+
+	/* re-enable any irqs previously active */
+	if (tmp & RTC_IRQMASK) {
+		unsigned char	mask;
+
+		if (cmos->enabled_wake) {
+			if (cmos->wake_off)
+				cmos->wake_off(dev);
+			else
+				disable_irq_wake(cmos->irq);
+			cmos->enabled_wake = 0;
+		}
+
+		spin_lock_irq(&rtc_lock);
+		do {
+			CMOS_WRITE(tmp, RTC_CONTROL);
+			hpet_set_rtc_irq_bit(tmp & RTC_IRQMASK);
+
+			mask = CMOS_READ(RTC_INTR_FLAGS);
+			mask &= (tmp & RTC_IRQMASK) | RTC_IRQF;
+			if (!is_hpet_enabled() || !is_intr(mask))
+				break;
+
+			/* force one-shot behavior if HPET blocked
+			 * the wake alarm's irq
+			 */
+			rtc_update_irq(cmos->rtc, 1, mask);
+			tmp &= ~RTC_AIE;
+			hpet_mask_rtc_irq_bit(RTC_AIE);
+		} while (mask & RTC_AIE);
+		spin_unlock_irq(&rtc_lock);
+	}
+
+	pr_debug("%s: resume, ctrl %02x\n",
+			dev_name(&cmos_rtc.rtc->dev),
+			tmp);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(cmos_pm_ops, cmos_suspend, cmos_resume);
+
+#else
+
+static inline int cmos_poweroff(struct device *dev)
+{
+	return -ENOSYS;
+}
+
+#endif
+
+/*----------------------------------------------------------------*/
+
+/* On non-x86 systems, a "CMOS" RTC lives most naturally on platform_bus.
+ * ACPI systems always list these as PNPACPI devices, and pre-ACPI PCs
+ * probably list them in similar PNPBIOS tables; so PNP is more common.
+ *
+ * We don't use legacy "poke at the hardware" probing.  Ancient PCs that
+ * predate even PNPBIOS should set up platform_bus devices.
+ */
+
+#ifdef	CONFIG_ACPI
+
+#include <linux/acpi.h>
+
+static u32 rtc_handler(void *context)
+{
+	acpi_clear_event(ACPI_EVENT_RTC);
+	acpi_disable_event(ACPI_EVENT_RTC, 0);
+	return ACPI_INTERRUPT_HANDLED;
+}
+
+static inline void rtc_wake_setup(void)
+{
+	acpi_install_fixed_event_handler(ACPI_EVENT_RTC, rtc_handler, NULL);
+	/*
+	 * After the RTC handler is installed, the Fixed_RTC event should
+	 * be disabled. Only when the RTC alarm is set will it be enabled.
+	 */
+	acpi_clear_event(ACPI_EVENT_RTC);
+	acpi_disable_event(ACPI_EVENT_RTC, 0);
+}
+
+static void rtc_wake_on(struct device *dev)
+{
+	acpi_clear_event(ACPI_EVENT_RTC);
+	acpi_enable_event(ACPI_EVENT_RTC, 0);
+}
+
+static void rtc_wake_off(struct device *dev)
+{
+	acpi_disable_event(ACPI_EVENT_RTC, 0);
+}
+
+/* Every ACPI platform has a mc146818 compatible "cmos rtc".  Here we find
+ * its device node and pass extra config data.  This helps its driver use
+ * capabilities that the now-obsolete mc146818 didn't have, and informs it
+ * that this board's RTC is wakeup-capable (per ACPI spec).
+ */
+static struct cmos_rtc_board_info acpi_rtc_info;
+
+static void __devinit
+cmos_wake_setup(struct device *dev)
+{
+	if (acpi_disabled)
+		return;
+
+	rtc_wake_setup();
+	acpi_rtc_info.wake_on = rtc_wake_on;
+	acpi_rtc_info.wake_off = rtc_wake_off;
+
+	/* workaround bug in some ACPI tables */
+	if (acpi_gbl_FADT.month_alarm && !acpi_gbl_FADT.day_alarm) {
+		dev_dbg(dev, "bogus FADT month_alarm (%d)\n",
+			acpi_gbl_FADT.month_alarm);
+		acpi_gbl_FADT.month_alarm = 0;
+	}
+
+	acpi_rtc_info.rtc_day_alarm = acpi_gbl_FADT.day_alarm;
+	acpi_rtc_info.rtc_mon_alarm = acpi_gbl_FADT.month_alarm;
+	acpi_rtc_info.rtc_century = acpi_gbl_FADT.century;
+
+	/* NOTE:  S4_RTC_WAKE is NOT currently useful to Linux */
+	if (acpi_gbl_FADT.flags & ACPI_FADT_S4_RTC_WAKE)
+		dev_info(dev, "RTC can wake from S4\n");
+
+	dev->platform_data = &acpi_rtc_info;
+
+	/* RTC always wakes from S1/S2/S3, and often S4/STD */
+	device_init_wakeup(dev, 1);
+}
+
+#else
+
+static void __devinit
+cmos_wake_setup(struct device *dev)
+{
+}
+
+#endif
+
+#ifdef	CONFIG_PNP
+
+#include <linux/pnp.h>
+
+static int __devinit
+cmos_pnp_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)
+{
+	cmos_wake_setup(&pnp->dev);
+
+	if (pnp_port_start(pnp,0) == 0x70 && !pnp_irq_valid(pnp,0))
+		/* Some machines contain a PNP entry for the RTC, but
+		 * don't define the IRQ. It should always be safe to
+		 * hardcode it in these cases
+		 */
+		return cmos_do_probe(&pnp->dev,
+				pnp_get_resource(pnp, IORESOURCE_IO, 0), 8);
+	else
+		return cmos_do_probe(&pnp->dev,
+				pnp_get_resource(pnp, IORESOURCE_IO, 0),
+				pnp_irq(pnp, 0));
+}
+
+static void __exit cmos_pnp_remove(struct pnp_dev *pnp)
+{
+	cmos_do_remove(&pnp->dev);
+}
+
+#ifdef	CONFIG_PM
+
+static int cmos_pnp_suspend(struct pnp_dev *pnp, pm_message_t mesg)
+{
+	return cmos_suspend(&pnp->dev);
+}
+
+static int cmos_pnp_resume(struct pnp_dev *pnp)
+{
+	return cmos_resume(&pnp->dev);
+}
+
+#else
+#define	cmos_pnp_suspend	NULL
+#define	cmos_pnp_resume		NULL
+#endif
+
+static void cmos_pnp_shutdown(struct pnp_dev *pnp)
+{
+	if (system_state == SYSTEM_POWER_OFF && !cmos_poweroff(&pnp->dev))
+		return;
+
+	cmos_do_shutdown();
+}
+
+static const struct pnp_device_id rtc_ids[] = {
+	{ .id = "PNP0b00", },
+	{ .id = "PNP0b01", },
+	{ .id = "PNP0b02", },
+	{ },
+};
+MODULE_DEVICE_TABLE(pnp, rtc_ids);
+
+static struct pnp_driver cmos_pnp_driver = {
+	.name		= (char *) driver_name,
+	.id_table	= rtc_ids,
+	.probe		= cmos_pnp_probe,
+	.remove		= __exit_p(cmos_pnp_remove),
+	.shutdown	= cmos_pnp_shutdown,
+
+	/* flag ensures resume() gets called, and stops syslog spam */
+	.flags		= PNP_DRIVER_RES_DO_NOT_CHANGE,
+	.suspend	= cmos_pnp_suspend,
+	.resume		= cmos_pnp_resume,
+};
+
+#endif	/* CONFIG_PNP */
+
+#ifdef CONFIG_OF
+static const struct of_device_id of_cmos_match[] = {
+	{
+		.compatible = "motorola,mc146818",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, of_cmos_match);
+
+static __init void cmos_of_init(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct rtc_time time;
+	int ret;
+	const __be32 *val;
+
+	if (!node)
+		return;
+
+	val = of_get_property(node, "ctrl-reg", NULL);
+	if (val)
+		CMOS_WRITE(be32_to_cpup(val), RTC_CONTROL);
+
+	val = of_get_property(node, "freq-reg", NULL);
+	if (val)
+		CMOS_WRITE(be32_to_cpup(val), RTC_FREQ_SELECT);
+
+	get_rtc_time(&time);
+	ret = rtc_valid_tm(&time);
+	if (ret) {
+		struct rtc_time def_time = {
+			.tm_year = 1,
+			.tm_mday = 1,
+		};
+		set_rtc_time(&def_time);
+	}
+}
+#else
+static inline void cmos_of_init(struct platform_device *pdev) {}
+#define of_cmos_match NULL
+#endif
+/*----------------------------------------------------------------*/
+
+/* Platform setup should have set up an RTC device, when PNP is
+ * unavailable ... this could happen even on (older) PCs.
+ */
+
+static int __init cmos_platform_probe(struct platform_device *pdev)
+{
+	cmos_of_init(pdev);
+	cmos_wake_setup(&pdev->dev);
+	return cmos_do_probe(&pdev->dev,
+			platform_get_resource(pdev, IORESOURCE_IO, 0),
+			platform_get_irq(pdev, 0));
+}
+
+static int __exit cmos_platform_remove(struct platform_device *pdev)
+{
+	cmos_do_remove(&pdev->dev);
+	return 0;
+}
+
+static void cmos_platform_shutdown(struct platform_device *pdev)
+{
+	if (system_state == SYSTEM_POWER_OFF && !cmos_poweroff(&pdev->dev))
+		return;
+
+	cmos_do_shutdown();
+}
+
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:rtc_cmos");
+
+static struct platform_driver cmos_platform_driver = {
+	.remove		= __exit_p(cmos_platform_remove),
+	.shutdown	= cmos_platform_shutdown,
+	.driver = {
+		.name		= (char *) driver_name,
+#ifdef CONFIG_PM
+		.pm		= &cmos_pm_ops,
+#endif
+		.of_match_table = of_cmos_match,
+	}
+};
+
+#ifdef CONFIG_PNP
+static bool pnp_driver_registered;
+#endif
+static bool platform_driver_registered;
+
+static int __init cmos_init(void)
+{
+	int retval = 0;
+
+#ifdef	CONFIG_PNP
+	retval = pnp_register_driver(&cmos_pnp_driver);
+	if (retval == 0)
+		pnp_driver_registered = true;
+#endif
+
+	if (!cmos_rtc.dev) {
+		retval = platform_driver_probe(&cmos_platform_driver,
+					       cmos_platform_probe);
+		if (retval == 0)
+			platform_driver_registered = true;
+	}
+
+	if (retval == 0)
+		return 0;
+
+#ifdef	CONFIG_PNP
+	if (pnp_driver_registered)
+		pnp_unregister_driver(&cmos_pnp_driver);
+#endif
+	return retval;
+}
+module_init(cmos_init);
+
+static void __exit cmos_exit(void)
+{
+#ifdef	CONFIG_PNP
+	if (pnp_driver_registered)
+		pnp_unregister_driver(&cmos_pnp_driver);
+#endif
+	if (platform_driver_registered)
+		platform_driver_unregister(&cmos_platform_driver);
+}
+module_exit(cmos_exit);
+
+
+MODULE_AUTHOR("David Brownell");
+MODULE_DESCRIPTION("Driver for PC-style 'CMOS' RTCs");
+MODULE_LICENSE("GPL");
diff -Nurp linux/drivers/rtc/#rtc-dev.c# linux-3.0/drivers/rtc/#rtc-dev.c#
--- linux/drivers/rtc/#rtc-dev.c#	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/drivers/rtc/#rtc-dev.c#	2014-02-19 21:03:24.445265165 -0500
@@ -0,0 +1,529 @@
+/*
+ * RTC subsystem, dev interface
+ *
+ * Copyright (C) 2005 Tower Technologies
+ * Author: Alessandro Zummo <a.zummo@towertech.it>
+ *
+ * based on arch/arm/common/rtctime.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/module.h>
+#include <linux/rtc.h>
+#include <linux/sched.h>
+#include "rtc-core.h"
+
+static dev_t rtc_devt;
+
+#define RTC_DEV_MAX 16 /* 16 RTCs should be enough for everyone... */
+
+static int rtc_dev_open(struct inode *inode, struct file *file)
+{
+	int err;
+	struct rtc_device *rtc = container_of(inode->i_cdev,
+					struct rtc_device, char_dev);
+	const struct rtc_class_ops *ops = rtc->ops;
+
+	if (test_and_set_bit_lock(RTC_DEV_BUSY, &rtc->flags))
+		return -EBUSY;
+
+	file->private_data = rtc;
+
+	err = ops->open ? ops->open(rtc->dev.parent) : 0;
+	if (err == 0) {
+		spin_lock_irq(&rtc->irq_lock);
+		rtc->irq_data = 0;
+		spin_unlock_irq(&rtc->irq_lock);
+
+		return 0;
+	}
+
+	/* something has gone wrong */
+	clear_bit_unlock(RTC_DEV_BUSY, &rtc->flags);
+	return err;
+}
+
+#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL
+/*
+ * Routine to poll RTC seconds field for change as often as possible,
+ * after first RTC_UIE use timer to reduce polling
+ */
+static void rtc_uie_task(struct work_struct *work)
+{
+	struct rtc_device *rtc =
+		container_of(work, struct rtc_device, uie_task);
+	struct rtc_time tm;
+	int num = 0;
+	int err;
+
+	err = rtc_read_time(rtc, &tm);
+
+	spin_lock_irq(&rtc->irq_lock);
+	if (rtc->stop_uie_polling || err) {
+		rtc->uie_task_active = 0;
+	} else if (rtc->oldsecs != tm.tm_sec) {
+		num = (tm.tm_sec + 60 - rtc->oldsecs) % 60;
+		rtc->oldsecs = tm.tm_sec;
+		rtc->uie_timer.expires = jiffies + HZ - (HZ/10);
+		rtc->uie_timer_active = 1;
+		rtc->uie_task_active = 0;
+		add_timer(&rtc->uie_timer);
+	} else if (schedule_work(&rtc->uie_task) == 0) {
+		rtc->uie_task_active = 0;
+	}
+	spin_unlock_irq(&rtc->irq_lock);
+	if (num)
+		rtc_handle_legacy_irq(rtc, num, RTC_UF);
+}
+static void rtc_uie_timer(unsigned long data)
+{
+	struct rtc_device *rtc = (struct rtc_device *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rtc->irq_lock, flags);
+	rtc->uie_timer_active = 0;
+	rtc->uie_task_active = 1;
+	if ((schedule_work(&rtc->uie_task) == 0))
+		rtc->uie_task_active = 0;
+	spin_unlock_irqrestore(&rtc->irq_lock, flags);
+}
+
+static int clear_uie(struct rtc_device *rtc)
+{
+	spin_lock_irq(&rtc->irq_lock);
+	if (rtc->uie_irq_active) {
+		rtc->stop_uie_polling = 1;
+		if (rtc->uie_timer_active) {
+			spin_unlock_irq(&rtc->irq_lock);
+			del_timer_sync(&rtc->uie_timer);
+			spin_lock_irq(&rtc->irq_lock);
+			rtc->uie_timer_active = 0;
+		}
+		if (rtc->uie_task_active) {
+			spin_unlock_irq(&rtc->irq_lock);
+			flush_scheduled_work();
+			spin_lock_irq(&rtc->irq_lock);
+		}
+		rtc->uie_irq_active = 0;
+	}
+	spin_unlock_irq(&rtc->irq_lock);
+	return 0;
+}
+
+static int set_uie(struct rtc_device *rtc)
+{
+	struct rtc_time tm;
+	int err;
+
+	err = rtc_read_time(rtc, &tm);
+	if (err)
+		return err;
+	spin_lock_irq(&rtc->irq_lock);
+	if (!rtc->uie_irq_active) {
+		rtc->uie_irq_active = 1;
+		rtc->stop_uie_polling = 0;
+		rtc->oldsecs = tm.tm_sec;
+		rtc->uie_task_active = 1;
+		if (schedule_work(&rtc->uie_task) == 0)
+			rtc->uie_task_active = 0;
+	}
+	rtc->irq_data = 0;
+	spin_unlock_irq(&rtc->irq_lock);
+	return 0;
+}
+
+int rtc_dev_update_irq_enable_emul(struct rtc_device *rtc, unsigned int enabled)
+{
+	if (enabled)
+		return set_uie(rtc);
+	else
+		return clear_uie(rtc);
+}
+EXPORT_SYMBOL(rtc_dev_update_irq_enable_emul);
+
+#endif /* CONFIG_RTC_INTF_DEV_UIE_EMUL */
+
+static ssize_t
+rtc_dev_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	struct rtc_device *rtc = file->private_data;
+
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long data;
+	ssize_t ret;
+
+	if (count != sizeof(unsigned int) && count < sizeof(unsigned long))
+		return -EINVAL;
+
+	add_wait_queue(&rtc->irq_queue, &wait);
+	do {
+		__set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_irq(&rtc->irq_lock);
+		data = rtc->irq_data;
+		rtc->irq_data = 0;
+		spin_unlock_irq(&rtc->irq_lock);
+
+		if (data != 0) {
+			ret = 0;
+			break;
+		}
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			break;
+		}
+		if (signal_pending(current)) {
+			ret = -ERESTARTSYS;
+			break;
+		}
+		schedule();
+	} while (1);
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&rtc->irq_queue, &wait);
+
+	if (ret == 0) {
+		/* Check for any data updates */
+		if (rtc->ops->read_callback)
+			data = rtc->ops->read_callback(rtc->dev.parent,
+						       data);
+
+		if (sizeof(int) != sizeof(long) &&
+		    count == sizeof(unsigned int))
+			ret = put_user(data, (unsigned int __user *)buf) ?:
+				sizeof(unsigned int);
+		else
+			ret = put_user(data, (unsigned long __user *)buf) ?:
+				sizeof(unsigned long);
+	}
+	return ret;
+}
+
+static unsigned int rtc_dev_poll(struct file *file, poll_table *wait)
+{
+	struct rtc_device *rtc = file->private_data;
+	unsigned long data;
+
+	poll_wait(file, &rtc->irq_queue, wait);
+
+	data = rtc->irq_data;
+
+	return (data != 0) ? (POLLIN | POLLRDNORM) : 0;
+}
+
+static long rtc_dev_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	struct rtc_device *rtc = file->private_data;
+	const struct rtc_class_ops *ops = rtc->ops;
+	struct rtc_time tm;
+	struct rtc_wkalrm alarm;
+	void __user *uarg = (void __user *) arg;
+
+	err = mutex_lock_interruptible(&rtc->ops_lock);
+	if (err)
+		return err;
+
+	/* check that the calling task has appropriate permissions
+	 * for certain ioctls. doing this check here is useful
+	 * to avoid duplicate code in each driver.
+	 */
+	switch (cmd) {
+	case RTC_EPOCH_SET:
+	case RTC_SET_TIME:
+		if (!capable(CAP_SYS_TIME))
+			err = -EACCES;
+		break;
+
+	case RTC_IRQP_SET:
+		if (arg > rtc->max_user_freq && !capable(CAP_SYS_RESOURCE))
+			err = -EACCES;
+		break;
+
+	case RTC_PIE_ON:
+		if (rtc->irq_freq > rtc->max_user_freq &&
+				!capable(CAP_SYS_RESOURCE))
+			err = -EACCES;
+		break;
+	}
+
+	if (err)
+		goto done;
+
+	/*
+	 * Drivers *SHOULD NOT* provide ioctl implementations
+	 * for these requests.  Instead, provide methods to
+	 * support the following code, so that the RTC's main
+	 * features are accessible without using ioctls.
+	 *
+	 * RTC and alarm times will be in UTC, by preference,
+	 * but dual-booting with MS-Windows implies RTCs must
+	 * use the local wall clock time.
+	 */
+
+	switch (cmd) {
+	case RTC_ALM_READ:
+		mutex_unlock(&rtc->ops_lock);
+
+		err = rtc_read_alarm(rtc, &alarm);
+		if (err < 0)
+			return err;
+
+		if (copy_to_user(uarg, &alarm.time, sizeof(tm)))
+			err = -EFAULT;
+		return err;
+
+	case RTC_ALM_SET:
+		mutex_unlock(&rtc->ops_lock);
+
+		if (copy_from_user(&alarm.time, uarg, sizeof(tm)))
+			return -EFAULT;
+
+		alarm.enabled = 0;
+		alarm.pending = 0;
+		alarm.time.tm_wday = -1;
+		alarm.time.tm_yday = -1;
+		alarm.time.tm_isdst = -1;
+
+		/* RTC_ALM_SET alarms may be up to 24 hours in the future.
+		 * Rather than expecting every RTC to implement "don't care"
+		 * for day/month/year fields, just force the alarm to have
+		 * the right values for those fields.
+		 *
+		 * RTC_WKALM_SET should be used instead.  Not only does it
+		 * eliminate the need for a separate RTC_AIE_ON call, it
+		 * doesn't have the "alarm 23:59:59 in the future" race.
+		 *
+		 * NOTE:  some legacy code may have used invalid fields as
+		 * wildcards, exposing hardware "periodic alarm" capabilities.
+		 * Not supported here.
+		 */
+		{
+			unsigned long now, then;
+
+			err = rtc_read_time(rtc, &tm);
+			if (err < 0)
+				return err;
+			rtc_tm_to_time(&tm, &now);
+
+			alarm.time.tm_mday = tm.tm_mday;
+			alarm.time.tm_mon = tm.tm_mon;
+			alarm.time.tm_year = tm.tm_year;
+			err  = rtc_valid_tm(&alarm.time);
+			if (err < 0)
+				return err;
+			rtc_tm_to_time(&alarm.time, &then);
+
+			/* alarm may need to wrap into tomorrow */
+			if (then < now) {
+				rtc_time_to_tm(now + 24 * 60 * 60, &tm);
+				alarm.time.tm_mday = tm.tm_mday;
+				alarm.time.tm_mon = tm.tm_mon;
+				alarm.time.tm_year = tm.tm_year;
+			}
+		}
+
+		return rtc_set_alarm(rtc, &alarm);
+
+	case RTC_RD_TIME:
+		mutex_unlock(&rtc->ops_lock);
+
+		err = rtc_read_time(rtc, &tm);
+		if (err < 0)
+			return err;
+
+		if (copy_to_user(uarg, &tm, sizeof(tm)))
+			err = -EFAULT;
+		return err;
+
+	case RTC_SET_TIME:
+		mutex_unlock(&rtc->ops_lock);
+
+		if (copy_from_user(&tm, uarg, sizeof(tm)))
+			return -EFAULT;
+
+		return rtc_set_time(rtc, &tm);
+
+	case RTC_PIE_ON:
+		err = rtc_irq_set_state(rtc, NULL, 1);
+		break;
+
+	case RTC_PIE_OFF:
+		err = rtc_irq_set_state(rtc, NULL, 0);
+		break;
+
+	case RTC_AIE_ON:
+		mutex_unlock(&rtc->ops_lock);
+		return rtc_alarm_irq_enable(rtc, 1);
+
+	case RTC_AIE_OFF:
+		mutex_unlock(&rtc->ops_lock);
+		return rtc_alarm_irq_enable(rtc, 0);
+
+	case RTC_UIE_ON:
+		mutex_unlock(&rtc->ops_lock);
+		return rtc_update_irq_enable(rtc, 1);
+
+	case RTC_UIE_OFF:
+		mutex_unlock(&rtc->ops_lock);
+		return rtc_update_irq_enable(rtc, 0);
+
+	case RTC_IRQP_SET:
+		err = rtc_irq_set_freq(rtc, NULL, arg);
+		break;
+
+	case RTC_IRQP_READ:
+		err = put_user(rtc->irq_freq, (unsigned long __user *)uarg);
+		break;
+
+#if 0
+	case RTC_EPOCH_SET:
+#ifndef rtc_epoch
+		/*
+		 * There were no RTC clocks before 1900.
+		 */
+		if (arg < 1900) {
+			err = -EINVAL;
+			break;
+		}
+		rtc_epoch = arg;
+		err = 0;
+#endif
+		break;
+
+	case RTC_EPOCH_READ:
+		err = put_user(rtc_epoch, (unsigned long __user *)uarg);
+		break;
+#endif
+	case RTC_WKALM_SET:
+		mutex_unlock(&rtc->ops_lock);
+		if (copy_from_user(&alarm, uarg, sizeof(alarm)))
+			return -EFAULT;
+
+		return rtc_set_alarm(rtc, &alarm);
+
+	case RTC_WKALM_RD:
+		mutex_unlock(&rtc->ops_lock);
+		err = rtc_read_alarm(rtc, &alarm);
+		if (err < 0)
+			return err;
+
+		if (copy_to_user(uarg, &alarm, sizeof(alarm)))
+			err = -EFAULT;
+		return err;
+
+	default:
+		/* Finally try the driver's ioctl interface */
+		if (ops->ioctl) {
+			err = ops->ioctl(rtc->dev.parent, cmd, arg);
+			if (err == -ENOIOCTLCMD)
+				err = -ENOTTY;
+		} else
+			err = -ENOTTY;
+		break;
+	}
+
+done:
+	mutex_unlock(&rtc->ops_lock);
+	return err;
+}
+
+static int rtc_dev_fasync(int fd, struct file *file, int on)
+{
+	struct rtc_device *rtc = file->private_data;
+	return fasync_helper(fd, file, on, &rtc->async_queue);
+}
+
+static int rtc_dev_release(struct inode *inode, struct file *file)
+{
+	struct rtc_device *rtc = file->private_data;
+
+	/* We shut down the repeating IRQs that userspace enabled,
+	 * since nothing is listening to them.
+	 *  - Update (UIE) ... currently only managed through ioctls
+	 *  - Periodic (PIE) ... also used through rtc_*() interface calls
+	 *
+	 * Leave the alarm alone; it may be set to trigger a system wakeup
+	 * later, or be used by kernel code, and is a one-shot event anyway.
+	 */
+
+	/* Keep ioctl until all drivers are converted */
+	rtc_dev_ioctl(file, RTC_UIE_OFF, 0);
+	rtc_update_irq_enable(rtc, 0);
+	rtc_irq_set_state(rtc, NULL, 0);
+
+	if (rtc->ops->release)
+		rtc->ops->release(rtc->dev.parent);
+
+	clear_bit_unlock(RTC_DEV_BUSY, &rtc->flags);
+	return 0;
+}
+
+static const struct file_operations rtc_dev_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= rtc_dev_read,
+	.poll		= rtc_dev_poll,
+	.unlocked_ioctl	= rtc_dev_ioctl,
+	.open		= rtc_dev_open,
+	.release	= rtc_dev_release,
+	.fasync		= rtc_dev_fasync,
+};
+
+/* insertion/removal hooks */
+
+void rtc_dev_prepare(struct rtc_device *rtc)
+{
+	if (!rtc_devt)
+		return;
+
+	if (rtc->id >= RTC_DEV_MAX) {
+		pr_debug("%s: too many RTC devices\n", rtc->name);
+		return;
+	}
+
+	rtc->dev.devt = MKDEV(MAJOR(rtc_devt), rtc->id);
+
+#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL
+	INIT_WORK(&rtc->uie_task, rtc_uie_task);
+	setup_timer(&rtc->uie_timer, rtc_uie_timer, (unsigned long)rtc);
+#endif
+
+	cdev_init(&rtc->char_dev, &rtc_dev_fops);
+	rtc->char_dev.owner = rtc->owner;
+}
+
+void rtc_dev_add_device(struct rtc_device *rtc)
+{
+	if (cdev_add(&rtc->char_dev, rtc->dev.devt, 1))
+		printk(KERN_WARNING "%s: failed to add char device %d:%d\n",
+			rtc->name, MAJOR(rtc_devt), rtc->id);
+	else
+		pr_debug("%s: dev (%d:%d)\n", rtc->name,
+			MAJOR(rtc_devt), rtc->id);
+}
+
+void rtc_dev_del_device(struct rtc_device *rtc)
+{
+	if (rtc->dev.devt)
+		cdev_del(&rtc->char_dev);
+}
+
+void __init rtc_dev_init(void)
+{
+	int err;
+
+	err = alloc_chrdev_region(&rtc_devt, 0, RTC_DEV_MAX, "rtc");
+	if (err < 0)
+		printk(KERN_ERR "%s: failed to allocate char dev region\n",
+			__FILE__);
+}
+
+void __exit rtc_dev_exit(void)
+{
+	if (rtc_devt)
+		unregister_chrdev_region(rtc_devt, RTC_DEV_MAX);
+}
diff -Nurp linux/include/config/auto.conf linux-3.0/include/config/auto.conf
--- linux/include/config/auto.conf	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/config/auto.conf	2014-02-19 21:05:09.308632403 -0500
@@ -0,0 +1,418 @@
+#
+# Automatically generated make config: don't edit
+# Linux/x86_64 3.0.0 Kernel Configuration
+#
+CONFIG_SCSI_DMA=y
+CONFIG_KERNEL_GZIP=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_CRC32=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_FIRMWARE_MEMMAP=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_NET_ETHERNET=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_X86_TSC=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_PNPACPI=y
+CONFIG_SSB_POSSIBLE=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_8139CP=y
+CONFIG_IPV6=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_NAMESPACES=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_PCIEAER=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_SERIAL_8250=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_RD_LZMA=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_BCMA_POSSIBLE=y
+CONFIG_VGA_ARB=y
+CONFIG_DEBUG_LOCK_ALLOC=y
+CONFIG_PRINTK=y
+CONFIG_TIMERFD=y
+CONFIG_BOUNCE=y
+CONFIG_SHMEM=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_ATA=y
+CONFIG_SERIO=y
+CONFIG_X86=y
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PCI_IOAPIC=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_ACPI_FAN=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ACPI=y
+CONFIG_MTRR=y
+CONFIG_ACPI_BLACKLIST_YEAR=0
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_X86_MPPARSE=y
+CONFIG_STANDALONE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_BLOCK=y
+CONFIG_HAVE_IDE=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_VIRTIO_RING=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_BUG=y
+CONFIG_PM=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_VT=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_POWER_SUPPLY=y
+CONFIG_NLS=y
+CONFIG_MFD_SUPPORT=y
+CONFIG_ZONE_DMA=y
+CONFIG_IRQ_WORK=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_NETDEVICES=y
+CONFIG_EVENTFD=y
+CONFIG_IPV6_SIT=y
+CONFIG_XFRM=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_X86_CMOV=y
+CONFIG_RD_LZO=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_SCSI_WAIT_SCAN=m
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_IO_DELAY_0X80=y
+CONFIG_DMI=y
+CONFIG_DEFAULT_CFQ=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_EXT3_FS=y
+CONFIG_INET_TUNNEL=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_CRYPTO_RNG=y
+CONFIG_RD_GZIP=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_SWIOTLB=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_ATA_ACPI=y
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+CONFIG_BINFMT_ELF=y
+CONFIG_SCSI_PROC_FS=y
+CONFIG_HOTPLUG=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_SLABINFO=y
+CONFIG_CRYPTO_HW=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_ACPI_AC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_CRC16=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_X86_CMPXCHG=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_TMPFS=y
+CONFIG_ANON_INODES=y
+CONFIG_FUTEX=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_PCI_LABEL=y
+CONFIG_MODULES=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_UNIX=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_HPET_TIMER=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_MISC_DEVICES=y
+CONFIG_RD_BZIP2=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_KEYBOARD_ATKBD=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_CPU_IDLE=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_VIRT_TO_BUS=y
+CONFIG_CMPXCHG_LOCAL=y
+CONFIG_GENERIC_CPU=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_SUSPEND=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_FS_MBCACHE=y
+CONFIG_RTC_CLASS=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_IOMMU_HELPER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_SLUB=y
+CONFIG_XZ_DEC_BCJ=y
+CONFIG_PM_SLEEP=y
+CONFIG_FRAME_POINTER=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_BASE_FULL=y
+CONFIG_FW_LOADER=y
+CONFIG_KALLSYMS=y
+CONFIG_PCI=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_MII=y
+CONFIG_SIGNALFD=y
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_EXT4_FS=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_XZ_DEC=y
+CONFIG_SATA_PMP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_GART_IOMMU=y
+CONFIG_EPOLL=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11"
+CONFIG_NET=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_PACKET=y
+CONFIG_INET=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_VIRTIO_NET=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_FREEZER=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_RTC_LIB=y
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_CRYPTO_AES=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_HT_IRQ=y
+CONFIG_RD_XZ=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_VGA_CONSOLE=y
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_X86_XADD=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_PREEMPT_NONE=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_PNP=y
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_GENERIC_BUG=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_HW_CONSOLE=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOCALVERSION=""
+CONFIG_CRYPTO=y
+CONFIG_SCHED_DEBUG=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_VIRTIO=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_SCSI_MOD=y
+CONFIG_SERIAL_CORE=y
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAS_DMA=y
+CONFIG_NET_PCI=y
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_SCSI=y
+CONFIG_X86_64=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_RTC_DRV_CMOS=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_JBD2=y
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_SPARSEMEM=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_HZ_250=y
+CONFIG_X86_IO_APIC=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_FRAME_WARN=2048
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_DEBUG_RODATA_TEST=y
+CONFIG_PROVE_LOCKING=y
+CONFIG_STACKTRACE=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_HAS_IOPORT=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_ISA_DMA_API=y
+CONFIG_HZ=250
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_DIRECT_GBPAGES=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_NLATTR=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_NR_CPUS=1
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_SYSFS=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_TRACE_IRQFLAGS=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_THERMAL=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_MTRR_SANITIZER=y
+CONFIG_TINY_RCU=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_ACPI_THERMAL=y
+CONFIG_BASE_SMALL=0
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_PROC_FS=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SYSCTL=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_NET_NS=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_ATA_SFF=y
+CONFIG_NO_BOOTMEM=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_PCIEASPM=y
+CONFIG_ATA_PIIX=y
+CONFIG_SATA_AHCI=y
+CONFIG_BLK_DEV=y
+CONFIG_SERIO_I8042=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_ZONE_DMA32=y
+CONFIG_JBD=y
+CONFIG_LOCKDEP=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_INET_DIAG=y
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_ELF_CORE=y
+CONFIG_INET_LRO=y
+CONFIG_VT_CONSOLE=y
+CONFIG_PCI_DIRECT=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_VIRTIO_BLK=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_64BIT=y
+CONFIG_CROSS_COMPILE=""
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_ATA_BMDMA=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_BITREVERSE=y
+CONFIG_DEVPORT=y
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_PAT=y
+CONFIG_PNP_DEBUG_MESSAGES=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_FILE_LOCKING=y
+CONFIG_AIO=y
+CONFIG_PERF_EVENTS=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_AMD_NB=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_DEBUG_INFO=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_DEBUG_RODATA=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_INPUT=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_MMU=y
+CONFIG_HAVE_IRQ_WORK=y
diff -Nurp linux/include/config/auto.conf.cmd linux-3.0/include/config/auto.conf.cmd
--- linux/include/config/auto.conf.cmd	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/config/auto.conf.cmd	2014-02-19 21:05:09.315632561 -0500
@@ -0,0 +1,625 @@
+deps_config := \
+	lib/xz/Kconfig \
+	lib/Kconfig \
+	drivers/virtio/Kconfig \
+	drivers/lguest/Kconfig \
+	drivers/vhost/Kconfig \
+	virt/kvm/Kconfig \
+	arch/x86/kvm/Kconfig \
+	drivers/crypto/caam/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/async_tx/Kconfig \
+	crypto/Kconfig \
+	security/integrity/ima/Kconfig \
+	security/apparmor/Kconfig \
+	security/tomoyo/Kconfig \
+	security/smack/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.kmemcheck \
+	lib/Kconfig.kgdb \
+	samples/Kconfig \
+	kernel/trace/Kconfig \
+	mm/Kconfig.debug \
+	lib/Kconfig.debug \
+	arch/x86/Kconfig.debug \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/partitions/Kconfig \
+	fs/9p/Kconfig \
+	fs/afs/Kconfig \
+	fs/coda/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/cifs/Kconfig \
+	fs/ceph/Kconfig \
+	net/sunrpc/Kconfig \
+	fs/nfsd/Kconfig \
+	fs/nfs/Kconfig \
+	fs/exofs/Kconfig \
+	fs/ufs/Kconfig \
+	fs/sysv/Kconfig \
+	fs/pstore/Kconfig \
+	fs/romfs/Kconfig \
+	fs/qnx4/Kconfig \
+	fs/hpfs/Kconfig \
+	fs/omfs/Kconfig \
+	fs/minix/Kconfig \
+	fs/freevxfs/Kconfig \
+	fs/squashfs/Kconfig \
+	fs/cramfs/Kconfig \
+	fs/logfs/Kconfig \
+	fs/ubifs/Kconfig \
+	fs/jffs2/Kconfig \
+	fs/efs/Kconfig \
+	fs/bfs/Kconfig \
+	fs/befs/Kconfig \
+	fs/hfsplus/Kconfig \
+	fs/hfs/Kconfig \
+	fs/ecryptfs/Kconfig \
+	fs/affs/Kconfig \
+	fs/adfs/Kconfig \
+	fs/configfs/Kconfig \
+	fs/sysfs/Kconfig \
+	fs/proc/Kconfig \
+	fs/ntfs/Kconfig \
+	fs/fat/Kconfig \
+	fs/udf/Kconfig \
+	fs/isofs/Kconfig \
+	fs/cachefiles/Kconfig \
+	fs/fscache/Kconfig \
+	fs/fuse/Kconfig \
+	fs/autofs4/Kconfig \
+	fs/quota/Kconfig \
+	fs/notify/fanotify/Kconfig \
+	fs/notify/inotify/Kconfig \
+	fs/notify/dnotify/Kconfig \
+	fs/notify/Kconfig \
+	fs/nilfs2/Kconfig \
+	fs/btrfs/Kconfig \
+	fs/ocfs2/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/jfs/Kconfig \
+	fs/reiserfs/Kconfig \
+	fs/jbd2/Kconfig \
+	fs/jbd/Kconfig \
+	fs/ext4/Kconfig \
+	fs/ext3/Kconfig \
+	fs/ext2/Kconfig \
+	fs/Kconfig \
+	drivers/firmware/google/Kconfig \
+	drivers/firmware/Kconfig \
+	drivers/clocksource/Kconfig \
+	drivers/hwspinlock/Kconfig \
+	drivers/clk/Kconfig \
+	drivers/platform/x86/Kconfig \
+	drivers/platform/Kconfig \
+	drivers/staging/nvec/Kconfig \
+	drivers/staging/mei/Kconfig \
+	drivers/staging/altera-stapl/Kconfig \
+	drivers/staging/gma500/Kconfig \
+	drivers/staging/ste_rmi4/Kconfig \
+	drivers/staging/cptm1217/Kconfig \
+	drivers/staging/speakup/Kconfig \
+	drivers/staging/intel_sst/Kconfig \
+	drivers/staging/ft1000/Kconfig \
+	drivers/staging/bcm/Kconfig \
+	drivers/staging/keucr/Kconfig \
+	drivers/staging/ath6kl/Kconfig \
+	drivers/staging/sbe-2t3e3/Kconfig \
+	drivers/staging/westbridge/astoria/gadget/Kconfig \
+	drivers/staging/westbridge/astoria/block/Kconfig \
+	drivers/staging/westbridge/astoria/device/Kconfig \
+	drivers/staging/westbridge/astoria/Kconfig \
+	drivers/staging/westbridge/Kconfig \
+	drivers/staging/quickstart/Kconfig \
+	drivers/staging/tidspbridge/Kconfig \
+	drivers/staging/solo6x10/Kconfig \
+	drivers/staging/easycap/Kconfig \
+	drivers/staging/lirc/Kconfig \
+	drivers/staging/msm/Kconfig \
+	drivers/staging/xgifb/Kconfig \
+	drivers/staging/cxt1e1/Kconfig \
+	drivers/staging/crystalhd/Kconfig \
+	drivers/staging/dt3155v4l/Kconfig \
+	drivers/staging/sm7xx/Kconfig \
+	drivers/staging/wlags49_h25/Kconfig \
+	drivers/staging/wlags49_h2/Kconfig \
+	drivers/staging/zcache/Kconfig \
+	drivers/staging/zram/Kconfig \
+	drivers/staging/cs5535_gpio/Kconfig \
+	drivers/staging/iio/trigger/Kconfig \
+	drivers/staging/iio/resolver/Kconfig \
+	drivers/staging/iio/meter/Kconfig \
+	drivers/staging/iio/magnetometer/Kconfig \
+	drivers/staging/iio/light/Kconfig \
+	drivers/staging/iio/imu/Kconfig \
+	drivers/staging/iio/gyro/Kconfig \
+	drivers/staging/iio/dds/Kconfig \
+	drivers/staging/iio/dac/Kconfig \
+	drivers/staging/iio/addac/Kconfig \
+	drivers/staging/iio/adc/Kconfig \
+	drivers/staging/iio/accel/Kconfig \
+	drivers/staging/iio/Kconfig \
+	drivers/staging/sep/Kconfig \
+	drivers/staging/vme/boards/Kconfig \
+	drivers/staging/vme/devices/Kconfig \
+	drivers/staging/vme/bridges/Kconfig \
+	drivers/staging/vme/Kconfig \
+	drivers/staging/hv/Kconfig \
+	drivers/staging/vt6656/Kconfig \
+	drivers/staging/vt6655/Kconfig \
+	drivers/staging/quatech_usb2/Kconfig \
+	drivers/staging/spectra/Kconfig \
+	drivers/staging/serqt_usb2/Kconfig \
+	drivers/staging/octeon/Kconfig \
+	drivers/gpu/drm/nouveau/Kconfig \
+	drivers/gpu/drm/vmwgfx/Kconfig \
+	drivers/staging/line6/Kconfig \
+	drivers/staging/phison/Kconfig \
+	drivers/staging/pohmelfs/Kconfig \
+	drivers/staging/frontier/Kconfig \
+	drivers/staging/rts_pstor/Kconfig \
+	drivers/staging/rtl8712/Kconfig \
+	drivers/staging/rtl8192e/Kconfig \
+	drivers/staging/rtl8192u/Kconfig \
+	drivers/staging/rtl8187se/Kconfig \
+	drivers/staging/panel/Kconfig \
+	drivers/staging/asus_oled/Kconfig \
+	drivers/staging/olpc_dcon/Kconfig \
+	drivers/staging/comedi/Kconfig \
+	drivers/staging/brcm80211/Kconfig \
+	drivers/staging/echo/Kconfig \
+	drivers/staging/wlan-ng/Kconfig \
+	drivers/staging/winbond/Kconfig \
+	drivers/staging/usbip/Kconfig \
+	drivers/staging/cxd2099/Kconfig \
+	drivers/staging/tm6000/Kconfig \
+	drivers/staging/cx25821/Kconfig \
+	drivers/staging/go7007/Kconfig \
+	drivers/staging/slicoss/Kconfig \
+	drivers/staging/et131x/Kconfig \
+	drivers/staging/generic_serial/Kconfig \
+	drivers/staging/tty/Kconfig \
+	drivers/staging/Kconfig \
+	drivers/xen/Kconfig \
+	drivers/vlynq/Kconfig \
+	drivers/uio/Kconfig \
+	drivers/auxdisplay/Kconfig \
+	drivers/dca/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/edac/Kconfig \
+	drivers/infiniband/ulp/iser/Kconfig \
+	drivers/infiniband/ulp/srp/Kconfig \
+	drivers/infiniband/ulp/ipoib/Kconfig \
+	drivers/infiniband/hw/nes/Kconfig \
+	drivers/infiniband/hw/mlx4/Kconfig \
+	drivers/infiniband/hw/cxgb4/Kconfig \
+	drivers/infiniband/hw/cxgb3/Kconfig \
+	drivers/infiniband/hw/amso1100/Kconfig \
+	drivers/infiniband/hw/ehca/Kconfig \
+	drivers/infiniband/hw/qib/Kconfig \
+	drivers/infiniband/hw/ipath/Kconfig \
+	drivers/infiniband/hw/mthca/Kconfig \
+	drivers/infiniband/Kconfig \
+	drivers/accessibility/Kconfig \
+	drivers/nfc/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/memstick/host/Kconfig \
+	drivers/memstick/core/Kconfig \
+	drivers/memstick/Kconfig \
+	drivers/mmc/host/Kconfig \
+	drivers/mmc/card/Kconfig \
+	drivers/mmc/core/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/uwb/Kconfig \
+	drivers/usb/otg/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/renesas_usbhs/Kconfig \
+	drivers/usb/musb/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/wusbcore/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/usbhid/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/soc/codecs/Kconfig \
+	sound/soc/txx9/Kconfig \
+	sound/soc/tegra/Kconfig \
+	sound/soc/sh/Kconfig \
+	sound/soc/s6000/Kconfig \
+	sound/soc/samsung/Kconfig \
+	sound/soc/pxa/Kconfig \
+	sound/soc/mid-x86/Kconfig \
+	sound/soc/kirkwood/Kconfig \
+	sound/soc/omap/Kconfig \
+	sound/soc/nuc900/Kconfig \
+	sound/soc/jz4740/Kconfig \
+	sound/soc/imx/Kconfig \
+	sound/soc/fsl/Kconfig \
+	sound/soc/ep93xx/Kconfig \
+	sound/soc/davinci/Kconfig \
+	sound/soc/blackfin/Kconfig \
+	sound/soc/au1x/Kconfig \
+	sound/soc/atmel/Kconfig \
+	sound/soc/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/firewire/Kconfig \
+	sound/usb/Kconfig \
+	sound/sh/Kconfig \
+	sound/mips/Kconfig \
+	sound/spi/Kconfig \
+	sound/atmel/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/hda/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/seq/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/display/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/omap2/displays/Kconfig \
+	drivers/video/omap2/omapfb/Kconfig \
+	drivers/video/omap2/dss/Kconfig \
+	drivers/video/omap2/Kconfig \
+	drivers/video/omap/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/gpu/stub/Kconfig \
+	drivers/gpu/drm/radeon/Kconfig \
+	drivers/gpu/drm/Kconfig \
+	drivers/gpu/vga/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/ngene/Kconfig \
+	drivers/media/dvb/mantis/Kconfig \
+	drivers/media/dvb/pt1/Kconfig \
+	drivers/media/dvb/firewire/Kconfig \
+	drivers/media/dvb/dm1105/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/siano/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/wl128x/Kconfig \
+	drivers/media/radio/si470x/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/cx231xx/Kconfig \
+	drivers/media/video/tlg2300/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/hdpvr/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/gspca/gl860/Kconfig \
+	drivers/media/video/gspca/stv06xx/Kconfig \
+	drivers/media/video/gspca/m5602/Kconfig \
+	drivers/media/video/gspca/Kconfig \
+	drivers/media/video/uvc/Kconfig \
+	drivers/media/video/m5mols/Kconfig \
+	drivers/media/video/saa7164/Kconfig \
+	drivers/media/video/cx18/Kconfig \
+	drivers/media/video/ivtv/Kconfig \
+	drivers/media/video/au0828/Kconfig \
+	drivers/media/video/cx23885/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/zoran/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/omap/Kconfig \
+	drivers/media/video/davinci/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/common/tuners/Kconfig \
+	drivers/media/rc/keymaps/Kconfig \
+	drivers/media/rc/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/Kconfig \
+	drivers/regulator/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/bcma/Kconfig \
+	drivers/ssb/Kconfig \
+	drivers/watchdog/Kconfig \
+	drivers/thermal/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/power/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/ptp/Kconfig \
+	drivers/pps/generators/Kconfig \
+	drivers/pps/clients/Kconfig \
+	drivers/pps/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/muxes/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/s390/char/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/tty/hvc/Kconfig \
+	drivers/tty/serial/Kconfig \
+	drivers/tty/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/tablet/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/telephony/Kconfig \
+	drivers/isdn/hardware/mISDN/Kconfig \
+	drivers/isdn/mISDN/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/net/caif/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/ieee802154/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/pcmcia/Kconfig \
+	drivers/net/usb/Kconfig \
+	drivers/net/wimax/i2400m/Kconfig \
+	drivers/net/wimax/Kconfig \
+	drivers/net/wireless/mwifiex/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/wl12xx/Kconfig \
+	drivers/net/wireless/wl1251/Kconfig \
+	drivers/net/wireless/rtlwifi/Kconfig \
+	drivers/net/wireless/rt2x00/Kconfig \
+	drivers/net/wireless/p54/Kconfig \
+	drivers/net/wireless/orinoco/Kconfig \
+	drivers/net/wireless/libertas/Kconfig \
+	drivers/net/wireless/iwmc3200wifi/Kconfig \
+	drivers/net/wireless/iwlegacy/Kconfig \
+	drivers/net/wireless/iwlwifi/Kconfig \
+	drivers/net/wireless/ipw2x00/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/b43legacy/Kconfig \
+	drivers/net/wireless/b43/Kconfig \
+	drivers/net/wireless/ath/carl9170/Kconfig \
+	drivers/net/wireless/ath/ath9k/Kconfig \
+	drivers/net/wireless/ath/ath5k/Kconfig \
+	drivers/net/wireless/ath/Kconfig \
+	drivers/net/wireless/rtl818x/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/net/benet/Kconfig \
+	drivers/net/sfc/Kconfig \
+	drivers/net/stmmac/Kconfig \
+	drivers/net/ixp2000/Kconfig \
+	drivers/net/octeon/Kconfig \
+	drivers/net/fs_enet/Kconfig \
+	drivers/net/ibm_newemac/Kconfig \
+	drivers/net/tulip/Kconfig \
+	drivers/net/arm/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/Kconfig \
+	drivers/macintosh/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/firewire/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/target/tcm_fc/Kconfig \
+	drivers/target/loopback/Kconfig \
+	drivers/target/Kconfig \
+	drivers/md/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/osd/Kconfig \
+	drivers/scsi/device_handler/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/mpt2sas/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/mvsas/Kconfig \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/be2iscsi/Kconfig \
+	drivers/scsi/bnx2fc/Kconfig \
+	drivers/scsi/bnx2i/Kconfig \
+	drivers/scsi/cxgbi/cxgb4i/Kconfig \
+	drivers/scsi/cxgbi/cxgb3i/Kconfig \
+	drivers/scsi/cxgbi/Kconfig \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/misc/carma/Kconfig \
+	drivers/misc/lis3lv02d/Kconfig \
+	drivers/misc/ti-st/Kconfig \
+	drivers/misc/iwmc3200top/Kconfig \
+	drivers/misc/cb710/Kconfig \
+	drivers/misc/eeprom/Kconfig \
+	drivers/misc/c2port/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/drbd/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/of/Kconfig \
+	drivers/mtd/ubi/Kconfig \
+	drivers/mtd/lpddr/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/Kconfig \
+	drivers/Kconfig \
+	net/ceph/Kconfig \
+	net/caif/Kconfig \
+	net/9p/Kconfig \
+	net/rfkill/Kconfig \
+	net/wimax/Kconfig \
+	net/mac80211/Kconfig \
+	net/wireless/Kconfig \
+	net/rxrpc/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/can/softing/Kconfig \
+	drivers/net/can/usb/Kconfig \
+	drivers/net/can/c_can/Kconfig \
+	drivers/net/can/sja1000/Kconfig \
+	drivers/net/can/mscan/Kconfig \
+	drivers/net/can/Kconfig \
+	net/can/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/batman-adv/Kconfig \
+	net/dns_resolver/Kconfig \
+	net/dcb/Kconfig \
+	net/sched/Kconfig \
+	net/ieee802154/Kconfig \
+	net/phonet/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/dsa/Kconfig \
+	net/bridge/Kconfig \
+	net/802/Kconfig \
+	net/l2tp/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/rds/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/ipvs/Kconfig \
+	net/netfilter/ipset/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/Kconfig \
+	net/iucv/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/rapidio/switches/Kconfig \
+	drivers/rapidio/Kconfig \
+	drivers/pci/hotplug/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/mca/Kconfig \
+	drivers/eisa/Kconfig \
+	drivers/pci/Kconfig \
+	drivers/pci/pcie/aer/Kconfig.debug \
+	drivers/pci/pcie/aer/Kconfig \
+	drivers/pci/pcie/Kconfig \
+	drivers/idle/Kconfig \
+	drivers/cpuidle/Kconfig \
+	drivers/cpufreq/Kconfig.x86 \
+	drivers/cpufreq/Kconfig \
+	drivers/sfi/Kconfig \
+	drivers/acpi/apei/Kconfig \
+	drivers/acpi/Kconfig \
+	kernel/power/Kconfig \
+	kernel/Kconfig.hz \
+	mm/Kconfig \
+	kernel/Kconfig.preempt \
+	arch/x86/Kconfig.cpu \
+	arch/x86/lguest/Kconfig \
+	arch/x86/xen/Kconfig \
+	kernel/time/Kconfig \
+	kernel/Kconfig.freezer \
+	kernel/Kconfig.locks \
+	block/Kconfig.iosched \
+	block/Kconfig \
+	kernel/gcov/Kconfig \
+	arch/Kconfig \
+	usr/Kconfig \
+	kernel/irq/Kconfig \
+	init/Kconfig \
+	arch/x86/Kconfig \
+	Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+ifneq "$(KERNELVERSION)" "3.0.0"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(ARCH)" "x86_64"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(SRCARCH)" "x86"
+include/config/auto.conf: FORCE
+endif
+
+$(deps_config): ;
diff -Nurp linux/include/config/kernel.release linux-3.0/include/config/kernel.release
--- linux/include/config/kernel.release	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/config/kernel.release	2014-02-19 21:05:09.524637277 -0500
@@ -0,0 +1 @@
+3.0.0
diff -Nurp linux/include/config/tristate.conf linux-3.0/include/config/tristate.conf
--- linux/include/config/tristate.conf	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/config/tristate.conf	2014-02-19 21:05:09.935646552 -0500
@@ -0,0 +1,78 @@
+#
+# Automatically generated - do not edit
+
+CONFIG_CRC32=Y
+CONFIG_8139CP=Y
+CONFIG_IPV6=Y
+CONFIG_CRYPTO_RNG2=Y
+CONFIG_SERIAL_8250=Y
+CONFIG_LZO_DECOMPRESS=Y
+CONFIG_DECOMPRESS_LZMA=Y
+CONFIG_INPUT_MOUSEDEV=Y
+CONFIG_ATA=Y
+CONFIG_SERIO=Y
+CONFIG_ZLIB_INFLATE=Y
+CONFIG_ACPI_FAN=Y
+CONFIG_VIRTIO_RING=Y
+CONFIG_POWER_SUPPLY=Y
+CONFIG_NLS=Y
+CONFIG_IPV6_SIT=Y
+CONFIG_SCSI_WAIT_SCAN=M
+CONFIG_INET_XFRM_MODE_BEET=Y
+CONFIG_INET6_XFRM_MODE_TUNNEL=Y
+CONFIG_EXT3_FS=Y
+CONFIG_INET_TUNNEL=Y
+CONFIG_IOSCHED_CFQ=Y
+CONFIG_CRYPTO_RNG=Y
+CONFIG_INET_XFRM_MODE_TRANSPORT=Y
+CONFIG_ACPI_PROCESSOR=Y
+CONFIG_ACPI_AC=Y
+CONFIG_CRC16=Y
+CONFIG_VIRTIO_PCI=Y
+CONFIG_UNIX=Y
+CONFIG_CRYPTO_ALGAPI=Y
+CONFIG_KEYBOARD_ATKBD=Y
+CONFIG_FS_MBCACHE=Y
+CONFIG_FW_LOADER=Y
+CONFIG_DECOMPRESS_XZ=Y
+CONFIG_MII=Y
+CONFIG_EXT4_FS=Y
+CONFIG_XZ_DEC=Y
+CONFIG_PACKET=Y
+CONFIG_VIRTIO_NET=Y
+CONFIG_SERIAL_8250_PNP=Y
+CONFIG_CRYPTO_AES=Y
+CONFIG_INET_XFRM_MODE_TUNNEL=Y
+CONFIG_ACPI_BUTTON=Y
+CONFIG_SERIO_LIBPS2=Y
+CONFIG_INET_TCP_DIAG=Y
+CONFIG_CRYPTO=Y
+CONFIG_VIRTIO=Y
+CONFIG_SCSI_MOD=Y
+CONFIG_SERIAL_CORE=Y
+CONFIG_SCSI=Y
+CONFIG_RTC_DRV_CMOS=Y
+CONFIG_JBD2=Y
+CONFIG_DECOMPRESS_BZIP2=Y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=Y
+CONFIG_HOTPLUG_PCI=Y
+CONFIG_TCP_CONG_CUBIC=Y
+CONFIG_ACPI_BATTERY=Y
+CONFIG_THERMAL=Y
+CONFIG_ACPI_THERMAL=Y
+CONFIG_ATA_PIIX=Y
+CONFIG_SATA_AHCI=Y
+CONFIG_SERIO_I8042=Y
+CONFIG_CRYPTO_ANSI_CPRNG=Y
+CONFIG_JBD=Y
+CONFIG_INET_DIAG=Y
+CONFIG_INET_LRO=Y
+CONFIG_INET6_XFRM_MODE_BEET=Y
+CONFIG_DECOMPRESS_GZIP=Y
+CONFIG_VIRTIO_BLK=Y
+CONFIG_DECOMPRESS_LZO=Y
+CONFIG_SERIAL_8250_PCI=Y
+CONFIG_BLK_DEV_SD=Y
+CONFIG_BITREVERSE=Y
+CONFIG_CRYPTO_ALGAPI2=Y
+CONFIG_INPUT=Y
diff -Nurp linux/include/generated/asm-offsets.h linux-3.0/include/generated/asm-offsets.h
--- linux/include/generated/asm-offsets.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/generated/asm-offsets.h	2014-02-19 21:05:11.319677781 -0500
@@ -0,0 +1,55 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define pt_regs_bx 40 /* offsetof(struct pt_regs, bx)	# */
+#define pt_regs_bx 40 /* offsetof(struct pt_regs, bx)	# */
+#define pt_regs_cx 88 /* offsetof(struct pt_regs, cx)	# */
+#define pt_regs_dx 96 /* offsetof(struct pt_regs, dx)	# */
+#define pt_regs_sp 152 /* offsetof(struct pt_regs, sp)	# */
+#define pt_regs_bp 32 /* offsetof(struct pt_regs, bp)	# */
+#define pt_regs_si 104 /* offsetof(struct pt_regs, si)	# */
+#define pt_regs_di 112 /* offsetof(struct pt_regs, di)	# */
+#define pt_regs_r8 72 /* offsetof(struct pt_regs, r8)	# */
+#define pt_regs_r9 64 /* offsetof(struct pt_regs, r9)	# */
+#define pt_regs_r10 56 /* offsetof(struct pt_regs, r10)	# */
+#define pt_regs_r11 48 /* offsetof(struct pt_regs, r11)	# */
+#define pt_regs_r12 24 /* offsetof(struct pt_regs, r12)	# */
+#define pt_regs_r13 16 /* offsetof(struct pt_regs, r13)	# */
+#define pt_regs_r14 8 /* offsetof(struct pt_regs, r14)	# */
+#define pt_regs_r15 0 /* offsetof(struct pt_regs, r15)	# */
+#define pt_regs_flags 144 /* offsetof(struct pt_regs, flags)	# */
+
+#define saved_context_cr0 202 /* offsetof(struct saved_context, cr0)	# */
+#define saved_context_cr2 210 /* offsetof(struct saved_context, cr2)	# */
+#define saved_context_cr3 218 /* offsetof(struct saved_context, cr3)	# */
+#define saved_context_cr4 226 /* offsetof(struct saved_context, cr4)	# */
+#define saved_context_cr8 234 /* offsetof(struct saved_context, cr8)	# */
+
+#define TSS_ist 36 /* offsetof(struct tss_struct, x86_tss.ist)	# */
+
+#define __NR_syscall_max 308 /* sizeof(syscalls) - 1	# */
+
+#define TI_flags 16 /* offsetof(struct thread_info, flags)	# */
+#define TI_status 20 /* offsetof(struct thread_info, status)	# */
+#define TI_addr_limit 32 /* offsetof(struct thread_info, addr_limit)	# */
+#define TI_preempt_count 28 /* offsetof(struct thread_info, preempt_count)	# */
+
+#define crypto_tfm_ctx_offset 88 /* offsetof(struct crypto_tfm, __crt_ctx)	# */
+
+#define pbe_address 0 /* offsetof(struct pbe, address)	# */
+#define pbe_orig_address 8 /* offsetof(struct pbe, orig_address)	# */
+#define pbe_next 16 /* offsetof(struct pbe, next)	# */
+
+#define BP_scratch 484 /* offsetof(struct boot_params, scratch)	# */
+#define BP_loadflags 529 /* offsetof(struct boot_params, hdr.loadflags)	# */
+#define BP_hardware_subarch 572 /* offsetof(struct boot_params, hdr.hardware_subarch)	# */
+#define BP_version 518 /* offsetof(struct boot_params, hdr.version)	# */
+#define BP_kernel_alignment 560 /* offsetof(struct boot_params, hdr.kernel_alignment)	# */
+
+#endif
diff -Nurp linux/include/generated/autoconf.h linux-3.0/include/generated/autoconf.h
--- linux/include/generated/autoconf.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/generated/autoconf.h	2014-02-19 21:05:11.326677939 -0500
@@ -0,0 +1,418 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux/x86_64 3.0.0 Kernel Configuration
+ */
+#define CONFIG_SCSI_DMA 1
+#define CONFIG_KERNEL_GZIP 1
+#define CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK 1
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_CRC32 1
+#define CONFIG_EXT3_FS_XATTR 1
+#define CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT 1
+#define CONFIG_FIRMWARE_MEMMAP 1
+#define CONFIG_FIX_EARLYCON_MEM 1
+#define CONFIG_XZ_DEC_IA64 1
+#define CONFIG_NETWORK_FILESYSTEMS 1
+#define CONFIG_X86_MINIMUM_CPU_FAMILY 64
+#define CONFIG_NET_ETHERNET 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_X86_TSC 1
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define CONFIG_PNPACPI 1
+#define CONFIG_SSB_POSSIBLE 1
+#define CONFIG_HAVE_KERNEL_LZMA 1
+#define CONFIG_HAVE_MEMORY_PRESENT 1
+#define CONFIG_DEFAULT_SECURITY_DAC 1
+#define CONFIG_8139CP 1
+#define CONFIG_IPV6 1
+#define CONFIG_AUDIT_ARCH 1
+#define CONFIG_HAVE_KERNEL_BZIP2 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_UEVENT_HELPER_PATH "/sbin/hotplug"
+#define CONFIG_ARCH_SPARSEMEM_ENABLE 1
+#define CONFIG_NAMESPACES 1
+#define CONFIG_DEFAULT_MESSAGE_LOGLEVEL 4
+#define CONFIG_PCIEAER 1
+#define CONFIG_CRYPTO_RNG2 1
+#define CONFIG_SERIAL_8250 1
+#define CONFIG_LZO_DECOMPRESS 1
+#define CONFIG_RD_LZMA 1
+#define CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK 1
+#define CONFIG_BCMA_POSSIBLE 1
+#define CONFIG_VGA_ARB 1
+#define CONFIG_DEBUG_LOCK_ALLOC 1
+#define CONFIG_PRINTK 1
+#define CONFIG_TIMERFD 1
+#define CONFIG_BOUNCE 1
+#define CONFIG_SHMEM 1
+#define CONFIG_HAVE_ARCH_JUMP_LABEL 1
+#define CONFIG_DECOMPRESS_LZMA 1
+#define CONFIG_INPUT_MOUSEDEV 1
+#define CONFIG_ATA 1
+#define CONFIG_SERIO 1
+#define CONFIG_X86 1
+#define CONFIG_RTC_INTF_SYSFS 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_HAVE_BPF_JIT 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_PCI_IOAPIC 1
+#define CONFIG_RTC_INTF_PROC 1
+#define CONFIG_ACPI_FAN 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_OUTPUT_FORMAT "elf64-x86-64"
+#define CONFIG_ACPI 1
+#define CONFIG_MTRR 1
+#define CONFIG_ACPI_BLACKLIST_YEAR 0
+#define CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING 1
+#define CONFIG_HPET_EMULATE_RTC 1
+#define CONFIG_X86_MPPARSE 1
+#define CONFIG_STANDALONE 1
+#define CONFIG_HAVE_SETUP_PER_CPU_AREA 1
+#define CONFIG_IO_DELAY_TYPE_0XED 1
+#define CONFIG_BLOCK 1
+#define CONFIG_HAVE_IDE 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_VIRTIO_RING 1
+#define CONFIG_CPU_SUP_INTEL 1
+#define CONFIG_BUG 1
+#define CONFIG_PM 1
+#define CONFIG_GENERIC_ISA_DMA 1
+#define CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE 0
+#define CONFIG_VT 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 999999
+#define CONFIG_POWER_SUPPLY 1
+#define CONFIG_NLS 1
+#define CONFIG_MFD_SUPPORT 1
+#define CONFIG_ZONE_DMA 1
+#define CONFIG_IRQ_WORK 1
+#define CONFIG_SPARSEMEM_EXTREME 1
+#define CONFIG_ARCH_DEFCONFIG "arch/x86/configs/x86_64_defconfig"
+#define CONFIG_VGA_ARB_MAX_GPUS 16
+#define CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_IPV6_SIT 1
+#define CONFIG_XFRM 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_SERIAL_8250_CONSOLE 1
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define CONFIG_X86_CMOV 1
+#define CONFIG_RD_LZO 1
+#define CONFIG_ARCH_HAS_CPU_IDLE_WAIT 1
+#define CONFIG_INSTRUCTION_DECODER 1
+#define CONFIG_SCSI_WAIT_SCAN_MODULE 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_INET_XFRM_MODE_BEET 1
+#define CONFIG_HAVE_DYNAMIC_FTRACE 1
+#define CONFIG_MAGIC_SYSRQ 1
+#define CONFIG_IO_DELAY_0X80 1
+#define CONFIG_DMI 1
+#define CONFIG_DEFAULT_CFQ 1
+#define CONFIG_CPU_SUP_AMD 1
+#define CONFIG_INET6_XFRM_MODE_TUNNEL 1
+#define CONFIG_PCIEPORTBUS 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_EXT3_FS 1
+#define CONFIG_INET_TUNNEL 1
+#define CONFIG_X86_INTERNODE_CACHE_SHIFT 6
+#define CONFIG_GENERIC_CLOCKEVENTS 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_RWSEM_XCHGADD_ALGORITHM 1
+#define CONFIG_HAVE_KERNEL_XZ 1
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_DETECT_HUNG_TASK 1
+#define CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT 0
+#define CONFIG_CRYPTO_RNG 1
+#define CONFIG_RD_GZIP 1
+#define CONFIG_ARCH_HAS_CPU_RELAX 1
+#define CONFIG_HAVE_REGS_AND_STACK_ACCESS_API 1
+#define CONFIG_SWIOTLB 1
+#define CONFIG_INET_XFRM_MODE_TRANSPORT 1
+#define CONFIG_ATA_ACPI 1
+#define CONFIG_HAVE_ARCH_KMEMCHECK 1
+#define CONFIG_ACPI_PROCESSOR 1
+#define CONFIG_HAVE_KVM 1
+#define CONFIG_HAVE_GENERIC_HARDIRQS 1
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_SCSI_PROC_FS 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_DEBUG_MUTEXES 1
+#define CONFIG_SLABINFO 1
+#define CONFIG_CRYPTO_HW 1
+#define CONFIG_PCSPKR_PLATFORM 1
+#define CONFIG_ACPI_AC 1
+#define CONFIG_XZ_DEC_X86 1
+#define CONFIG_CRC16 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_X86_CMPXCHG 1
+#define CONFIG_BROKEN_ON_SMP 1
+#define CONFIG_TMPFS 1
+#define CONFIG_ANON_INODES 1
+#define CONFIG_FUTEX 1
+#define CONFIG_VIRTIO_PCI 1
+#define CONFIG_RTC_HCTOSYS 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_USER_STACKTRACE_SUPPORT 1
+#define CONFIG_SLUB_DEBUG 1
+#define CONFIG_IPV6_NDISC_NODETYPE 1
+#define CONFIG_PCI_LABEL 1
+#define CONFIG_MODULES 1
+#define CONFIG_ARCH_HIBERNATION_POSSIBLE 1
+#define CONFIG_UNIX 1
+#define CONFIG_DEFAULT_HOSTNAME "(none)"
+#define CONFIG_HPET_TIMER 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_MISC_DEVICES 1
+#define CONFIG_RD_BZIP2 1
+#define CONFIG_ARCH_SUPPORTS_MSI 1
+#define CONFIG_KEYBOARD_ATKBD 1
+#define CONFIG_ARCH_HAS_DEFAULT_IDLE 1
+#define CONFIG_CPU_IDLE 1
+#define CONFIG_LOG_BUF_SHIFT 17
+#define CONFIG_EXTRA_FIRMWARE ""
+#define CONFIG_VIRT_TO_BUS 1
+#define CONFIG_CMPXCHG_LOCAL 1
+#define CONFIG_GENERIC_CPU 1
+#define CONFIG_DEFAULT_HUNG_TASK_TIMEOUT 120
+#define CONFIG_HAVE_OPTPROBES 1
+#define CONFIG_SUSPEND 1
+#define CONFIG_SERIAL_8250_RUNTIME_UARTS 4
+#define CONFIG_FS_MBCACHE 1
+#define CONFIG_RTC_CLASS 1
+#define CONFIG_HAVE_LATENCYTOP_SUPPORT 1
+#define CONFIG_IOMMU_HELPER 1
+#define CONFIG_HAVE_FUNCTION_TRACER 1
+#define CONFIG_ARCH_SELECT_MEMORY_MODEL 1
+#define CONFIG_SLUB 1
+#define CONFIG_XZ_DEC_BCJ 1
+#define CONFIG_PM_SLEEP 1
+#define CONFIG_FRAME_POINTER 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_HAVE_MMIOTRACE_SUPPORT 1
+#define CONFIG_GENERIC_FIND_FIRST_BIT 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_FW_LOADER 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_PCI 1
+#define CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
+#define CONFIG_DECOMPRESS_XZ 1
+#define CONFIG_PCI_QUIRKS 1
+#define CONFIG_MII 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_HAVE_UNSTABLE_SCHED_CLOCK 1
+#define CONFIG_EXT4_FS 1
+#define CONFIG_HAVE_HW_BREAKPOINT 1
+#define CONFIG_XZ_DEC 1
+#define CONFIG_SATA_PMP 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_X86_WP_WORKS_OK 1
+#define CONFIG_GART_IOMMU 1
+#define CONFIG_EPOLL 1
+#define CONFIG_ARCH_HWEIGHT_CFLAGS "-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11"
+#define CONFIG_NET 1
+#define CONFIG_HAVE_SPARSE_IRQ 1
+#define CONFIG_ACPI_SLEEP 1
+#define CONFIG_PACKET 1
+#define CONFIG_INET 1
+#define CONFIG_XZ_DEC_POWERPC 1
+#define CONFIG_VIRTIO_NET 1
+#define CONFIG_SERIAL_8250_PNP 1
+#define CONFIG_FREEZER 1
+#define CONFIG_PCI_DOMAINS 1
+#define CONFIG_X86_DEBUGCTLMSR 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_X86_LOCAL_APIC 1
+#define CONFIG_HAVE_KPROBES 1
+#define CONFIG_CRYPTO_AES 1
+#define CONFIG_EXT4_USE_FOR_EXT23 1
+#define CONFIG_HT_IRQ 1
+#define CONFIG_RD_XZ 1
+#define CONFIG_INET_XFRM_MODE_TUNNEL 1
+#define CONFIG_VGA_CONSOLE 1
+#define CONFIG_ATA_VERBOSE_ERROR 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_DEBUG_SPINLOCK 1
+#define CONFIG_ACPI_BUTTON 1
+#define CONFIG_ILLEGAL_POINTER_VALUE 0xdead000000000000
+#define CONFIG_SYSCTL_SYSCALL 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
+#define CONFIG_NEED_DMA_MAP_STATE 1
+#define CONFIG_X86_XADD 1
+#define CONFIG_SERIO_LIBPS2 1
+#define CONFIG_GENERIC_IOMAP 1
+#define CONFIG_PREEMPT_NONE 1
+#define CONFIG_SPARSEMEM_MANUAL 1
+#define CONFIG_HAVE_KERNEL_GZIP 1
+#define CONFIG_PNP 1
+#define CONFIG_NEED_PER_CPU_KM 1
+#define CONFIG_KALLSYMS_ALL 1
+#define CONFIG_GENERIC_BUG 1
+#define CONFIG_HAVE_FTRACE_MCOUNT_RECORD 1
+#define CONFIG_INET_TCP_DIAG 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER 1
+#define CONFIG_HAVE_IOREMAP_PROT 1
+#define CONFIG_DEBUG_KERNEL 1
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_CRYPTO 1
+#define CONFIG_SCHED_DEBUG 1
+#define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
+#define CONFIG_VIRTIO 1
+#define CONFIG_HAVE_DMA_API_DEBUG 1
+#define CONFIG_GENERIC_IRQ_SHOW 1
+#define CONFIG_SCSI_MOD 1
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_ARCH_PHYS_ADDR_T_64BIT 1
+#define CONFIG_HAVE_KRETPROBES 1
+#define CONFIG_HAS_DMA 1
+#define CONFIG_NET_PCI 1
+#define CONFIG_IO_DELAY_TYPE_NONE 3
+#define CONFIG_SCSI 1
+#define CONFIG_X86_64 1
+#define CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG 1
+#define CONFIG_RTC_DRV_CMOS 1
+#define CONFIG_ARCH_HAS_CACHE_LINE_SIZE 1
+#define CONFIG_JBD2 1
+#define CONFIG_MISC_FILESYSTEMS 1
+#define CONFIG_CLOCKSOURCE_WATCHDOG 1
+#define CONFIG_DECOMPRESS_BZIP2 1
+#define CONFIG_XZ_DEC_SPARC 1
+#define CONFIG_ARCH_SPARSEMEM_DEFAULT 1
+#define CONFIG_X86_RESERVE_LOW 64
+#define CONFIG_NEED_SG_DMA_LENGTH 1
+#define CONFIG_SPARSEMEM 1
+#define CONFIG_INET6_XFRM_MODE_TRANSPORT 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_HZ_250 1
+#define CONFIG_X86_IO_APIC 1
+#define CONFIG_ARCH_POPULATES_NODE_MAP 1
+#define CONFIG_FRAME_WARN 2048
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_INITRAMFS_SOURCE ""
+#define CONFIG_DEBUG_RODATA_TEST 1
+#define CONFIG_PROVE_LOCKING 1
+#define CONFIG_STACKTRACE 1
+#define CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC 1
+#define CONFIG_HAS_IOPORT 1
+#define CONFIG_X86_CMPXCHG64 1
+#define CONFIG_ISA_DMA_API 1
+#define CONFIG_HZ 250
+#define CONFIG_ACPI_PROC_EVENT 1
+#define CONFIG_DIRECT_GBPAGES 1
+#define CONFIG_SERIAL_8250_NR_UARTS 4
+#define CONFIG_HAVE_USER_RETURN_NOTIFIER 1
+#define CONFIG_DEFAULT_IOSCHED "cfq"
+#define CONFIG_NLATTR 1
+#define CONFIG_HOTPLUG_PCI 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_NR_CPUS 1
+#define CONFIG_SUSPEND_FREEZER 1
+#define CONFIG_SYSFS 1
+#define CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST 1
+#define CONFIG_XZ_DEC_ARM 1
+#define CONFIG_DEFAULT_IO_DELAY_TYPE 0
+#define CONFIG_HAVE_SYSCALL_TRACEPOINTS 1
+#define CONFIG_ACPI_BATTERY 1
+#define CONFIG_SPARSEMEM_VMEMMAP_ENABLE 1
+#define CONFIG_TRACE_IRQFLAGS 1
+#define CONFIG_VIRTUALIZATION 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_HAVE_OPROFILE 1
+#define CONFIG_CPU_IDLE_GOV_LADDER 1
+#define CONFIG_THERMAL 1
+#define CONFIG_HAVE_ARCH_KGDB 1
+#define CONFIG_X86_PM_TIMER 1
+#define CONFIG_ZONE_DMA_FLAG 1
+#define CONFIG_GENERIC_CMOS_UPDATE 1
+#define CONFIG_DEFAULT_SECURITY ""
+#define CONFIG_MTRR_SANITIZER 1
+#define CONFIG_TINY_RCU 1
+#define CONFIG_IO_DELAY_TYPE_0X80 0
+#define CONFIG_HAVE_DMA_ATTRS 1
+#define CONFIG_EARLY_PRINTK 1
+#define CONFIG_HAVE_FUNCTION_GRAPH_TRACER 1
+#define CONFIG_ACPI_THERMAL 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_HAVE_TEXT_POKE_SMP 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_GENERIC_BUG_RELATIVE_POINTERS 1
+#define CONFIG_SCSI_LOWLEVEL 1
+#define CONFIG_IRQ_FORCED_THREADING 1
+#define CONFIG_PAGEFLAGS_EXTENDED 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_PHYS_ADDR_T_64BIT 1
+#define CONFIG_HAVE_C_RECORDMCOUNT 1
+#define CONFIG_HAVE_ARCH_TRACEHOOK 1
+#define CONFIG_NET_NS 1
+#define CONFIG_HAVE_PERF_EVENTS 1
+#define CONFIG_ATA_SFF 1
+#define CONFIG_NO_BOOTMEM 1
+#define CONFIG_DEBUG_MEMORY_INIT 1
+#define CONFIG_PCIEASPM 1
+#define CONFIG_ATA_PIIX 1
+#define CONFIG_SATA_AHCI 1
+#define CONFIG_BLK_DEV 1
+#define CONFIG_SERIO_I8042 1
+#define CONFIG_TRACING_SUPPORT 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_CRYPTO_ANSI_CPRNG 1
+#define CONFIG_ZONE_DMA32 1
+#define CONFIG_JBD 1
+#define CONFIG_LOCKDEP 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
+#define CONFIG_ARCH_MAY_HAVE_PC_FDC 1
+#define CONFIG_HAVE_KERNEL_LZO 1
+#define CONFIG_INET_DIAG 1
+#define CONFIG_IO_DELAY_TYPE_UDELAY 2
+#define CONFIG_ELF_CORE 1
+#define CONFIG_INET_LRO 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_PCI_DIRECT 1
+#define CONFIG_INET6_XFRM_MODE_BEET 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BUILD 1
+#define CONFIG_DECOMPRESS_GZIP 1
+#define CONFIG_VIRTIO_BLK 1
+#define CONFIG_DECOMPRESS_LZO 1
+#define CONFIG_64BIT 1
+#define CONFIG_CROSS_COMPILE ""
+#define CONFIG_GENERIC_CLOCKEVENTS_BROADCAST 1
+#define CONFIG_SERIAL_8250_PCI 1
+#define CONFIG_HAVE_MIXED_BREAKPOINTS_REGS 1
+#define CONFIG_ATA_BMDMA 1
+#define CONFIG_XZ_DEC_ARMTHUMB 1
+#define CONFIG_ARCH_WANT_FRAME_POINTERS 1
+#define CONFIG_CPU_SUP_CENTAUR 1
+#define CONFIG_ARCH_USES_PG_UNCACHED 1
+#define CONFIG_BLK_DEV_SD 1
+#define CONFIG_PHYSICAL_ALIGN 0x1000000
+#define CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST 1
+#define CONFIG_BITREVERSE 1
+#define CONFIG_DEVPORT 1
+#define CONFIG_X86_L1_CACHE_SHIFT 6
+#define CONFIG_X86_PAT 1
+#define CONFIG_PNP_DEBUG_MESSAGES 1
+#define CONFIG_ARCH_DMA_ADDR_T_64BIT 1
+#define CONFIG_FILE_LOCKING 1
+#define CONFIG_AIO 1
+#define CONFIG_PERF_EVENTS 1
+#define CONFIG_GENERIC_TIME_VSYSCALL 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_RTC_INTF_DEV 1
+#define CONFIG_EXT4_FS_XATTR 1
+#define CONFIG_AMD_NB 1
+#define CONFIG_NLS_DEFAULT "iso8859-1"
+#define CONFIG_DEBUG_INFO 1
+#define CONFIG_CRYPTO_ALGAPI2 1
+#define CONFIG_PHYSICAL_START 0x1000000
+#define CONFIG_HAVE_MEMBLOCK 1
+#define CONFIG_DEBUG_RODATA 1
+#define CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS 1
+#define CONFIG_INPUT 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_HAVE_PERF_EVENTS_NMI 1
+#define CONFIG_MMU 1
+#define CONFIG_HAVE_IRQ_WORK 1
diff -Nurp linux/include/generated/bounds.h linux-3.0/include/generated/bounds.h
--- linux/include/generated/bounds.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/generated/bounds.h	2014-02-19 21:05:11.326677939 -0500
@@ -0,0 +1,14 @@
+#ifndef __LINUX_BOUNDS_H__
+#define __LINUX_BOUNDS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define NR_PAGEFLAGS 23 /* __NR_PAGEFLAGS	# */
+#define MAX_NR_ZONES 4 /* __MAX_NR_ZONES	# */
+#define NR_PCG_FLAGS 7 /* __NR_PCG_FLAGS	# */
+
+#endif
diff -Nurp linux/include/generated/compile.h linux-3.0/include/generated/compile.h
--- linux/include/generated/compile.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/generated/compile.h	2014-02-19 21:05:11.327677962 -0500
@@ -0,0 +1,6 @@
+/* This file is auto generated, version 6 */
+#define UTS_MACHINE "x86_64"
+#define UTS_VERSION "#6 Thu Nov 1 13:45:36 EDT 2012"
+#define LINUX_COMPILE_BY "joepleso"
+#define LINUX_COMPILE_HOST "pet-lab-4"
+#define LINUX_COMPILER "gcc version 4.6.1 (Ubuntu/Linaro 4.6.1-9ubuntu3) "
diff -Nurp linux/include/generated/utsrelease.h linux-3.0/include/generated/utsrelease.h
--- linux/include/generated/utsrelease.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/generated/utsrelease.h	2014-02-19 21:05:11.347678413 -0500
@@ -0,0 +1 @@
+#define UTS_RELEASE "3.0.0"
diff -Nurp linux/include/linux/version.h linux-3.0/include/linux/version.h
--- linux/include/linux/version.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/include/linux/version.h	2014-02-19 21:05:28.584067310 -0500
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 196608
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -Nurp linux/Module.symvers linux-3.0/Module.symvers
--- linux/Module.symvers	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/Module.symvers	2014-02-19 21:05:59.729769898 -0500
@@ -0,0 +1,4191 @@
+0x00000000	sata_pmp_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_write	vmlinux	EXPORT_SYMBOL
+0x00000000	set_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	replace_page_cache_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cond_resched_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_class_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_sense_key_string	vmlinux	EXPORT_SYMBOL
+0x00000000	request_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	unblock_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	console_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_end_command	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_execute	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoll	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_seq_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_install_notify_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	init_uts_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__inet6_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_release	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_start	vmlinux	EXPORT_SYMBOL
+0x00000000	ioread32be	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_map_sector_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_update_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_initialize_rcv_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	net_enable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	sockfd_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_tf_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_load_table	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_max_hw_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	__unregister_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	directly_mappable_cdev_bdi	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_graft_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_command	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_next_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	vfsmount_lock_global_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	input_handler_for_each_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	default_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_attr_link_power_management_policy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_read_config_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	iget_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestampns	vmlinux	EXPORT_SYMBOL
+0x00000000	class_interface_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iowrite8_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	class_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfsmount_lock_local_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_write_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	__srcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	reset_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_last	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_string	vmlinux	EXPORT_SYMBOL
+0x00000000	memmove	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	__block_page_mkwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	laptop_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	end_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_direct_write	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	d_alloc_pseudo	vmlinux	EXPORT_SYMBOL
+0x00000000	fiemap_check_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_readonly_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ipv6_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_pci_find_root	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_map_rom	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_copychunks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfsmount_lock_lock_dep_map	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_table_header	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_page	vmlinux	EXPORT_SYMBOL
+0x00000000	register_console	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_socketpair	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_pci_bmdma_init_one	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_del	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_tso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_set_firmware_waking_vector64	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_copy_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	__krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_in_prepare_r	vmlinux	EXPORT_SYMBOL
+0x00000000	task_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_install_interface_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mm_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_scr_write_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_miter_start	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_in_user	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_unprep_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_read	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_mode_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_stop_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	load_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_year_days	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_link_offline	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_host_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	add_timer_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_group_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_slots_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev16	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoull_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou16_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	free_dma	vmlinux	EXPORT_SYMBOL
+0x00000000	device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_load	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_add	vmlinux	EXPORT_SYMBOL
+0x00000000	scsicam_bios_param	vmlinux	EXPORT_SYMBOL
+0x00000000	single_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	I_BDEV	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_unregister_irq_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_tty_get	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_tty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enable_all_runtime_gpes	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_route_child_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_path_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	find_or_create_page	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debug_lockdep_rcu_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_reset_provider	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_range_reserved	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_twsk_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_extd_sense_format	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_uevent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wakeup_source_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_write_config_dword	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_user_nocache	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_hung_up_p	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_child	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_cleanup_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setlease	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_is_keyboard_id	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_list_add_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	syscore_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_walk_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_enable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	timerqueue_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hpet_set_periodic_freq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_timing_merge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	swiotlb_unmap_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	write_one_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_boottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_synchronize_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_activate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	n_tty_ioctl_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	virtqueue_enable_cb_delayed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_event_status	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_blockdev	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_rfree	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__root_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_next_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_part_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	freeze_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_processor_ffh_cstate_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_kill_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_long	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_msi_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_parent_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_nocheck	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_defrag	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_show_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idr_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_read	vmlinux	EXPORT_SYMBOL
+0x00000000	free_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_next_object	vmlinux	EXPORT_SYMBOL
+0x00000000	free_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_setup_caps	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_get	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateIncomp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sigprocmask	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	ec_burst_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	do_mmap_pgoff	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_rmem	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	amd_e400_c1e_detected	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_flush_all	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_acpi_gtm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_acpi_stm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pipe_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	genlmsg_multicast_allns	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_restore	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_rescan_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_scsi_slave_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_kernel_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	mktime	vmlinux	EXPORT_SYMBOL
+0x00000000	system_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pcibios_align_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_next	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	con_set_default_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_ido	vmlinux	EXPORT_SYMBOL
+0x00000000	match_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	ioctl_by_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_remove_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_delete_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_register_guest_info_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	__secpath_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_bit_function	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_route_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_dev_classify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_release_private	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	hw_breakpoint_restore	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_km	vmlinux	EXPORT_SYMBOL
+0x00000000	in_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_next	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	unshare_fs_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	system_nrt_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tasklet_hi_schedule_first	vmlinux	EXPORT_SYMBOL
+0x00000000	x86_platform	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_carrier_raised	vmlinux	EXPORT_SYMBOL
+0x00000000	__brelse	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_probe_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_sock_destruct	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_chars_in_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_unregister_region	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	__serio_register_port	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_pull_rcsum	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_invalid_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_gang_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	register_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_alloc_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_pages_exact_nid	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_on	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_parse_options	vmlinux	EXPORT_SYMBOL
+0x00000000	gdt_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ctl_sock_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_add_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	firmware_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_store_saved_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_register_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	___pskb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_prereset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_driver_flush_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_setup_cardbus	vmlinux	EXPORT_SYMBOL
+0x00000000	strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	strsep	vmlinux	EXPORT_SYMBOL
+0x00000000	iomem_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_scr_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_kfree	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_virtio_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mnt_unpin	vmlinux	EXPORT_SYMBOL
+0x00000000	end_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_create	vmlinux	EXPORT_SYMBOL
+0x00000000	sb_min_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	register_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_hardirqs_on_caller	vmlinux	EXPORT_SYMBOL
+0x00000000	setup_deferrable_timer_on_stack_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuidle_disable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serial8250_resume_port	vmlinux	EXPORT_SYMBOL
+0x00000000	pcix_set_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	__kernel_param_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	del_gendisk	vmlinux	EXPORT_SYMBOL
+0x00000000	block_write_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_register_type	vmlinux	EXPORT_SYMBOL
+0x00000000	put_mnt_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	____pagevec_lru_add	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	__blockdev_direct_IO	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_end	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_device_update	vmlinux	EXPORT_SYMBOL
+0x00000000	km_new_mapping	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_check_resource_conflict	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_sync_single_for_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_block_bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__symbol_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ip_dev_find	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_atomic_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	d_materialise_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_free	vmlinux	EXPORT_SYMBOL
+0x00000000	file_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_bounce	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bin2bcd	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	__request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_detach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_is_root_bridge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_ec_add_query_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdev_read_only	vmlinux	EXPORT_SYMBOL
+0x00000000	put_pages_list	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wfree	vmlinux	EXPORT_SYMBOL
+0x00000000	test_set_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_exclusive_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_remap	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	amd_erratum_400	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	amd_erratum_383	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_timer_bug_msg	vmlinux	EXPORT_SYMBOL
+0x00000000	input_flush_device	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	num_physpages	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strpbrk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_frag_match	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_vpd_find_info_keyword	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_find_free_region	vmlinux	EXPORT_SYMBOL
+0x00000000	set_disk_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_unprep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_aalg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_create_openreq_child	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_common_release	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_prepare_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_reset_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_get_irq_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flex_array_get_ptr	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc_bioset	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_ethtool_gset	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_ethtool_sset	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_cancel_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_remove_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_processor_power_init_bm_check	vmlinux	EXPORT_SYMBOL
+0x00000000	release_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unmap_underlying_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	con_debug_leave	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__invalidate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_low_latency	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_qc_issue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_max_low_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_unregister_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_hlist_next_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_flip_buffer_push	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_get_divisor	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_add_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msleep	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_async_notification	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_net_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bforget	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_unhash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	input_mt_destroy_slots	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	get_random_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_off	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_lock_nest_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_vpd_find_tag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_augment_erase_end	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_peek_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_prep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vlan_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_shorten	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_scan_target	vmlinux	EXPORT_SYMBOL
+0x00000000	list_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_arg_zero	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_pfn_range	vmlinux	EXPORT_SYMBOL
+0x00000000	getnstimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	device_bind_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_vpd_truncate	vmlinux	EXPORT_SYMBOL
+0x00000000	file_update_time	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_init	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_setup_blk_pc_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	_kstrtol	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_uevent_env	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_entry_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	init_timer_key	vmlinux	EXPORT_SYMBOL
+0x00000000	fpu_finit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_cmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_free_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_wake_from_d3	vmlinux	EXPORT_SYMBOL
+0x00000000	filp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_setsize	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_std_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	ether_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	device_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__break_lease	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_comm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_augment_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages_range	vmlinux	EXPORT_SYMBOL
+0x00000000	force_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_dma_max_seg_size	vmlinux	EXPORT_SYMBOL
+0x00000000	d_path	vmlinux	EXPORT_SYMBOL
+0x00000000	vring_del_virtqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_notifier_call_chain	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstatat	vmlinux	EXPORT_SYMBOL
+0x00000000	sdev_evt_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	igrab	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_back_from_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_check_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	warn_slowpath_null	vmlinux	EXPORT_SYMBOL
+0x00000000	linkwatch_fire_event	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_install_fixed_event_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_build_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_mt_report_slot_state	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_init_io	vmlinux	EXPORT_SYMBOL
+0x00000000	__memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_lock_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_sync_single_for_device	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_write_wakeup	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_read_config_word	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_append	vmlinux	EXPORT_SYMBOL
+0x00000000	pciserial_suspend_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_cache_page_gfp	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_delayed_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_error	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_crit	vmlinux	EXPORT_SYMBOL
+0x00000000	ec_write	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sget	vmlinux	EXPORT_SYMBOL
+0x00000000	memset	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_map_biosrom	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_start_engine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sw_hweight8	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_mounts_for_expiry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	work_cpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_input_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	d_set_d_op	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_drain	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_table	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_get_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_get_status	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_am_i_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_configure_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	revalidate_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	register_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_in	vmlinux	EXPORT_SYMBOL
+0x00000000	misc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	block_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	may_umount_tree	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_get_port	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_wait_ready	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_attr_unload_heads	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_ldisc_ref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	mtrr_add	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_af_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_remove_gpe_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	iget_failed	vmlinux	EXPORT_SYMBOL
+0x00000000	mac_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_tso	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_dumb_qc_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_set_spd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_restore_state	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_enable_xhci_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_trim	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_sub_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_set_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_release_selected_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet6_lookup_established	vmlinux	EXPORT_SYMBOL
+0x00000000	__nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_init	vmlinux	EXPORT_SYMBOL
+0x00000000	amd_flush_garts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_udp_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_ecn	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_tx_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_mii_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_size_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_wc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_wb	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_delete_tunnel	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_resources	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in6_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_rescan_device	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_prev	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_init_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_unlink_disk_holder	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_evaluate_object	vmlinux	EXPORT_SYMBOL
+0x00000000	__const_udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_tw_get_peer	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_flags_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_sysrq	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_port_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_kstrtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	__block_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	register_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	timespec_trunc	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sockets_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_release_global_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_owner_or_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_confirm	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_gpe_status	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_select_bars	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_power_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_register_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	__ata_ehi_push_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	con_copy_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_ref_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_commit_write	vmlinux	EXPORT_SYMBOL
+0x00000000	__netdev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_spin_lock_init	vmlinux	EXPORT_SYMBOL
+0x00000000	bcd2bin	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_get_undo_access	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_create_kernel_counter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	dput	vmlinux	EXPORT_SYMBOL
+0x00000000	is_container_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_deb_timing_long	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	screen_glyph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_free	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_sdev_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_max_busnr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_init	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_update_format	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_link_online	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_segment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_max_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	warn_slowpath_fmt_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_init_congestion_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_push	vmlinux	EXPORT_SYMBOL
+0x00000000	device_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_run_queue_async	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_file	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_lock_irqsave_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	free_task	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_valid_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_block_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_start	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_in_finish_r	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_save_initial_config	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__getblk	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	x86_cpu_to_apicid	vmlinux	EXPORT_SYMBOL
+0x00000000	xstate_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_wakeup_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_current_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_cable_sata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wakeup_source_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sw_hweight32	vmlinux	EXPORT_SYMBOL
+0x00000000	__sw_hweight16	vmlinux	EXPORT_SYMBOL
+0x00000000	__sw_hweight64	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_prealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_skip_r	vmlinux	EXPORT_SYMBOL
+0x00000000	pagevec_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	current_kernel_time	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_cong_avoid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_set_nonroot	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_queuecmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy_compat	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_alarm_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcim_iounmap_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_modify_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_input_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	udplite_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_restore_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_remove_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_find_next_zero_area	vmlinux	EXPORT_SYMBOL
+0x00000000	__suspend_report_result	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_tryget	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_evaluate_reference	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_attach_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_detach_filter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	unload_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	__supported_pte_mask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_gso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_register_card_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_left	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_skb_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	i8042_remove_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_postreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_table_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	ht_destroy_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_plug	vmlinux	EXPORT_SYMBOL
+0x00000000	bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_init	vmlinux	EXPORT_SYMBOL
+0x00000000	request_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	generate_netlink_event	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_fault_in_readable	vmlinux	EXPORT_SYMBOL
+0x00000000	module_mutex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_resume_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_enable_subsystem	vmlinux	EXPORT_SYMBOL
+0x00000000	modify_user_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cap_empty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_pcie_error_reporting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shoot_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iput	vmlinux	EXPORT_SYMBOL
+0x00000000	sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	snmp_mib_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_upload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_unmap_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_doulongvec_ms_jiffies_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_bitremap	vmlinux	EXPORT_SYMBOL
+0x00000000	register_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_event_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_data_xfer_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aer_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elevator_change	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_blocks_per_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_scsi_unlock_native_capacity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_firmware_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_load_tables	vmlinux	EXPORT_SYMBOL
+0x00000000	kref_get	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_change_features	vmlinux	EXPORT_SYMBOL
+0x00000000	init_dummy_netdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_ido	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_ltr	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_errno	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_mode_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_ltr	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_check_available_features	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_waitqueue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_tunnel_register	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_insert_cloned_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_timer_deferrable_key	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_datagram_from_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_compute_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timerqueue_iterate_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_put_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	single_release	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_optmem_max	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_dev_to_name	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	in4_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	in6_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_mode_select	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_xor	vmlinux	EXPORT_SYMBOL
+0x00000000	__clear_user	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_want_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_softreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	suspend_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_write_unlock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	__starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_has_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iget5_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_handler_data	vmlinux	EXPORT_SYMBOL
+0x00000000	yield_to	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_check_media	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	test_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_remove_address_space_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_bus_parented	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_bh_lrus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_read_non_owner	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_lid_notifier_register	vmlinux	EXPORT_SYMBOL
+0x00000000	register_acpi_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_aes_expand_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_splice_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek_unlocked	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_read	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_map	vmlinux	EXPORT_SYMBOL
+0x00000000	console_suspend_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_fix_features	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	cad_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtou8	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_hash_frag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__big_tty_mutex_owner	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flex_array_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_probing_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_dev_classify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_update_format	vmlinux	EXPORT_SYMBOL
+0x00000000	recalc_sigpending	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_acpi_gtm_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lockdep_init_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_part_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	follow_down_one	vmlinux	EXPORT_SYMBOL
+0x00000000	recalibrate_cpu_khz	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_unprep_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_options_rcv_srr	vmlinux	EXPORT_SYMBOL
+0x00000000	device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_request_card_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_regions_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_open	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_checksum_help	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_remove_list	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_data	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_install_global_event_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_init	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_pause_and_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_hsm_move	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_link_debounce	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	virtqueue_enable_cb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_get_undo_access	vmlinux	EXPORT_SYMBOL
+0x00000000	register_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_do_set_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_xfer_mode2mask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fiemap_fill_next_extent	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_set_sk_err	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_add_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_check_events	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	downgrade_write	vmlinux	EXPORT_SYMBOL
+0x00000000	complete	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_port_freeze	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_iter_single_seg_count	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_link_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_test_unit_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_update_name_case	vmlinux	EXPORT_SYMBOL
+0x00000000	high_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_unmap_biosrom	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_install_table_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enter_sleep_state_prep	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_link	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_target	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_result	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_blocks_per_page	vmlinux	EXPORT_SYMBOL
+0x00000000	page_cache_async_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	kblockd_schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_section	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig_info	vmlinux	EXPORT_SYMBOL
+0x00000000	iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__neigh_event_send	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_close	vmlinux	EXPORT_SYMBOL
+0x00000000	show_class_attr_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_store_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_cache_page_async	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout_uninterruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	allow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_get_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	clflush_cache_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_msleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_pcie_error_reporting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_dgram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	virtqueue_get_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_pipe_buf_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_steal	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_exit_net	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_get	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_put	vmlinux	EXPORT_SYMBOL
+0x00000000	files_lglock_local_unlock_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_copystring	vmlinux	EXPORT_SYMBOL
+0x00000000	__send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	debug_check_no_locks_freed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_merge_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_start_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	d_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_rwsem	vmlinux	EXPORT_SYMBOL
+0x00000000	page_zero_new_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	mntput	vmlinux	EXPORT_SYMBOL
+0x00000000	mntget	vmlinux	EXPORT_SYMBOL
+0x00000000	fasync_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	lockdep_rtnl_is_held	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_mandatory_area	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_deschedule	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_ufo	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_pskb	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_right	vmlinux	EXPORT_SYMBOL
+0x00000000	__request_module	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_inherit_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_deactivate	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__rwlock_init	vmlinux	EXPORT_SYMBOL
+0x00000000	srandom32	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	set_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	km_policy_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_find	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_out_peek_r	vmlinux	EXPORT_SYMBOL
+0x00000000	dlci_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_tx_ipv6_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_report_device_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_free_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_link_abort	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rename_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	page_symlink_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	register_virtio_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou16	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_inode_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	vunmap	vmlinux	EXPORT_SYMBOL
+0x00000000	write_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	refrigerator	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	do_blank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_virtio_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_prot_clear_portaddr_nulls	vmlinux	EXPORT_SYMBOL
+0x00000000	task_current_syscall	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	single_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_page_dirty_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_conn_request	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_port_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_port_abort	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_wmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_syn_recv_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_tbl_sync_single	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	icmp_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_check_link	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_set_power	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_hashinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	fd_install	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_internal_device_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fsync_range	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_evntsel_nmi	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_get_device_klist	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_put	vmlinux	EXPORT_SYMBOL
+0x00000000	apply_to_page_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	out_of_line_wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_lock_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	__iowrite64_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_partition	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_release_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	pciserial_remove_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pciserial_resume_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_miter_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_init_jbd_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_biosrom_size	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_finish_plug	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_32_user	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_pmp_qc_defer_cmd_switch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_port_intr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_scsi_change_queue_depth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_subsys	vmlinux	EXPORT_SYMBOL
+0x00000000	do_brk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_adv_win_scale	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_page	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_test_config_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unlock_flocks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_next_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_init	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i8253_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	secpath_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	set_user_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_direct_to_actor	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_get_res	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close_start	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_release	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_add_before	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vga_put	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_attr_alg2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proto_register	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_irq_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_wakeup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_pci_disabled	vmlinux	EXPORT_SYMBOL
+0x00000000	check_disk_size_change	vmlinux	EXPORT_SYMBOL
+0x00000000	down_read	vmlinux	EXPORT_SYMBOL
+0x00000000	km_report	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_expand	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_free_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_setup_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_softirq_done	vmlinux	EXPORT_SYMBOL
+0x00000000	d_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_flush_done_q	vmlinux	EXPORT_SYMBOL
+0x00000000	virtio_check_driver_offered_feature	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_iomap	vmlinux	EXPORT_SYMBOL
+0x00000000	path_is_under	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_morph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_unregister_port	vmlinux	EXPORT_SYMBOL
+0x00000000	ioremap_nocache	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_host	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_selected_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_host_device	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioremap_nocache	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_ssthresh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_remove_bus_device	vmlinux	EXPORT_SYMBOL
+0x00000000	iter_div_u64_rem	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	i8042_lock_chip	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_enable_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_once	vmlinux	EXPORT_SYMBOL
+0x00000000	__srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_move	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	ns_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_add_global	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_del_global	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_device_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	vfsmount_lock_local_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	trace_hardirqs_on	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_table_init	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_effect_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	attribute_container_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_segment_boundary	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stop_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_insert_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	task_active_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_terminate	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_add_dynid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clock_t_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_table	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_release	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_std_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_resume_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_put_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_latter_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nr_free_buffer_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_memory_ro	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_memory_rw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_khz	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	serial8250_do_pm	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_physical_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_ltr_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtouint	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	up_write	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_all_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_prep_state_check	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_target_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	fget	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_syscore_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_log_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	match_token	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_abort	vmlinux	EXPORT_SYMBOL
+0x00000000	vmtruncate	vmlinux	EXPORT_SYMBOL
+0x00000000	down_write	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_output_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsilun_to_int	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_test_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_block_super	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_lookup_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	crc16	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	kallsyms_on_each_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mutex_lock_nested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bsearch	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_put_request	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_full_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_create_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_queue_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_port_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_limits_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_remove_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mapping_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	color_table	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_check_region	vmlinux	EXPORT_SYMBOL
+0x00000000	put_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	add_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	argv_split	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	find_first_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_hw_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aes_set_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2__journal_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	console_conditional_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_stack	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_scsi_cmd_error_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_target_state	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	writeback_inodes_sb_nr_if_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	xattr_getsecurity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smp_call_function_single	vmlinux	EXPORT_SYMBOL
+0x00000000	native_read_tsc	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_erase	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_busy_sleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strcasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	save_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	clockevents_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ifla_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unthrottle	vmlinux	EXPORT_SYMBOL
+0x00000000	set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	block_page_mkwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	set_timer_slack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_compat_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_spawn_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_error_remove_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_prefix	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_dst_lookup_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_unhash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmi_check_system	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_execute_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_dev_select	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_noop_qc_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_object_info	vmlinux	EXPORT_SYMBOL
+0x00000000	vsscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_unlock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_vfs_cache_pressure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kern_path_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	panic	vmlinux	EXPORT_SYMBOL
+0x00000000	ioremap_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	reserve_perfctr_nmi	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_dma_seg_boundary	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_init_one	vmlinux	EXPORT_SYMBOL
+0x00000000	__kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_port_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_irq_routing_table	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_init_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debug_show_held_locks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ip_select_ident	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_gro_receive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sg_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_next_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_ht_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_load	vmlinux	EXPORT_SYMBOL
+0x00000000	flock_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_warn_lro_forwarding	vmlinux	EXPORT_SYMBOL
+0x00000000	memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_init_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_add_pc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_stacked_transfer_operstate	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_reconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	d_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	cont_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_mode_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflate	vmlinux	EXPORT_SYMBOL
+0x00000000	vscnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_recount_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_long	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_dr7	vmlinux	EXPORT_SYMBOL
+0x00000000	km_policy_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_tunnel_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_join_group	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_is_intel_switchable_xhci	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_timing_find_mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_free	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioread8_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	uuid_be_gen	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lease_modify	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_dst_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_start	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_sysdev_class	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_assign_unassigned_bridge_resources	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioread32_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header_cache_update	vmlinux	EXPORT_SYMBOL
+0x00000000	virtqueue_disable_cb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_copy_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	strncpy	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	get_max_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_hardirqs_off	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_disabled	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_release_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kern_mount_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__init_kthread_worker	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_requeue_request	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked4	vmlinux	EXPORT_SYMBOL
+0x00000000	strndup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_wb	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	pagevec_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_find_acq	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_mac_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_scan_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_setup_fs_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lockdep_rcu_dereference	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idle_notifier_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_tm_to_time	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_slave_link_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_compat_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	allocate_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	task_ns_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_feed	vmlinux	EXPORT_SYMBOL
+0x00000000	__round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_fold	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_shutdown_super	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_track_queue_full	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_evaluate_integer	vmlinux	EXPORT_SYMBOL
+0x00000000	crc16_table	vmlinux	EXPORT_SYMBOL
+0x00000000	init_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_ts_and_drops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2__journal_start	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_request_active	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_timeout_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_link	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	isa_dma_bridge_buggy	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_real	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic_notifier_list	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	d_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pages_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_os_write_port	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_set_expiry	vmlinux	EXPORT_SYMBOL
+0x00000000	use_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_delayed_work_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	save_stack_trace_tsk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_read	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	add_page_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_copy_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	con_is_bound	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_page	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	__strncpy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	dmi_name_in_vendors	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_warning	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_set_medium_removal	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_can_wakeup	vmlinux	EXPORT_SYMBOL
+0x00000000	profile_pc	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_wipe	vmlinux	EXPORT_SYMBOL
+0x00000000	async_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioremap_wc	vmlinux	EXPORT_SYMBOL
+0x00000000	__ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	__nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	strnstr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_diag_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_pci_sff_prepare_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_pci_rootbridge_handle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_show_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_schedule_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmi_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	vfsmount_lock_lock_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_ts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_deb_timing_hotplug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_get	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_put	vmlinux	EXPORT_SYMBOL
+0x00000000	files_lglock_local_lock_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	map_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_dev_get_saddr	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_ntuple_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	__check_region	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_ip_default_ttl	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_load_saved_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flex_array_get	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_diag_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	vgacon_text_force	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_get_part	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_kernel_release	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_create	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_set_mmss	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_resource_n	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_off	vmlinux	EXPORT_SYMBOL
+0x00000000	sdev_evt_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lease_get_mtime	vmlinux	EXPORT_SYMBOL
+0x00000000	sb_set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_to_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_write	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_dev_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dump_write	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	__class_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_os_wait_events_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	filp_open	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_calg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm4_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_read_vpd	vmlinux	EXPORT_SYMBOL
+0x00000000	get_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	__free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	print_stack_trace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_child_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__register_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	thaw_process	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_init_state	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_assign_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtos8_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_spawn2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_user_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_notify_peers	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_add	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_split	vmlinux	EXPORT_SYMBOL
+0x00000000	input_grab_device	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_block_til_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	ioread8	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	x86_hyper_vmware	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_count_auth_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_broadcast	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_hp_params	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_full_page_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_file_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in_group_p	vmlinux	EXPORT_SYMBOL
+0x00000000	console_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	apic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_former_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_out_prepare_r	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_lost_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_security_override_from_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_wait_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_wait_after_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_obff	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_tsc_unstable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	e820_any_mapped	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_hashinfo_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_mt_report_pointer_emulation	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_ioremap_bar	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	end_buffer_read_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer_pinned	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_initialize_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_month_days	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_miter_next	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_timers_register_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_pull	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_add_new_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_unmap_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snmp_mib_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_get_vpd_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_initialize_objects	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_check_expire	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_boot_setup_check	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_uid	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_ino	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_bitmap	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_build_and_send_pkt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_gifconf	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_rng_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alg_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_inode_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_wide_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_out_r	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_do_dev_read_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_resource_to_address64	vmlinux	EXPORT_SYMBOL
+0x00000000	__srcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	secure_ipv4_port_ephemeral	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	kmalloc_caches	vmlinux	EXPORT_SYMBOL
+0x00000000	daemonize	vmlinux	EXPORT_SYMBOL
+0x00000000	icmpv6_send	vmlinux	EXPORT_SYMBOL
+0x00000000	put_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	put_page	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_reset_device	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_deref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_update	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_dummy_port_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_allocated_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_out_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_tx_hw_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	up	vmlinux	EXPORT_SYMBOL
+0x00000000	icmp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_hp_remove_module_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_get	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	__virt_addr_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_update	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_pid_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_udp_rmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_open	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_sock_fast	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite16_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite32_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	dmi_get_system_info	vmlinux	EXPORT_SYMBOL
+0x00000000	i8042_install_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	execute_in_process_context	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_register	vmlinux	EXPORT_SYMBOL
+0x00000000	fput	vmlinux	EXPORT_SYMBOL
+0x00000000	vector_used_by_percpu_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_os_map_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msrs_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_timer_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_frag_init	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_set_features	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_add_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	add_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_remove_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	strnicmp	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_to_page	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_release	vmlinux	EXPORT_SYMBOL
+0x00000000	add_wait_queue_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	d_add_ci	vmlinux	EXPORT_SYMBOL
+0x00000000	net_ipv6_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	net_ipv4_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_set_master	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_checksum_complete_head	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_map_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_init	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	workqueue_set_max_active	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_bmdma_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_raise_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	system_unbound_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_irq_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_first_zero_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_adjust_queue_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_find_first	vmlinux	EXPORT_SYMBOL
+0x00000000	x86_dma_fallback_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_unregister_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_add	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_split	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	class_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_remove_interface	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_pme_active	vmlinux	EXPORT_SYMBOL
+0x00000000	__locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_check_req	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sys_close	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pgrp	vmlinux	EXPORT_SYMBOL
+0x00000000	device_wakeup_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_pci_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	is_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_int	vmlinux	EXPORT_SYMBOL
+0x00000000	start_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_free_datagram_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_unregister_card_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	notify_change	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_up	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_short	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	edid_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_unregister_child_port	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_device	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_hp_change_slot_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_read_mapping_page_gfp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_cfg_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	__sk_mem_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_disable_all_gpes	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_tag_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_merge_bvec	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_lock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_want_write_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_fill_cmd_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bd_link_disk_holder	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uuid_le_gen	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_free_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_device_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	rwsem_down_write_failed	vmlinux	EXPORT_SYMBOL
+0x00000000	should_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_id_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_get_irq_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_array_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_get_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_write_space	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_notify_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_dup_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_remove_gpe_block	vmlinux	EXPORT_SYMBOL
+0x00000000	first_ec	vmlinux	EXPORT_SYMBOL
+0x00000000	zap_vma_ptes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_memory_uc	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_bysel_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_em_messages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_bmdma_port_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_complete_async_scans	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_add	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_del	vmlinux	EXPORT_SYMBOL
+0x00000000	init_user_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_skb_features	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_map_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	work_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sk_mem_reclaim	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_pin_device	vmlinux	EXPORT_SYMBOL
+0x00000000	d_prune_aliases	vmlinux	EXPORT_SYMBOL
+0x00000000	usleep_range	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__pagevec_release	vmlinux	EXPORT_SYMBOL
+0x00000000	warn_slowpath_fmt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_set_readrq	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup5	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family_with_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_block_user_cfg_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_scnlistprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_release_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enter_sleep_state	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_get_by_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	movable_zone	vmlinux	EXPORT_SYMBOL
+0x00000000	kbd_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_fill_super	vmlinux	EXPORT_SYMBOL
+0x00000000	have_submounts	vmlinux	EXPORT_SYMBOL
+0x00000000	printk_timed_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_vlan_hwaccel_receive_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_queue_err_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	__tasklet_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_load	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_add_page	vmlinux	EXPORT_SYMBOL
+0x00000000	init_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_thread	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateEnd	vmlinux	EXPORT_SYMBOL
+0x00000000	contig_page_data	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_evictor	vmlinux	EXPORT_SYMBOL
+0x00000000	console_blanked	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_update_all_gpes	vmlinux	EXPORT_SYMBOL
+0x00000000	__iowrite32_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_do_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev32	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_read	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_thaw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ec_transaction	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_scan_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_getxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	processors	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_set_features	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_readpages	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_disable_event	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_delayed_work_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pack_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_litter_super	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_proto_csum_replace4	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_prepare_flip_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_prepare_flip_string_flags	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	prandom32	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_check_limits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_hlist_next	vmlinux	EXPORT_SYMBOL
+0x00000000	account_page_dirtied	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_page_killable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_make_synack	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_check_gmii_support	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_ehi_clear_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_page	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_forward	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bit_waitqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_wait_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	drop_file_write_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_estimator_active	vmlinux	EXPORT_SYMBOL
+0x00000000	get_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	request_dma	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_inc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_orphan_count	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_data_xfer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kick_iocb	vmlinux	EXPORT_SYMBOL
+0x00000000	register_wide_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wakeup_source_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	get_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_mkdir_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	tag_pages_for_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_scsi_simulate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_kzalloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	swiotlb_dma_supported	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_attr_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bread	vmlinux	EXPORT_SYMBOL
+0x00000000	files_lglock_local_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy_toiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	in_aton	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_resolve_output	vmlinux	EXPORT_SYMBOL
+0x00000000	ec_read	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_init_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_unblock_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__mnt_is_readonly	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	__scm_send	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dma_map	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_init	vmlinux	EXPORT_SYMBOL
+0x00000000	try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_iff_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	add_input_randomness	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_acpi_bus_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_iter_advance	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_unblock_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	device_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_free_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_pci_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_dbg_layer	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_writeout_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_rcv_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_find_chipset_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_install_gpe_block	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_slave_configure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_qc_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_reprobe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_next_zero_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	timeval_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_kfree_skb_any	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_abort	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_drop_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_local_reserved_ports	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_type	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_bridges	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_srcu_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_cong_avoid_ai	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_max_syn_backlog	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_resume_and_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_create_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_delay_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_down	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_xfer_mask2mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	redraw_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	virtqueue_detach_unused_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_reenable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_mapping_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_rom	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_complement	vmlinux	EXPORT_SYMBOL
+0x00000000	memdup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_cooling_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_get_required_mask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	del_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_update_link_speed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_close	vmlinux	EXPORT_SYMBOL
+0x00000000	__mark_inode_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	strnlen	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	adjust_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	kmsg_dump_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ahci_reset_controller	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__destroy_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	print_context_stack_bp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_is_cwnd_limited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_add_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_mod_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_set_irq_type	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_irq_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_port_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__lru_cache_add	vmlinux	EXPORT_SYMBOL
+0x00000000	__printk_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	pgprot_writecombine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_hangman	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf8_to_utf32	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_prep_return	vmlinux	EXPORT_SYMBOL
+0x00000000	override_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	system_long_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmsg_dump_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_register_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	secure_tcpv6_sequence_number	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_device_hid	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_zeroout	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_get_create_access	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_level_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lzo1x_decompress_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timecompare_transform	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_append	vmlinux	EXPORT_SYMBOL
+0x00000000	pcim_iomap_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	random32	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_lock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	__irq_set_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_get_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_do_scan_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_handle_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blocking_notifier_chain_cond_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_state_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_init	vmlinux	EXPORT_SYMBOL
+0x00000000	panic_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mtrr_del	vmlinux	EXPORT_SYMBOL
+0x00000000	net_msg_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_timestamp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_configure_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	noop_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_add_host_with_dma	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_read_lock_bh_held	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sha_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_filter_release_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_index_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_allmulti	vmlinux	EXPORT_SYMBOL
+0x00000000	input_mt_report_finger_count	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_intersects	vmlinux	EXPORT_SYMBOL
+0x00000000	ksize	vmlinux	EXPORT_SYMBOL
+0x00000000	up_read_non_owner	vmlinux	EXPORT_SYMBOL
+0x00000000	kstat	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_stop_bus_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_set_name	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_truncate_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_synchronize_full	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_bmdma_irq_clear	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_gpe_device	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_remove_notify_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	set_device_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_unregister_guest_info_callbacks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_clear_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	panic_blink	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_port_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_dirty_page	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_try_set_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stop_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_remove_posix	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_port_service_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_slow_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_activate	vmlinux	EXPORT_SYMBOL
+0x00000000	__pneigh_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_set_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	bioset_create	vmlinux	EXPORT_SYMBOL
+0x00000000	x86_hyper	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_put_cacheinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ihold	vmlinux	EXPORT_SYMBOL
+0x00000000	names_cachep	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inode_pages2_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_qc_complete_multiple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_unmap_rom	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_path_raw	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_sad_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_del	vmlinux	EXPORT_SYMBOL
+0x00000000	input_event_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_device_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_put	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	single_open	vmlinux	EXPORT_SYMBOL
+0x00000000	page_follow_link_light	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock_killable_nested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_find_1stfragopt	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_install_interface	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_trans_will_send_data_barrier	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_set_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ahci_kick_engine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_get_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	hex2bin	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_listen_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf32_to_utf8	vmlinux	EXPORT_SYMBOL
+0x00000000	groups_free	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	cleanup_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_cmos_write	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_perform_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_pci_detect_ejectable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_request_region_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	vfsmount_lock_global_lock_online	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_platform_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_parms_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_single	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_clock_idle_sleep_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	interruptible_sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	amd_northbridges	vmlinux	EXPORT_SYMBOL
+0x00000000	__ip_route_output_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_syscore_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_invalidate_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	io_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_bmdma_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_part_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	pid_vnr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	math_state_restore	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_decode_session	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_lower_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_set	vmlinux	EXPORT_SYMBOL
+0x00000000	__clocksource_updatefreq_scale	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_set_err	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_netdev_mqs	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	__dst_destroy_metrics_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_purge	vmlinux	EXPORT_SYMBOL
+0x00000000	register_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_unmapped_area	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_lru	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_sched_lock_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_clear_features	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_release	vmlinux	EXPORT_SYMBOL
+0x00000000	d_find_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	yield	vmlinux	EXPORT_SYMBOL
+0x00000000	fsstack_copy_attr_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_processor_ffh_cstate_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp6_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_init_replay	vmlinux	EXPORT_SYMBOL
+0x00000000	udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_unregister_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_toiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_always	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_sb_list_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_invalidate	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_32	vmlinux	EXPORT_SYMBOL
+0x00000000	debug_show_all_locks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pid_task	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_page	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	monotonic_to_bootbased	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_memory_x	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv4_config	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_on	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_full	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_route_output	vmlinux	EXPORT_SYMBOL
+0x00000000	__rta_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	__dst_free	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_newsize_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_obff	vmlinux	EXPORT_SYMBOL
+0x00000000	no_pci_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	strncmp	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kfree_s	vmlinux	EXPORT_SYMBOL
+0x00000000	crc32_le	vmlinux	EXPORT_SYMBOL
+0x00000000	lcm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_map_and_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	empty_aops	vmlinux	EXPORT_SYMBOL
+0x00000000	__task_pid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_user_generic_string	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_link	vmlinux	EXPORT_SYMBOL
+0x00000000	input_event_to_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	rodata_test_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	boot_option_idle_override	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_generic_getfrag	vmlinux	EXPORT_SYMBOL
+0x00000000	call_netdevice_notifiers	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_quirk_pll_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mii_nway_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_enqueue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thaw_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_array_uc	vmlinux	EXPORT_SYMBOL
+0x00000000	current_task	vmlinux	EXPORT_SYMBOL
+0x00000000	print_context_stack	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_run_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_rx_csum_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_data_xfer32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_release_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_push_nfrag_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pio_need_iordy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_table	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_abort_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scm_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	d_move	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_del_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	touch_atime	vmlinux	EXPORT_SYMBOL
+0x00000000	device_set_wakeup_capable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mod_timer_pending	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_configure_link	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	strchr	vmlinux	EXPORT_SYMBOL
+0x00000000	strstr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_listen_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_parse_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_release_card_device	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_new_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_lookup_byaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_expand_head	vmlinux	EXPORT_SYMBOL
+0x00000000	take_over_console	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_bmdma_port_intr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_register_resndata	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msrs_free	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_write	vmlinux	EXPORT_SYMBOL
+0x00000000	bh_submit_read	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_change_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	__hw_addr_del_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_acpi_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	bdev_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wake_async	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_qc_prep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	getrawmonotonic	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_page_dirty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_prot_inuse_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_add_request_payload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	x86_bios_cpu_apicid	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	copy_strings_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	amd_nb_misc_ids	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_clear_gpe	vmlinux	EXPORT_SYMBOL
+0x00000000	vfsmount_lock_global_unlock_online	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_get_remaining	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_enter_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_add_rx_frag	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_root_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_kernel_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_create	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_post_internal_cmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_alloc_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_attach_data	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_get_create_access	vmlinux	EXPORT_SYMBOL
+0x00000000	no_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_unlock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_timed_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_irq_set_freq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rwsem_down_read_failed	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_array_uc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_array_wc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_array_wb	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_receive_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_pci_check_ejectable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_show_options	vmlinux	EXPORT_SYMBOL
+0x00000000	pagecache_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_paths	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_pause	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	capable	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_cmd_aborted	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_swevent_get_recursion_context	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	autoremove_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	give_up_console	vmlinux	EXPORT_SYMBOL
+0x00000000	getname	vmlinux	EXPORT_SYMBOL
+0x00000000	pcpu_base_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_attr_alg_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_calg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uhci_check_and_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_init_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_locked_super	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_class_create_file	vmlinux	EXPORT_SYMBOL
+0x00000000	in_lock_functions	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_rx_handler_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_datagram_const_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getpeername	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_driver_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serial8250_do_set_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_chmod_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_event	vmlinux	EXPORT_SYMBOL
+0x00000000	hex_to_bin	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_pin_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_user	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_clock_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	get_current_tty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_create_data	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_string	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockname	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_and	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_alloc_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_set_bond_master	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_err_bytes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	input_scancode_to_scalar	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_eh_freeze_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_lock_file	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	set_page_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	totalram_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_prereset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dump_seek	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_get_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	__register_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_class_close	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtoll_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_pci_problems	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	free_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_format_mac	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_send_sigurg	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_eh_thaw_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_is_active	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_crit	vmlinux	EXPORT_SYMBOL
+0x00000000	drop_super	vmlinux	EXPORT_SYMBOL
+0x00000000	printk	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_init_controller	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_std_hardreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	remove_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	try_to_release_page	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_add	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_get_ejd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_flocks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_kthread_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	native_io_delay	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_copy_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_subsys_pm_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_single_device	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtol_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_dir_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	_copy_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	setattr_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_fini	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_dispatch_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_start_head	vmlinux	EXPORT_SYMBOL
+0x00000000	__phys_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	device_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_pci_osc_control_set	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_notice	vmlinux	EXPORT_SYMBOL
+0x00000000	serial8250_suspend_port	vmlinux	EXPORT_SYMBOL
+0x00000000	fg_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_find	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_read	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_read	vmlinux	EXPORT_SYMBOL
+0x00000000	__devm_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_hash_nolisten	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy_fromiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_find_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_prep_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	local_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_base_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_unlock_updates	vmlinux	EXPORT_SYMBOL
+0x00000000	__class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idr_remove_all	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	disallow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_ip_nonlocal_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	pciserial_init_ports	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf8s_to_utf16s	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_fops_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ns_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_resize_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv4_specific	vmlinux	EXPORT_SYMBOL
+0x00000000	proto_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_release_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_instantiate_filp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_af_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_long	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_scr_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_vendor_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	match_strdup	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_seq_next	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_ro_fops	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_setup_gpe_for_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_find	vmlinux	EXPORT_SYMBOL
+0x00000000	inetdev_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	con_debug_enter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_fdatawrite	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_base_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	console_blank_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_lock_irqsave	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vm_unmap_aliases	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_finish_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	dmi_find_device	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_device_flags_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_tbl_unmap_single	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_fetch_request	vmlinux	EXPORT_SYMBOL
+0x00000000	free_inode_nonrcu	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	block_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_name	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_get_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	perf_event_release_kernel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	destroy_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idle_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twsk_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_ehi_push_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_SAK	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_load_and_free_saved_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_save_state	vmlinux	EXPORT_SYMBOL
+0x00000000	check_disk_change	vmlinux	EXPORT_SYMBOL
+0x00000000	default_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	writeback_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_put_link	vmlinux	EXPORT_SYMBOL
+0x00000000	release_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_id_c_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_state_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	vring_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_option	vmlinux	EXPORT_SYMBOL
+0x00000000	register_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_select_initial_window	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_format_exception	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	up_read	vmlinux	EXPORT_SYMBOL
+0x00000000	_cond_resched	vmlinux	EXPORT_SYMBOL
+0x00000000	empty_zero_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__pskb_pull_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alert	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_wait_until_sent	vmlinux	EXPORT_SYMBOL
+0x00000000	bioset_free	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstat	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_lstat	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_spin_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	orderly_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_mutex_lock_nest_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usermodehelper_is_disabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__netif_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_get_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioread16	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_fh_to_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_fillattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_alloc_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate_unique	vmlinux	EXPORT_SYMBOL
+0x00000000	request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma32_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_scr_valid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_forget	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	input_get_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_find_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_task_ioprio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_arg_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	snmp_fold_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_disable_link_state	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_start	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_fdget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thermal_zone_device_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_alloc_pinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_lock_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_uncopy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	make_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__d_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	__mmdrop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_qc_fill_rtf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strtobool	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_force_commit_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_release_private	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_remove_one	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_console_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_error	vmlinux	EXPORT_SYMBOL
+0x00000000	writeback_inodes_sb_nr	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_removexattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__mutex_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_set_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pcix_get_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_check_used_features	vmlinux	EXPORT_SYMBOL
+0x00000000	icmpv6_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	serial8250_register_port	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_write	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readv	vmlinux	EXPORT_SYMBOL
+0x00000000	search_binary_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	amd_get_nb_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_link_get_net	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_work_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sched_clock_idle_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tsc_khz	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_8	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_8	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	put_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_pair_release	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_start	vmlinux	EXPORT_SYMBOL
+0x00000000	register_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	loops_per_jiffy	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_validate_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_is_system_supplied	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_name	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_copy_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_delayed_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_attr_sw_activity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mangle_path	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_domain_bus_and_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	anon_inode_getfd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_remove_table_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_is_held	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	strnlen_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_ignore_sss	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_bmdma_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mnt_pin	vmlinux	EXPORT_SYMBOL
+0x00000000	set_create_files_as	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_set_battery_charged	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	install_exec_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_setscheduler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_putpeer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_sk_rebuild_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_init_wakeup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mb_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	system_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	avenrun	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_page_accessed	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_count_enc_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_report_bus_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	__ht_create_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_sk_dst_lookup_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cdev_add	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_input	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_add	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_del	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_add	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_del	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_update_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_attr_em_message_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_install_method	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_update_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_get_by_path	vmlinux	EXPORT_SYMBOL
+0x00000000	open_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_find_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_owner	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_xfer_mode2shift	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_activate_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_next_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_forget	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	system_freezable_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_delayed_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aout_dump_debugregs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_open_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__set_page_dirty_nobuffers	vmlinux	EXPORT_SYMBOL
+0x00000000	oops_begin	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_create_node	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_promiscuity	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_bios_ptable	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_write_vpd	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_connected_output	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_flush_pending_frames	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_kernel_create	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_parse_user	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsg_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	mmput	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_task	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	build_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_twsk_hashdance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_table_init_no_netlink	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_copy_app	vmlinux	EXPORT_SYMBOL
+0x00000000	input_allocate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_printk	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_pcie_reset_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_parselist	vmlinux	EXPORT_SYMBOL
+0x00000000	__insert_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	getboottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	revert_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_overflowgid	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_unmap_sg_attrs	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_mem_start	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_checksum_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_device_do_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	write_inode_now	vmlinux	EXPORT_SYMBOL
+0x00000000	dpm_suspend_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_store_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_hw_change	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_path	vmlinux	EXPORT_SYMBOL
+0x00000000	msleep_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_add	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_valid_name	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_err	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_init_table	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_open	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_freeze	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_cont_expand_simple	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_rq_timed_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc32_be	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_register_ioapic	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_output_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_find_text	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_clear_master	vmlinux	EXPORT_SYMBOL
+0x00000000	current_fs_time	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_lookup_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_test_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_buffer_dirty_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_thaw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_execute_req	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_run_osc	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	oops_in_progress	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_insert_flip_string_fixed_flag	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_throttle	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_check_change	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_backing_dev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_init	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_disable_lro	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_classdev_to_container	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kblockd_schedule_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_dump_start	vmlinux	EXPORT_SYMBOL
+0x00000000	call_netevent_notifiers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_scsi_port_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_base	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aio_put_req	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_ext_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_device_do_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serial8250_unregister_port	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	vfsmount_lock_local_lock_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	replace_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_policy_check	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_sff_init_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_info	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_evaluate_object_typed	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_sync_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	used_vectors	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_mc_rejoin_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_update_features	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_postreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_handle_response	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_set_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	int_sqrt	vmlinux	EXPORT_SYMBOL
+0x00000000	local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_dirty_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_init_node	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_parselist_user	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_update_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_request	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_read_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_try_to_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	input_unregister_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_replace	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_sched	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmi_get_date	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_andnot	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_get	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_int	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_drop_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_cable_80wire	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_short	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	strim	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_write	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_update_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfree	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_page_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_acpi_cbl_80wire	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_get_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_sync_sg_for_device	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rq_merge_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_do_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	get_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioread16be	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_dump_rq_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	trace_hardirqs_off_caller	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_unregister_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	consume_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_stay_awake	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_match_id	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_run_wake	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_get_tso	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_aspm_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	root_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vring_transport_features	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	files_lglock_global_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_ms_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_setattr	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	lockdep_off	vmlinux	EXPORT_SYMBOL
+0x00000000	cred_to_ucred	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_tx_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdget_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_init_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_get_peer	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_rcv_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_tx_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_to_sgvec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_set_gpe_wake_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	sscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	__breadahead	vmlinux	EXPORT_SYMBOL
+0x00000000	pfifo_fast_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_lid_open	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_name_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	___ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_kmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sched_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_twcal_tick	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_create_lite	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_qc_defer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	swiotlb_dma_mapping_error	vmlinux	EXPORT_SYMBOL
+0x00000000	d_obtain_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	ip4_datagram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_timewait_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_sff_init_one	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_start_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	iommu_area_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	global_cursor_default	vmlinux	EXPORT_SYMBOL
+0x00000000	native_rdmsr_safe_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	native_wrmsr_safe_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_page_dirty_for_io	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_init_notifier_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_min_cwnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_schedule_flip	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_follow_link	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_devnum	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_rename_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ms_hyperv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	write_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	input_free_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__hw_addr_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_out	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_free_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtos16_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_or	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_broadcast_filtered	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iowrite8	vmlinux	EXPORT_SYMBOL
+0x00000000	strlen	vmlinux	EXPORT_SYMBOL
+0x00000000	strspn	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_allocate_command	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_from_user_r	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_read_bit_register	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_cpu_data	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_init	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_changed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_irq_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_int	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_set	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_setup_and_register	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_cow_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_fixup_cardbus	vmlinux	EXPORT_SYMBOL
+0x00000000	release_perfctr_nmi	vmlinux	EXPORT_SYMBOL
+0x00000000	get_options	vmlinux	EXPORT_SYMBOL
+0x00000000	setup_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_unregister_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_pci_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bh_uptodate_or_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_in_r	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_read_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_remove_behind_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	string_get_size	vmlinux	EXPORT_SYMBOL
+0x00000000	register_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	fl6_sock_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_write_config_word	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_simple_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_synchronize_cookie_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	power_supply_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_list_start	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aead_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_state_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_enable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_write_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	completion_done	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_printf	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_setfns	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtol	vmlinux	EXPORT_SYMBOL
+0x00000000	rwsem_downgrade_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup5_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	local_apic_timer_c2_ok	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gen_kill_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_install_gpe_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_power_state	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_alignment_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_sense_info_fld	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_set_current_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_size_bridges	vmlinux	EXPORT_SYMBOL
+0x00000000	__bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_cookie_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cap_netlink_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	nr_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_spin_trylock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_kunmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_block_when_processing_errors	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_set_triggers	vmlinux	EXPORT_SYMBOL
+0x00000000	f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_dst_hoplimit	vmlinux	EXPORT_SYMBOL
+0x00000000	arp_invalidate	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_leave_sleep_state	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_map_sg_attrs	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	submit_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_clone_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_mkclean	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_seconds	vmlinux	EXPORT_SYMBOL
+0x00000000	kvasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_insert_color	vmlinux	EXPORT_SYMBOL
+0x00000000	amd_cache_northbridges	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_init_state	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_dma_pause	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_tf_to_fis	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__module_text_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_start_range_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_possible_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_buffer_request_room	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	unuse_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_pages_nodemask	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_abort_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_extend	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_err	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_execute_rq_nowait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_choose_state	vmlinux	EXPORT_SYMBOL
+0x00000000	delete_from_page_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_user	vmlinux	EXPORT_SYMBOL
+0x00000000	__alloc_percpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_eh_qc_retry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_get_serial	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_parms_release	vmlinux	EXPORT_SYMBOL
+0x00000000	device_release_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	swiotlb_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_lookup_devt	vmlinux	EXPORT_SYMBOL
+0x00000000	get_next_ino	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_register_interface	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setlease	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_queue_pio_task	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	set_current_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_input_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	update_region	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	sprint_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_fp_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_vhangup	vmlinux	EXPORT_SYMBOL
+0x00000000	kref_sub	vmlinux	EXPORT_SYMBOL
+0x00000000	shrink_dcache_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twdr_twkill_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_net	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_for_each_drv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_scheduler_active	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	__ndelay	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_find_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	in_egroup_p	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_append_datato_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	release_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite16	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite32	vmlinux	EXPORT_SYMBOL
+0x00000000	vzalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_msecs	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_usecs	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_child_process	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_binprm	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_port_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_last	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	can_do_mlock	vmlinux	EXPORT_SYMBOL
+0x00000000	__print_symbol	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_mc_map	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_walk_namespace	vmlinux	EXPORT_SYMBOL
+0x00000000	sprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_listxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	net_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_power_names	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_set_ltr	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inode_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_dirty_data	vmlinux	EXPORT_SYMBOL
+0x00000000	find_vma	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_exception	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_stream_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	screen_info	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_stop_engine	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_eh_qc_complete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_release_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_tvec_bases	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_class_remove_file	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_put	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_physical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	dio_end_io	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timecounter_cyc2time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtc_tm_to_ktime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ht_create_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_ack_err	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_check_addressable	vmlinux	EXPORT_SYMBOL
+0x00000000	perf_event_read_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_refcnt_read	vmlinux	EXPORT_SYMBOL
+0x00000000	input_mt_init_slots	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_close_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_rcv_established	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_queue_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_getpeer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ahci_set_em_messages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_prep_fn	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_ec_remove_query_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_strtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoll	vmlinux	EXPORT_SYMBOL
+0x00000000	net_ns_type_operations	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_trace	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_vmalloc_range	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	enable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	memchr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_release	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_destroy_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_current_gpe_count	vmlinux	EXPORT_SYMBOL
+0x00000000	submit_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_page_buffers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	handle_nested_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fl6_update_dst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_host_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dev_info_list_del_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_mtup_init	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoul_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtou8_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_streq	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_tbl_map_single	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unmap_kernel_range_noflush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_skip_exthdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_options_compile	vmlinux	EXPORT_SYMBOL
+0x00000000	aio_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	rt6_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	congestion_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_dma_drain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_write_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	__atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hex_dump_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	file_ra_state_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_larval_kill	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_register_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_get_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_get_ufo	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_rtc_timer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flow_cache_genid	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_new_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	input_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_update_power	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_set_master	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_mod_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	freeze_super	vmlinux	EXPORT_SYMBOL
+0x00000000	__devm_request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_finish_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_cons	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_common_sdev_attrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strncat	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcat	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_augment_erase_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_discard_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_should_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_notice	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_device_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_mapping_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_change_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	datagram_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	virtqueue_add_buf_gfp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_end_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_hlist_start_head_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_uc_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_check_available_features	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_old_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_port_start32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timekeeping_inject_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	mii_link_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	wakeup_source_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	stop_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_type	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	strcspn	vmlinux	EXPORT_SYMBOL
+0x00000000	native_load_gs_index	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_unbind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_cable_ignore	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_scan_bridge	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_extend	vmlinux	EXPORT_SYMBOL
+0x00000000	do_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_aio_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_bitmap_list	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_timing_compute	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioremap_page_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	arp_find	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_pme_capable	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	finish_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_after	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_print_result	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_weight	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	clockevent_delta2ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generate_random_uuid	vmlinux	EXPORT_SYMBOL
+0x00000000	default_red	vmlinux	EXPORT_SYMBOL
+0x00000000	get_net_ns_by_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_write_bit_register	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_complete_power_transition	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnetlink_put_metrics	vmlinux	EXPORT_SYMBOL
+0x00000000	int_to_scsilun	vmlinux	EXPORT_SYMBOL
+0x00000000	may_umount	vmlinux	EXPORT_SYMBOL
+0x00000000	pcix_get_max_mmrbc	vmlinux	EXPORT_SYMBOL
+0x00000000	block_read_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	console_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_sort_breadthfirst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sync_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_ack_err	vmlinux	EXPORT_SYMBOL
+0x00000000	emergency_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	local_bh_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_death_row	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_rescan	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtouint_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_get_nr_vecs	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_byid	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_prepare_to_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	load_nls_default	vmlinux	EXPORT_SYMBOL
+0x00000000	nonseekable_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_get_local_port_range	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_escape	vmlinux	EXPORT_SYMBOL
+0x00000000	__seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc_root	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_alloc_descs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_store_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sas_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_cache_sync_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_create_bundle	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_dev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_free	vmlinux	EXPORT_SYMBOL
+0x00000000	is_hpet_enabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_hlist_start_head	vmlinux	EXPORT_SYMBOL
+0x00000000	clocksource_change_rating	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_assign_resources	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_hp_create_module_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_netdevice	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_reset_em	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_finish_command	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_get	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_put	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pid_info_as_uid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_get_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_tf_load	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_begin_ordered_truncate	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_trans_will_send_data_barrier	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_cleanup_aer_uncorrect_error_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	half_md4_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_prev_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_add_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	thaw_super	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_vlan_hwaccel_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_rand_reach_time	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_forward_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_common_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	n_tty_inherit_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflate_blob	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_find	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mknod	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_dequeue	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_gbl_FADT	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq_nosync	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_freeinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	softirq_work_list	vmlinux	EXPORT_SYMBOL
+0x00000000	__pm_relax	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_uevent_var	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_features_change	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_online_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	set_memory_nx	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dostring	vmlinux	EXPORT_SYMBOL
+0x00000000	usecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_write_config_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_schedule_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	files_lglock_lock_init	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_hash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_emerg	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_acpi_bus_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_force_commit_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	request_any_context_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udplite_table	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_segment_size	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_tail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_kfree_skb_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	dmi_first_match	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_shost_attrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_unblank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_find_ext_capability	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_file_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	log_wait_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enter_sleep_state_s4bios	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_claim_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	get_zeroed_page	vmlinux	EXPORT_SYMBOL
+0x00000000	input_close_device	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_create_link	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_error_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_insert_flip_string_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	address_space_init_once	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dev_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	remove_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_opt_accepted	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_spd_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_walk_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_is_partially_uptodate	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_etherdev_mqs	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_resume_port	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_handle_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_relax	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_errno	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_register_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_std_bios_param	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pagecache_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_unregister_client	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtoint_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_inner_extract_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_kernel_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	timecompare_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	complete_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file_from_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	files_lglock_lock_dep_map	vmlinux	EXPORT_SYMBOL
+0x00000000	get_monotonic_boottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_read_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unregister_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_rx_ni	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_begin_command	vmlinux	EXPORT_SYMBOL
+0x00000000	device_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_open	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_user_iov	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_putc	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_puts	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_mask_rtc_irq_bit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_dev_disable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_update_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	part_round_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_genocide	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_put_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	__alloc_workqueue_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmi_walk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_dispatch_add_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	end_buffer_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	d_drop	vmlinux	EXPORT_SYMBOL
+0x00000000	d_rehash	vmlinux	EXPORT_SYMBOL
+0x00000000	file_open_root	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_kthread_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_class	vmlinux	EXPORT_SYMBOL
+0x00000000	__bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_write	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_nx	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_rx	vmlinux	EXPORT_SYMBOL
+0x00000000	swiotlb_sync_sg_for_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_worker_fn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_stateonly_find	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_type	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_raw_read_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_acquire	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_bonding_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_reset_txq	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_check_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_resources_are_enforced	vmlinux	EXPORT_SYMBOL
+0x00000000	set_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_dst_set_noref	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_clear_event	vmlinux	EXPORT_SYMBOL
+0x00000000	debug_locks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_set_chip_data	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_xmit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_eh_analyze_ncq_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	find_vpid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strlen_user	vmlinux	EXPORT_SYMBOL
+0x00000000	unmap_mapping_range	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_select_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_getbyhwaddr_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_enable_device	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_present_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_close	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_get_page_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_irq_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dma_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_set_legacy_decoding	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_put_port	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_remove_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_killable_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_amd_quirk_pll_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_acquire_global_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_subset	vmlinux	EXPORT_SYMBOL
+0x00000000	set_normalized_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_type_trans	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_get	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_insert_mixed	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_nonblockable_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_lid_notifier_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	down_write_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	__hw_addr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	net_disable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_scsi_slave_config	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_pci_device_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_partsize	vmlinux	EXPORT_SYMBOL
+0x00000000	ioremap_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_port_pbar_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	groups_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_release_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	down	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_put	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_put	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	add_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_add_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_ethtool_get_settings	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_sdev_attrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strrchr	vmlinux	EXPORT_SYMBOL
+0x00000000	strnchr	vmlinux	EXPORT_SYMBOL
+0x00000000	balance_dirty_pages_ratelimited_nr	vmlinux	EXPORT_SYMBOL
+0x00000000	vsnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_replace_node	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_get_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_put_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_mod_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_clear_err	vmlinux	EXPORT_SYMBOL
+0x00000000	mount_pseudo	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_tcp_reordering	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_pci_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_preload	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kernel_param_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_register_irq_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_tstamp_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_set_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_copy_le	vmlinux	EXPORT_SYMBOL
+0x00000000	memscan	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_buffer_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	get_super	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_scheduled_work	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_check_ready	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	ll_rw_block	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_set_alarm_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_sendbyte	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_unpack_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	resume_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_detach_data	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrtos8	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_get_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_unregister_ioapic	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_get_sense	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_intx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kref_init	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_spawn_tfm2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_mac_address	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kd_mksound	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_os_unmap_memory	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_segment_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_cookie_generator	vmlinux	EXPORT_SYMBOL
+0x00000000	net_namespace_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_register	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_close	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_link_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_set_wakeup_enable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_find_bus	vmlinux	EXPORT_SYMBOL
+0x00000000	avail_to_resrv_perfctr_nmi_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_set_real_num_tx_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_group	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_add_list	vmlinux	EXPORT_SYMBOL
+0x00000000	end_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_writev	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_free_descs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_established	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_alert	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_rehash	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_stay_awake	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflate_workspacesize	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_client_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_pci_sff_activate_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_scsi_queuecmd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_timing_cycle2mode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_range_tag_if_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_userhz_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	console_start	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_simple_retransmit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_inode_getfile	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_dir_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_do_softreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	__find_get_block	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_open	vmlinux	EXPORT_SYMBOL
+0x00000000	put_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_first	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_dummy_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_disable_gpe	vmlinux	EXPORT_SYMBOL
+0x00000000	zero_fill_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	files_lglock_local_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_root_buses	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_syn_ack_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_ready_devs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_buffered_write	vmlinux	EXPORT_SYMBOL
+0x00000000	__hw_addr_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_cooling_device_register	vmlinux	EXPORT_SYMBOL
+0x00000000	input_open_device	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_policy_len	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	fsync_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_dst_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_for_each_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vzalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	timespec_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_uc	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enable_gpe	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_rtc_dropped_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_ctype	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_set_size	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	power_supply_get_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_len_r	vmlinux	EXPORT_SYMBOL
+0x00000000	task_xstate_cachep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_sk_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	input_inject_event	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_bus_read_config_dword	vmlinux	EXPORT_SYMBOL
+0x00000000	memparse	vmlinux	EXPORT_SYMBOL
+0x00000000	block_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	do_gettimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	do_settimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_increment_features	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_match_port	vmlinux	EXPORT_SYMBOL
+0x00000000	flow_cache_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_port_service_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_selected_regions	vmlinux	EXPORT_SYMBOL
+0x00000000	__splice_from_pipe	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_id_xfermask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_write_room	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_add_file_to_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_ops_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_trans_start	vmlinux	EXPORT_SYMBOL
+0x00000000	default_blu	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_power_manageable	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_register_region	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_put	vmlinux	EXPORT_SYMBOL
+0x00000000	task_tgid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	input_alloc_absinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_target_device	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_force_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	each_symbol_section	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_needs_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	grab_cache_page_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_sync_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_print_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_internal_device_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fs_overflowuid	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_process	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_dequeue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_erase	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_queue_delayed_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atapi_cmd_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arch_debugfs_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_stream_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_get_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_complete_request	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_tested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_drain_fifo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idr_get_next	vmlinux	EXPORT_SYMBOL
+0x00000000	ns_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_ipv6_magic	vmlinux	EXPORT_SYMBOL
+0x00000000	__delay	vmlinux	EXPORT_SYMBOL
+0x00000000	skip_spaces	vmlinux	EXPORT_SYMBOL
+0x00000000	add_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_power_off	vmlinux	EXPORT_SYMBOL
+0x00000000	__neigh_for_each_release	vmlinux	EXPORT_SYMBOL
+0x00000000	dpm_suspend_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_initialize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	bdget	vmlinux	EXPORT_SYMBOL
+0x00000000	bdput	vmlinux	EXPORT_SYMBOL
+0x00000000	fsstack_copy_inode_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_pci_bmdma_prepare_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtos16	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfsmount_lock_local_unlock_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_link_scr_lpm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strncpy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_init	vmlinux	EXPORT_SYMBOL
+0x00000000	all_vm_events	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_rate_est	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_partial_csum_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_empty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	init_special_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_chk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_to_file	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flush_kthread_worker	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	brioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_abs_params	vmlinux	EXPORT_SYMBOL
+0x00000000	device_schedule_callback_owner	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vm_insert_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	out_of_line_wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	register_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_is_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	workqueue_congested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_route_forward	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_replace_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_target_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_many	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_abort_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_logical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	reserve_evntsel_nmi	vmlinux	EXPORT_SYMBOL
+0x00000000	arp_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_enable_event	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_os_execute	vmlinux	EXPORT_SYMBOL
+0x00000000	__hw_addr_add_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sysrq_key	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_set	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_get	vmlinux	EXPORT_SYMBOL
+0x00000000	find_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_node_attached	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_sock_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_free_command	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_add_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sff_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_bus_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	set_security_override	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_stack	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_cow_metrics_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_read_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_dev_pair	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	swiotlb_map_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mount_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_del	vmlinux	EXPORT_SYMBOL
+0x00000000	register_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_last_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_initwait	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_console	vmlinux	EXPORT_SYMBOL
+0x00000000	register_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_gsi_to_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_reqsk_queue_prune	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_state_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sort	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_work_run	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clockevents_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kern_path	vmlinux	EXPORT_SYMBOL
+0x00000000	syscore_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	shrink_dcache_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_int	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_hp_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_issue_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	default_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_drop_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_inode_number	vmlinux	EXPORT_SYMBOL
+0x00000000	param_ops_short	vmlinux	EXPORT_SYMBOL
+0x00000000	x86_hyper_ms_hyperv	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_input_common	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_to_user_r	vmlinux	EXPORT_SYMBOL
+0x00000000	softnet_data	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_cpuid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	files_lglock_global_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sys_tz	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_tx_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_id	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_free_parts	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_unregister_type	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_request_regions_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_log_wait_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init_sleeper	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_compat_output	vmlinux	EXPORT_SYMBOL
+0x00000000	user_path_at	vmlinux	EXPORT_SYMBOL
+0x00000000	console_set_on_cmdline	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_link_hardreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_install_address_space_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_get_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_driver_string	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_get_readrq	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_status	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_os_get_iomem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_fileget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	max_mapnr	vmlinux	EXPORT_SYMBOL
+0x00000000	pcie_aspm_support_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_fget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dget_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_create	vmlinux	EXPORT_SYMBOL
+0x00000000	iunique	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dgram_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	input_release_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_dev_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	get_gendisk	vmlinux	EXPORT_SYMBOL
+0x00000000	get_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	files_lglock_global_unlock_online	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_doulongvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	sdev_evt_send_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_renumber_slot	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_attr_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wake_up_locked_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_pci_bmdma_clear_simplex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	local_bh_enable_ip	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv_encap	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_hp_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrndup	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_set_chip	vmlinux	EXPORT_SYMBOL
+0x00000000	console_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_pmp_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sata_deb_timing_normal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_build_sense_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_run	vmlinux	EXPORT_SYMBOL
+0x00000000	xz_dec_end	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	argv_free	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_clear_err	vmlinux	EXPORT_SYMBOL
+0x00000000	files_lglock_global_lock_online	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_family	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	swiotlb_free_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	register_net_sysctl_rotable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_rx_handler_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_release_jbd_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reset_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	might_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	__tasklet_hi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	arp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	sata_sff_hardreset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflateReset	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_onto	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_del	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_out_peek	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_enqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	rwsem_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	vga_get	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_fh_to_dentry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	try_to_del_timer_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_init_termios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_enable_device_io	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_bounce	vmlinux	EXPORT_SYMBOL
+0x00000000	__clocksource_register_scale	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_sas_port_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_dev_present	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_get	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_dev_put	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_instance2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jbd2_journal_revoke	vmlinux	EXPORT_SYMBOL
+0x00000000	read_dev_sector	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_destroy_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strcat	vmlinux	EXPORT_SYMBOL
+0x00000000	mb_cache_entry_release	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_unlock_irqrestore	vmlinux	EXPORT_SYMBOL
+0x00000000	down_write_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_listxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_pages_contig	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_create_dflt	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_add_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	kmemdup	vmlinux	EXPORT_SYMBOL
+0x00000000	__blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__strnlen_user	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock_interruptible_nested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_register_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_gro_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysrq_key	vmlinux	EXPORT_SYMBOL
+0x00000000	timerqueue_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_filesystem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_table_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	thermal_zone_bind_cooling_device	vmlinux	EXPORT_SYMBOL
+0x00000000	do_munmap	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_fixup_device	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_find_acq_byseq	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_af_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i8042_check_port_owner	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	save_stack_trace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_allocate_region	vmlinux	EXPORT_SYMBOL
+0x00000000	memory_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_get_acqseq	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_iterate_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_abort_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_sense_desc_find	vmlinux	EXPORT_SYMBOL
+0x00000000	default_grn	vmlinux	EXPORT_SYMBOL
+0x00000000	ioread16_rep	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_restart	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	pnpacpi_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_disk_node	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	dequeue_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__rtnl_af_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_gro_reset_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_atomic_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_get_hp_hw_control_from_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_tf_from_fis	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ec_burst_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_tfm_in_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fget_raw	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_pre_map_gar	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_tcp_wmem	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_net_namespace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_rescan_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_rq_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_flush_queueable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_twsk_destructor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_detach_fds	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_ktime_to_tm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	irq_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_clock_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_get_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_ealg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_pm_wait_for_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_remove_fixed_event_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_ft_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_fl_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_it_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_il_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	ahci_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_wait_after_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_set_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	misc_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_match_device_ids	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_one_len	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_x	vmlinux	EXPORT_SYMBOL
+0x00000000	hpet_rtc_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_has_amd_erratum	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	register_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_dec_and_mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	journal_wipe	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_mwi	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_private_data_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_set_default_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_allocated_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioread32	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_basic	vmlinux	EXPORT_SYMBOL
+0x00000000	create_mnt_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_map_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawrite_range	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_cmsg_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_sem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_sector_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_bh_lock_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inverse_translate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_os_read_port	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_unblock_user_cfg_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hpet_set_rtc_irq_bit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_idle_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_sff_exec_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	interruptible_sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	IO_APIC_get_PCI_irq_vector	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_extract_package	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateInit2	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_free	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_alloc_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lro_flush_pkt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	vprintk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_syncookies	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_post_unmap_gar	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vsprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_splice_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_find_class_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	grab_cache_page_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_fpu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_disable_link_state_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	utf16s_to_utf8s	vmlinux	EXPORT_SYMBOL
+0x00000000	down_read_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_task_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cond_resched_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pnp_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_sync_kiocb	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_set_max_ratio	vmlinux	EXPORT_SYMBOL
+0x00000000	redirty_page_for_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_emerg	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_kill_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_port_desc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_set_firmware_waking_vector	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_register_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	__timecompare_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_dma_in_prepare	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	byte_rev_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	set_bh_page	vmlinux	EXPORT_SYMBOL
+0x00000000	strcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_destroy_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_pair_get_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_pair_get_pty	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_sysdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_register_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	node_states	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_delete_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_cable_40wire	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_bus_set_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	i8042_command	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_cable_unknown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_size	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_extd_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_generate_netlink_event	vmlinux	EXPORT_SYMBOL
+0x00000000	__pci_reset_function	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_get_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_register	vmlinux	EXPORT_SYMBOL
+0x00000000	pcibios_scan_specific_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ping_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_generic_freeze	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_vargs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_disable_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_xor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_bit_bitmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i8042_unlock_chip	vmlinux	EXPORT_SYMBOL
+0x00000000	device_find_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_read_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	kallsyms_lookup_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_APIC_eilvt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_inodes_sb_if_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_pagecache	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_generate_proc_event	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	_local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	try_wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_unmerge_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_active_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mtrr_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_peer_xrlim_allow	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_interrupt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_user_hw_breakpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lockdep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_dbg_level	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_purge_cached_objects	vmlinux	EXPORT_SYMBOL
+0x00000000	commit_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_register_client	vmlinux	EXPORT_SYMBOL
+0x00000000	match_hex	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__skb_get_rxhash	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_realloc_headroom	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_attr_em_message	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serial8250_set_isa_configurator	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_map	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_pipe_buf_get	vmlinux	EXPORT_SYMBOL
+0x00000000	uhci_reset_hc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_close_end	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_dirty_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_personality	vmlinux	EXPORT_SYMBOL
+0x00000000	register_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	page_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	account_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	virtqueue_kick	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_verify_command	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrdup	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_write_lock_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_port_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ata_host_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_atomic_dec_and_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_register_km	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_dec_group	vmlinux	EXPORT_SYMBOL
+0x00000000	kasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_getxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_init_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_set_termios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acpi_unload_table_id	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_get_sleep_type_data	vmlinux	EXPORT_SYMBOL
+0x00000000	_raw_spin_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	class_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pci_get_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite16be	vmlinux	EXPORT_SYMBOL
+0x00000000	iowrite32be	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_query	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_release	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_start_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	jbd2_journal_force_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_create	vmlinux	EXPORT_SYMBOL
+0x00000000	fb_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kstrtoint	vmlinux	EXPORT_SYMBOL
+0x00000000	log_start_commit	vmlinux	EXPORT_SYMBOL
+0x00000000	__round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	check_tsc_unstable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twsk_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__serio_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_put_char	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	__rt_mutex_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_lost_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_next	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_user_generic_unrolled	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_dma_out_finish_r	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_array_wc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_pages_array_wb	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_suspend_port	vmlinux	EXPORT_SYMBOL
+0x00000000	__blkdev_driver_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_alloc_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_bmdma_qc_issue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	flex_array_free	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_phys_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_find_tlv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_changeaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_recycle_check	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_inode_pages2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_calculate_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	pnp_possible_config	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_prepare_input	vmlinux	EXPORT_SYMBOL
+0x00000000	vfsmount_lock_global_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	vring_new_virtqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vm_event_states	vmlinux	EXPORT_SYMBOL
+0x00000000	__release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	complete_all	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_set_vt_switch	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_free_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_set_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_clear_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	hex_asc	vmlinux	EXPORT_SYMBOL
+0x00000000	ata_ratelimit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_get_pgrp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strncasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	default_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_read_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_fragment	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_prep_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	pci_set_cacheline_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_octal	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_virtio_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_freewait	vmlinux	EXPORT_SYMBOL
+0x00000000	si_meminfo	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_create_on_node	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_cmos_read	vmlinux	EXPORT_SYMBOL
+0x00000000	current_umask	vmlinux	EXPORT_SYMBOL
+0x00000000	get_fs_type	vmlinux	EXPORT_SYMBOL
+0x00000000	ref_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_driver_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_get_private_data	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_prot_inuse_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	journal_check_used_features	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_copy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kzfree	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	acpi_bus_generate_proc_event4	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_removexattr	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_super	vmlinux	EXPORT_SYMBOL
+0x00000000	vmap	vmlinux	EXPORT_SYMBOL
diff -Nurp linux/net/socket.c linux-3.0/net/socket.c
--- linux/net/socket.c	2014-02-19 16:27:35.957878275 -0500
+++ linux-3.0/net/socket.c	2014-02-19 21:06:17.754176413 -0500
@@ -560,7 +560,7 @@ static inline int __sock_sendmsg_nosec(s
 static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 				 struct msghdr *msg, size_t size)
 {
-	int err = security_socket_sendmsg(sock, msg, size);
+  int err = security_socket_sendmsg(sock, msg, size);
 
 	return err ?: __sock_sendmsg_nosec(iocb, sock, msg, size);
 }
@@ -570,10 +570,14 @@ int sock_sendmsg(struct socket *sock, st
 	struct kiocb iocb;
 	struct sock_iocb siocb;
 	int ret;
+	int i;
 
 	init_sync_kiocb(&iocb, NULL);
 	iocb.private = &siocb;
 	ret = __sock_sendmsg(&iocb, sock, msg, size);
+
+	//for (i = 0; i < size;i++)
+	//printk("%x", (int)(((char*)msg)[i]));
 	if (-EIOCBQUEUED == ret)
 		ret = wait_on_sync_kiocb(&iocb);
 	return ret;
diff -Nurp linux/net/socket.c~ linux-3.0/net/socket.c~
--- linux/net/socket.c~	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/net/socket.c~	2014-02-19 21:06:17.773176842 -0500
@@ -0,0 +1,3379 @@
+/*
+ * NET		An implementation of the SOCKET network access protocol.
+ *
+ * Version:	@(#)socket.c	1.1.93	18/02/95
+ *
+ * Authors:	Orest Zborowski, <obz@Kodak.COM>
+ *		Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ * Fixes:
+ *		Anonymous	:	NOTSOCK/BADF cleanup. Error fix in
+ *					shutdown()
+ *		Alan Cox	:	verify_area() fixes
+ *		Alan Cox	:	Removed DDI
+ *		Jonathan Kamens	:	SOCK_DGRAM reconnect bug
+ *		Alan Cox	:	Moved a load of checks to the very
+ *					top level.
+ *		Alan Cox	:	Move address structures to/from user
+ *					mode above the protocol layers.
+ *		Rob Janssen	:	Allow 0 length sends.
+ *		Alan Cox	:	Asynchronous I/O support (cribbed from the
+ *					tty drivers).
+ *		Niibe Yutaka	:	Asynchronous I/O for writes (4.4BSD style)
+ *		Jeff Uphoff	:	Made max number of sockets command-line
+ *					configurable.
+ *		Matti Aarnio	:	Made the number of sockets dynamic,
+ *					to be allocated when needed, and mr.
+ *					Uphoff's max is used as max to be
+ *					allowed to allocate.
+ *		Linus		:	Argh. removed all the socket allocation
+ *					altogether: it's in the inode now.
+ *		Alan Cox	:	Made sock_alloc()/sock_release() public
+ *					for NetROM and future kernel nfsd type
+ *					stuff.
+ *		Alan Cox	:	sendmsg/recvmsg basics.
+ *		Tom Dyas	:	Export net symbols.
+ *		Marcin Dalecki	:	Fixed problems with CONFIG_NET="n".
+ *		Alan Cox	:	Added thread locking to sys_* calls
+ *					for sockets. May have errors at the
+ *					moment.
+ *		Kevin Buhr	:	Fixed the dumb errors in the above.
+ *		Andi Kleen	:	Some small cleanups, optimizations,
+ *					and fixed a copy_from_user() bug.
+ *		Tigran Aivazian	:	sys_send(args) calls sys_sendto(args, NULL, 0)
+ *		Tigran Aivazian	:	Made listen(2) backlog sanity checks
+ *					protocol-independent
+ *
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *
+ *	This module is effectively the top level interface to the BSD socket
+ *	paradigm.
+ *
+ *	Based upon Swansea University Computer Society NET3.039
+ */
+
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/thread_info.h>
+#include <linux/rcupdate.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/mutex.h>
+#include <linux/wanrouter.h>
+#include <linux/if_bridge.h>
+#include <linux/if_frad.h>
+#include <linux/if_vlan.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/cache.h>
+#include <linux/module.h>
+#include <linux/highmem.h>
+#include <linux/mount.h>
+#include <linux/security.h>
+#include <linux/syscalls.h>
+#include <linux/compat.h>
+#include <linux/kmod.h>
+#include <linux/audit.h>
+#include <linux/wireless.h>
+#include <linux/nsproxy.h>
+#include <linux/magic.h>
+#include <linux/slab.h>
+
+#include <asm/uaccess.h>
+#include <asm/unistd.h>
+
+#include <net/compat.h>
+#include <net/wext.h>
+#include <net/cls_cgroup.h>
+
+#include <net/sock.h>
+#include <linux/netfilter.h>
+
+#include <linux/if_tun.h>
+#include <linux/ipv6_route.h>
+#include <linux/route.h>
+#include <linux/sockios.h>
+#include <linux/atalk.h>
+
+static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
+static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
+			 unsigned long nr_segs, loff_t pos);
+static ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov,
+			  unsigned long nr_segs, loff_t pos);
+static int sock_mmap(struct file *file, struct vm_area_struct *vma);
+
+static int sock_close(struct inode *inode, struct file *file);
+static unsigned int sock_poll(struct file *file,
+			      struct poll_table_struct *wait);
+static long sock_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+#ifdef CONFIG_COMPAT
+static long compat_sock_ioctl(struct file *file,
+			      unsigned int cmd, unsigned long arg);
+#endif
+static int sock_fasync(int fd, struct file *filp, int on);
+static ssize_t sock_sendpage(struct file *file, struct page *page,
+			     int offset, size_t size, loff_t *ppos, int more);
+static ssize_t sock_splice_read(struct file *file, loff_t *ppos,
+				struct pipe_inode_info *pipe, size_t len,
+				unsigned int flags);
+
+/*
+ *	Socket files have a set of 'special' operations as well as the generic file ones. These don't appear
+ *	in the operation structures but are done directly via the socketcall() multiplexor.
+ */
+
+static const struct file_operations socket_file_ops = {
+	.owner =	THIS_MODULE,
+	.llseek =	no_llseek,
+	.aio_read =	sock_aio_read,
+	.aio_write =	sock_aio_write,
+	.poll =		sock_poll,
+	.unlocked_ioctl = sock_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = compat_sock_ioctl,
+#endif
+	.mmap =		sock_mmap,
+	.open =		sock_no_open,	/* special open code to disallow open via /proc */
+	.release =	sock_close,
+	.fasync =	sock_fasync,
+	.sendpage =	sock_sendpage,
+	.splice_write = generic_splice_sendpage,
+	.splice_read =	sock_splice_read,
+};
+
+/*
+ *	The protocol list. Each protocol is registered in here.
+ */
+
+static DEFINE_SPINLOCK(net_family_lock);
+static const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly;
+
+/*
+ *	Statistics counters of the socket lists
+ */
+
+static DEFINE_PER_CPU(int, sockets_in_use);
+
+/*
+ * Support routines.
+ * Move socket addresses back and forth across the kernel/user
+ * divide and look after the messy bits.
+ */
+
+/**
+ *	move_addr_to_kernel	-	copy a socket address into kernel space
+ *	@uaddr: Address in user space
+ *	@kaddr: Address in kernel space
+ *	@ulen: Length in user space
+ *
+ *	The address is copied into kernel space. If the provided address is
+ *	too long an error code of -EINVAL is returned. If the copy gives
+ *	invalid addresses -EFAULT is returned. On a success 0 is returned.
+ */
+
+int move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr *kaddr)
+{
+	if (ulen < 0 || ulen > sizeof(struct sockaddr_storage))
+		return -EINVAL;
+	if (ulen == 0)
+		return 0;
+	if (copy_from_user(kaddr, uaddr, ulen))
+		return -EFAULT;
+	return audit_sockaddr(ulen, kaddr);
+}
+
+/**
+ *	move_addr_to_user	-	copy an address to user space
+ *	@kaddr: kernel space address
+ *	@klen: length of address in kernel
+ *	@uaddr: user space address
+ *	@ulen: pointer to user length field
+ *
+ *	The value pointed to by ulen on entry is the buffer length available.
+ *	This is overwritten with the buffer space used. -EINVAL is returned
+ *	if an overlong buffer is specified or a negative buffer size. -EFAULT
+ *	is returned if either the buffer or the length field are not
+ *	accessible.
+ *	After copying the data up to the limit the user specifies, the true
+ *	length of the data is written over the length limit the user
+ *	specified. Zero is returned for a success.
+ */
+
+static int move_addr_to_user(struct sockaddr *kaddr, int klen,
+			     void __user *uaddr, int __user *ulen)
+{
+	int err;
+	int len;
+
+	err = get_user(len, ulen);
+	if (err)
+		return err;
+	if (len > klen)
+		len = klen;
+	if (len < 0 || len > sizeof(struct sockaddr_storage))
+		return -EINVAL;
+	if (len) {
+		if (audit_sockaddr(klen, kaddr))
+			return -ENOMEM;
+		if (copy_to_user(uaddr, kaddr, len))
+			return -EFAULT;
+	}
+	/*
+	 *      "fromlen shall refer to the value before truncation.."
+	 *                      1003.1g
+	 */
+	return __put_user(klen, ulen);
+}
+
+static struct kmem_cache *sock_inode_cachep __read_mostly;
+
+static struct inode *sock_alloc_inode(struct super_block *sb)
+{
+	struct socket_alloc *ei;
+	struct socket_wq *wq;
+
+	ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);
+	if (!ei)
+		return NULL;
+	wq = kmalloc(sizeof(*wq), GFP_KERNEL);
+	if (!wq) {
+		kmem_cache_free(sock_inode_cachep, ei);
+		return NULL;
+	}
+	init_waitqueue_head(&wq->wait);
+	wq->fasync_list = NULL;
+	RCU_INIT_POINTER(ei->socket.wq, wq);
+
+	ei->socket.state = SS_UNCONNECTED;
+	ei->socket.flags = 0;
+	ei->socket.ops = NULL;
+	ei->socket.sk = NULL;
+	ei->socket.file = NULL;
+
+	return &ei->vfs_inode;
+}
+
+static void sock_destroy_inode(struct inode *inode)
+{
+	struct socket_alloc *ei;
+	struct socket_wq *wq;
+
+	ei = container_of(inode, struct socket_alloc, vfs_inode);
+	wq = rcu_dereference_protected(ei->socket.wq, 1);
+	kfree_rcu(wq, rcu);
+	kmem_cache_free(sock_inode_cachep, ei);
+}
+
+static void init_once(void *foo)
+{
+	struct socket_alloc *ei = (struct socket_alloc *)foo;
+
+	inode_init_once(&ei->vfs_inode);
+}
+
+static int init_inodecache(void)
+{
+	sock_inode_cachep = kmem_cache_create("sock_inode_cache",
+					      sizeof(struct socket_alloc),
+					      0,
+					      (SLAB_HWCACHE_ALIGN |
+					       SLAB_RECLAIM_ACCOUNT |
+					       SLAB_MEM_SPREAD),
+					      init_once);
+	if (sock_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+static const struct super_operations sockfs_ops = {
+	.alloc_inode	= sock_alloc_inode,
+	.destroy_inode	= sock_destroy_inode,
+	.statfs		= simple_statfs,
+};
+
+/*
+ * sockfs_dname() is called from d_path().
+ */
+static char *sockfs_dname(struct dentry *dentry, char *buffer, int buflen)
+{
+	return dynamic_dname(dentry, buffer, buflen, "socket:[%lu]",
+				dentry->d_inode->i_ino);
+}
+
+static const struct dentry_operations sockfs_dentry_operations = {
+	.d_dname  = sockfs_dname,
+};
+
+static struct dentry *sockfs_mount(struct file_system_type *fs_type,
+			 int flags, const char *dev_name, void *data)
+{
+	return mount_pseudo(fs_type, "socket:", &sockfs_ops,
+		&sockfs_dentry_operations, SOCKFS_MAGIC);
+}
+
+static struct vfsmount *sock_mnt __read_mostly;
+
+static struct file_system_type sock_fs_type = {
+	.name =		"sockfs",
+	.mount =	sockfs_mount,
+	.kill_sb =	kill_anon_super,
+};
+
+/*
+ *	Obtains the first available file descriptor and sets it up for use.
+ *
+ *	These functions create file structures and maps them to fd space
+ *	of the current process. On success it returns file descriptor
+ *	and file struct implicitly stored in sock->file.
+ *	Note that another thread may close file descriptor before we return
+ *	from this function. We use the fact that now we do not refer
+ *	to socket after mapping. If one day we will need it, this
+ *	function will increment ref. count on file by 1.
+ *
+ *	In any case returned fd MAY BE not valid!
+ *	This race condition is unavoidable
+ *	with shared fd spaces, we cannot solve it inside kernel,
+ *	but we take care of internal coherence yet.
+ */
+
+static int sock_alloc_file(struct socket *sock, struct file **f, int flags)
+{
+	struct qstr name = { .name = "" };
+	struct path path;
+	struct file *file;
+	int fd;
+
+	fd = get_unused_fd_flags(flags);
+	if (unlikely(fd < 0))
+		return fd;
+
+	path.dentry = d_alloc_pseudo(sock_mnt->mnt_sb, &name);
+	if (unlikely(!path.dentry)) {
+		put_unused_fd(fd);
+		return -ENOMEM;
+	}
+	path.mnt = mntget(sock_mnt);
+
+	d_instantiate(path.dentry, SOCK_INODE(sock));
+	SOCK_INODE(sock)->i_fop = &socket_file_ops;
+
+	file = alloc_file(&path, FMODE_READ | FMODE_WRITE,
+		  &socket_file_ops);
+	if (unlikely(!file)) {
+		/* drop dentry, keep inode */
+		ihold(path.dentry->d_inode);
+		path_put(&path);
+		put_unused_fd(fd);
+		return -ENFILE;
+	}
+
+	sock->file = file;
+	file->f_flags = O_RDWR | (flags & O_NONBLOCK);
+	file->f_pos = 0;
+	file->private_data = sock;
+
+	*f = file;
+	return fd;
+}
+
+int sock_map_fd(struct socket *sock, int flags)
+{
+	struct file *newfile;
+	int fd = sock_alloc_file(sock, &newfile, flags);
+
+	if (likely(fd >= 0))
+		fd_install(fd, newfile);
+
+	return fd;
+}
+EXPORT_SYMBOL(sock_map_fd);
+
+static struct socket *sock_from_file(struct file *file, int *err)
+{
+	if (file->f_op == &socket_file_ops)
+		return file->private_data;	/* set in sock_map_fd */
+
+	*err = -ENOTSOCK;
+	return NULL;
+}
+
+/**
+ *	sockfd_lookup - Go from a file number to its socket slot
+ *	@fd: file handle
+ *	@err: pointer to an error code return
+ *
+ *	The file handle passed in is locked and the socket it is bound
+ *	too is returned. If an error occurs the err pointer is overwritten
+ *	with a negative errno code and NULL is returned. The function checks
+ *	for both invalid handles and passing a handle which is not a socket.
+ *
+ *	On a success the socket object pointer is returned.
+ */
+
+struct socket *sockfd_lookup(int fd, int *err)
+{
+	struct file *file;
+	struct socket *sock;
+
+	file = fget(fd);
+	if (!file) {
+		*err = -EBADF;
+		return NULL;
+	}
+
+	sock = sock_from_file(file, err);
+	if (!sock)
+		fput(file);
+	return sock;
+}
+EXPORT_SYMBOL(sockfd_lookup);
+
+static struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)
+{
+	struct file *file;
+	struct socket *sock;
+
+	*err = -EBADF;
+	file = fget_light(fd, fput_needed);
+	if (file) {
+		sock = sock_from_file(file, err);
+		if (sock)
+			return sock;
+		fput_light(file, *fput_needed);
+	}
+	return NULL;
+}
+
+/**
+ *	sock_alloc	-	allocate a socket
+ *
+ *	Allocate a new inode and socket object. The two are bound together
+ *	and initialised. The socket is then returned. If we are out of inodes
+ *	NULL is returned.
+ */
+
+static struct socket *sock_alloc(void)
+{
+	struct inode *inode;
+	struct socket *sock;
+
+	inode = new_inode(sock_mnt->mnt_sb);
+	if (!inode)
+		return NULL;
+
+	sock = SOCKET_I(inode);
+
+	kmemcheck_annotate_bitfield(sock, type);
+	inode->i_ino = get_next_ino();
+	inode->i_mode = S_IFSOCK | S_IRWXUGO;
+	inode->i_uid = current_fsuid();
+	inode->i_gid = current_fsgid();
+
+	percpu_add(sockets_in_use, 1);
+	return sock;
+}
+
+/*
+ *	In theory you can't get an open on this inode, but /proc provides
+ *	a back door. Remember to keep it shut otherwise you'll let the
+ *	creepy crawlies in.
+ */
+
+static int sock_no_open(struct inode *irrelevant, struct file *dontcare)
+{
+	return -ENXIO;
+}
+
+const struct file_operations bad_sock_fops = {
+	.owner = THIS_MODULE,
+	.open = sock_no_open,
+	.llseek = noop_llseek,
+};
+
+/**
+ *	sock_release	-	close a socket
+ *	@sock: socket to close
+ *
+ *	The socket is released from the protocol stack if it has a release
+ *	callback, and the inode is then released if the socket is bound to
+ *	an inode not a file.
+ */
+
+void sock_release(struct socket *sock)
+{
+	if (sock->ops) {
+		struct module *owner = sock->ops->owner;
+
+		sock->ops->release(sock);
+		sock->ops = NULL;
+		module_put(owner);
+	}
+
+	if (rcu_dereference_protected(sock->wq, 1)->fasync_list)
+		printk(KERN_ERR "sock_release: fasync list not empty!\n");
+
+	percpu_sub(sockets_in_use, 1);
+	if (!sock->file) {
+		iput(SOCK_INODE(sock));
+		return;
+	}
+	sock->file = NULL;
+}
+EXPORT_SYMBOL(sock_release);
+
+int sock_tx_timestamp(struct sock *sk, __u8 *tx_flags)
+{
+	*tx_flags = 0;
+	if (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE))
+		*tx_flags |= SKBTX_HW_TSTAMP;
+	if (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE))
+		*tx_flags |= SKBTX_SW_TSTAMP;
+	return 0;
+}
+EXPORT_SYMBOL(sock_tx_timestamp);
+
+static inline int __sock_sendmsg_nosec(struct kiocb *iocb, struct socket *sock,
+				       struct msghdr *msg, size_t size)
+{
+	struct sock_iocb *si = kiocb_to_siocb(iocb);
+
+	sock_update_classid(sock->sk);
+
+	si->sock = sock;
+	si->scm = NULL;
+	si->msg = msg;
+	si->size = size;
+
+	return sock->ops->sendmsg(iocb, sock, msg, size);
+}
+
+static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock,
+				 struct msghdr *msg, size_t size)
+{
+  int err = security_socket_sendmsg(sock, msg, size);
+  printk("security_socket_sendmsg returns %i\n",err);
+	return err ?: __sock_sendmsg_nosec(iocb, sock, msg, size);
+}
+
+int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
+{
+	struct kiocb iocb;
+	struct sock_iocb siocb;
+	int ret;
+	int i;
+
+	init_sync_kiocb(&iocb, NULL);
+	iocb.private = &siocb;
+	ret = __sock_sendmsg(&iocb, sock, msg, size);
+	printk("__sock_sendmsg returns %i\n",ret);
+	//for (i = 0; i < size;i++)
+	//printk("%x", (int)(((char*)msg)[i]));
+	if (-EIOCBQUEUED == ret)
+		ret = wait_on_sync_kiocb(&iocb);
+	return ret;
+}
+EXPORT_SYMBOL(sock_sendmsg);
+
+int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg, size_t size)
+{
+	struct kiocb iocb;
+	struct sock_iocb siocb;
+	int ret;
+
+	init_sync_kiocb(&iocb, NULL);
+	iocb.private = &siocb;
+	ret = __sock_sendmsg_nosec(&iocb, sock, msg, size);
+	if (-EIOCBQUEUED == ret)
+		ret = wait_on_sync_kiocb(&iocb);
+	return ret;
+}
+
+int kernel_sendmsg(struct socket *sock, struct msghdr *msg,
+		   struct kvec *vec, size_t num, size_t size)
+{
+	mm_segment_t oldfs = get_fs();
+	int result;
+
+	set_fs(KERNEL_DS);
+	/*
+	 * the following is safe, since for compiler definitions of kvec and
+	 * iovec are identical, yielding the same in-core layout and alignment
+	 */
+	msg->msg_iov = (struct iovec *)vec;
+	msg->msg_iovlen = num;
+	result = sock_sendmsg(sock, msg, size);
+	set_fs(oldfs);
+	return result;
+}
+EXPORT_SYMBOL(kernel_sendmsg);
+
+static int ktime2ts(ktime_t kt, struct timespec *ts)
+{
+	if (kt.tv64) {
+		*ts = ktime_to_timespec(kt);
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/*
+ * called from sock_recv_timestamp() if sock_flag(sk, SOCK_RCVTSTAMP)
+ */
+void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,
+	struct sk_buff *skb)
+{
+	int need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);
+	struct timespec ts[3];
+	int empty = 1;
+	struct skb_shared_hwtstamps *shhwtstamps =
+		skb_hwtstamps(skb);
+
+	/* Race occurred between timestamp enabling and packet
+	   receiving.  Fill in the current time for now. */
+	if (need_software_tstamp && skb->tstamp.tv64 == 0)
+		__net_timestamp(skb);
+
+	if (need_software_tstamp) {
+		if (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {
+			struct timeval tv;
+			skb_get_timestamp(skb, &tv);
+			put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,
+				 sizeof(tv), &tv);
+		} else {
+			skb_get_timestampns(skb, &ts[0]);
+			put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,
+				 sizeof(ts[0]), &ts[0]);
+		}
+	}
+
+
+	memset(ts, 0, sizeof(ts));
+	if (skb->tstamp.tv64 &&
+	    sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) {
+		skb_get_timestampns(skb, ts + 0);
+		empty = 0;
+	}
+	if (shhwtstamps) {
+		if (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE) &&
+		    ktime2ts(shhwtstamps->syststamp, ts + 1))
+			empty = 0;
+		if (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE) &&
+		    ktime2ts(shhwtstamps->hwtstamp, ts + 2))
+			empty = 0;
+	}
+	if (!empty)
+		put_cmsg(msg, SOL_SOCKET,
+			 SCM_TIMESTAMPING, sizeof(ts), &ts);
+}
+EXPORT_SYMBOL_GPL(__sock_recv_timestamp);
+
+static inline void sock_recv_drops(struct msghdr *msg, struct sock *sk,
+				   struct sk_buff *skb)
+{
+	if (sock_flag(sk, SOCK_RXQ_OVFL) && skb && skb->dropcount)
+		put_cmsg(msg, SOL_SOCKET, SO_RXQ_OVFL,
+			sizeof(__u32), &skb->dropcount);
+}
+
+void __sock_recv_ts_and_drops(struct msghdr *msg, struct sock *sk,
+	struct sk_buff *skb)
+{
+	sock_recv_timestamp(msg, sk, skb);
+	sock_recv_drops(msg, sk, skb);
+}
+EXPORT_SYMBOL_GPL(__sock_recv_ts_and_drops);
+
+static inline int __sock_recvmsg_nosec(struct kiocb *iocb, struct socket *sock,
+				       struct msghdr *msg, size_t size, int flags)
+{
+	struct sock_iocb *si = kiocb_to_siocb(iocb);
+
+	sock_update_classid(sock->sk);
+
+	si->sock = sock;
+	si->scm = NULL;
+	si->msg = msg;
+	si->size = size;
+	si->flags = flags;
+
+	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
+}
+
+static inline int __sock_recvmsg(struct kiocb *iocb, struct socket *sock,
+				 struct msghdr *msg, size_t size, int flags)
+{
+	int err = security_socket_recvmsg(sock, msg, size, flags);
+
+	return err ?: __sock_recvmsg_nosec(iocb, sock, msg, size, flags);
+}
+
+int sock_recvmsg(struct socket *sock, struct msghdr *msg,
+		 size_t size, int flags)
+{
+	struct kiocb iocb;
+	struct sock_iocb siocb;
+	int ret;
+
+	init_sync_kiocb(&iocb, NULL);
+	iocb.private = &siocb;
+	ret = __sock_recvmsg(&iocb, sock, msg, size, flags);
+	if (-EIOCBQUEUED == ret)
+		ret = wait_on_sync_kiocb(&iocb);
+	return ret;
+}
+EXPORT_SYMBOL(sock_recvmsg);
+
+static int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,
+			      size_t size, int flags)
+{
+	struct kiocb iocb;
+	struct sock_iocb siocb;
+	int ret;
+
+	init_sync_kiocb(&iocb, NULL);
+	iocb.private = &siocb;
+	ret = __sock_recvmsg_nosec(&iocb, sock, msg, size, flags);
+	if (-EIOCBQUEUED == ret)
+		ret = wait_on_sync_kiocb(&iocb);
+	return ret;
+}
+
+/**
+ * kernel_recvmsg - Receive a message from a socket (kernel space)
+ * @sock:       The socket to receive the message from
+ * @msg:        Received message
+ * @vec:        Input s/g array for message data
+ * @num:        Size of input s/g array
+ * @size:       Number of bytes to read
+ * @flags:      Message flags (MSG_DONTWAIT, etc...)
+ *
+ * On return the msg structure contains the scatter/gather array passed in the
+ * vec argument. The array is modified so that it consists of the unfilled
+ * portion of the original array.
+ *
+ * The returned value is the total number of bytes received, or an error.
+ */
+int kernel_recvmsg(struct socket *sock, struct msghdr *msg,
+		   struct kvec *vec, size_t num, size_t size, int flags)
+{
+	mm_segment_t oldfs = get_fs();
+	int result;
+
+	set_fs(KERNEL_DS);
+	/*
+	 * the following is safe, since for compiler definitions of kvec and
+	 * iovec are identical, yielding the same in-core layout and alignment
+	 */
+	msg->msg_iov = (struct iovec *)vec, msg->msg_iovlen = num;
+	result = sock_recvmsg(sock, msg, size, flags);
+	set_fs(oldfs);
+	return result;
+}
+EXPORT_SYMBOL(kernel_recvmsg);
+
+static void sock_aio_dtor(struct kiocb *iocb)
+{
+	kfree(iocb->private);
+}
+
+static ssize_t sock_sendpage(struct file *file, struct page *page,
+			     int offset, size_t size, loff_t *ppos, int more)
+{
+	struct socket *sock;
+	int flags;
+
+	sock = file->private_data;
+
+	flags = !(file->f_flags & O_NONBLOCK) ? 0 : MSG_DONTWAIT;
+	if (more)
+		flags |= MSG_MORE;
+
+	return kernel_sendpage(sock, page, offset, size, flags);
+}
+
+static ssize_t sock_splice_read(struct file *file, loff_t *ppos,
+				struct pipe_inode_info *pipe, size_t len,
+				unsigned int flags)
+{
+	struct socket *sock = file->private_data;
+
+	if (unlikely(!sock->ops->splice_read))
+		return -EINVAL;
+
+	sock_update_classid(sock->sk);
+
+	return sock->ops->splice_read(sock, ppos, pipe, len, flags);
+}
+
+static struct sock_iocb *alloc_sock_iocb(struct kiocb *iocb,
+					 struct sock_iocb *siocb)
+{
+	if (!is_sync_kiocb(iocb)) {
+		siocb = kmalloc(sizeof(*siocb), GFP_KERNEL);
+		if (!siocb)
+			return NULL;
+		iocb->ki_dtor = sock_aio_dtor;
+	}
+
+	siocb->kiocb = iocb;
+	iocb->private = siocb;
+	return siocb;
+}
+
+static ssize_t do_sock_read(struct msghdr *msg, struct kiocb *iocb,
+		struct file *file, const struct iovec *iov,
+		unsigned long nr_segs)
+{
+	struct socket *sock = file->private_data;
+	size_t size = 0;
+	int i;
+
+	for (i = 0; i < nr_segs; i++)
+		size += iov[i].iov_len;
+
+	msg->msg_name = NULL;
+	msg->msg_namelen = 0;
+	msg->msg_control = NULL;
+	msg->msg_controllen = 0;
+	msg->msg_iov = (struct iovec *)iov;
+	msg->msg_iovlen = nr_segs;
+	msg->msg_flags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;
+
+	return __sock_recvmsg(iocb, sock, msg, size, msg->msg_flags);
+}
+
+static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
+				unsigned long nr_segs, loff_t pos)
+{
+	struct sock_iocb siocb, *x;
+
+	if (pos != 0)
+		return -ESPIPE;
+
+	if (iocb->ki_left == 0)	/* Match SYS5 behaviour */
+		return 0;
+
+
+	x = alloc_sock_iocb(iocb, &siocb);
+	if (!x)
+		return -ENOMEM;
+	return do_sock_read(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);
+}
+
+static ssize_t do_sock_write(struct msghdr *msg, struct kiocb *iocb,
+			struct file *file, const struct iovec *iov,
+			unsigned long nr_segs)
+{
+	struct socket *sock = file->private_data;
+	size_t size = 0;
+	int i;
+
+	for (i = 0; i < nr_segs; i++)
+		size += iov[i].iov_len;
+
+	msg->msg_name = NULL;
+	msg->msg_namelen = 0;
+	msg->msg_control = NULL;
+	msg->msg_controllen = 0;
+	msg->msg_iov = (struct iovec *)iov;
+	msg->msg_iovlen = nr_segs;
+	msg->msg_flags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;
+	if (sock->type == SOCK_SEQPACKET)
+		msg->msg_flags |= MSG_EOR;
+
+	return __sock_sendmsg(iocb, sock, msg, size);
+}
+
+static ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov,
+			  unsigned long nr_segs, loff_t pos)
+{
+	struct sock_iocb siocb, *x;
+
+	if (pos != 0)
+		return -ESPIPE;
+
+	x = alloc_sock_iocb(iocb, &siocb);
+	if (!x)
+		return -ENOMEM;
+
+	return do_sock_write(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);
+}
+
+/*
+ * Atomic setting of ioctl hooks to avoid race
+ * with module unload.
+ */
+
+static DEFINE_MUTEX(br_ioctl_mutex);
+static int (*br_ioctl_hook) (struct net *, unsigned int cmd, void __user *arg);
+
+void brioctl_set(int (*hook) (struct net *, unsigned int, void __user *))
+{
+	mutex_lock(&br_ioctl_mutex);
+	br_ioctl_hook = hook;
+	mutex_unlock(&br_ioctl_mutex);
+}
+EXPORT_SYMBOL(brioctl_set);
+
+static DEFINE_MUTEX(vlan_ioctl_mutex);
+static int (*vlan_ioctl_hook) (struct net *, void __user *arg);
+
+void vlan_ioctl_set(int (*hook) (struct net *, void __user *))
+{
+	mutex_lock(&vlan_ioctl_mutex);
+	vlan_ioctl_hook = hook;
+	mutex_unlock(&vlan_ioctl_mutex);
+}
+EXPORT_SYMBOL(vlan_ioctl_set);
+
+static DEFINE_MUTEX(dlci_ioctl_mutex);
+static int (*dlci_ioctl_hook) (unsigned int, void __user *);
+
+void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
+{
+	mutex_lock(&dlci_ioctl_mutex);
+	dlci_ioctl_hook = hook;
+	mutex_unlock(&dlci_ioctl_mutex);
+}
+EXPORT_SYMBOL(dlci_ioctl_set);
+
+static long sock_do_ioctl(struct net *net, struct socket *sock,
+				 unsigned int cmd, unsigned long arg)
+{
+	int err;
+	void __user *argp = (void __user *)arg;
+
+	err = sock->ops->ioctl(sock, cmd, arg);
+
+	/*
+	 * If this ioctl is unknown try to hand it down
+	 * to the NIC driver.
+	 */
+	if (err == -ENOIOCTLCMD)
+		err = dev_ioctl(net, cmd, argp);
+
+	return err;
+}
+
+/*
+ *	With an ioctl, arg may well be a user mode pointer, but we don't know
+ *	what to do with it - that's up to the protocol still.
+ */
+
+static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)
+{
+	struct socket *sock;
+	struct sock *sk;
+	void __user *argp = (void __user *)arg;
+	int pid, err;
+	struct net *net;
+
+	sock = file->private_data;
+	sk = sock->sk;
+	net = sock_net(sk);
+	if (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15)) {
+		err = dev_ioctl(net, cmd, argp);
+	} else
+#ifdef CONFIG_WEXT_CORE
+	if (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {
+		err = dev_ioctl(net, cmd, argp);
+	} else
+#endif
+		switch (cmd) {
+		case FIOSETOWN:
+		case SIOCSPGRP:
+			err = -EFAULT;
+			if (get_user(pid, (int __user *)argp))
+				break;
+			err = f_setown(sock->file, pid, 1);
+			break;
+		case FIOGETOWN:
+		case SIOCGPGRP:
+			err = put_user(f_getown(sock->file),
+				       (int __user *)argp);
+			break;
+		case SIOCGIFBR:
+		case SIOCSIFBR:
+		case SIOCBRADDBR:
+		case SIOCBRDELBR:
+			err = -ENOPKG;
+			if (!br_ioctl_hook)
+				request_module("bridge");
+
+			mutex_lock(&br_ioctl_mutex);
+			if (br_ioctl_hook)
+				err = br_ioctl_hook(net, cmd, argp);
+			mutex_unlock(&br_ioctl_mutex);
+			break;
+		case SIOCGIFVLAN:
+		case SIOCSIFVLAN:
+			err = -ENOPKG;
+			if (!vlan_ioctl_hook)
+				request_module("8021q");
+
+			mutex_lock(&vlan_ioctl_mutex);
+			if (vlan_ioctl_hook)
+				err = vlan_ioctl_hook(net, argp);
+			mutex_unlock(&vlan_ioctl_mutex);
+			break;
+		case SIOCADDDLCI:
+		case SIOCDELDLCI:
+			err = -ENOPKG;
+			if (!dlci_ioctl_hook)
+				request_module("dlci");
+
+			mutex_lock(&dlci_ioctl_mutex);
+			if (dlci_ioctl_hook)
+				err = dlci_ioctl_hook(cmd, argp);
+			mutex_unlock(&dlci_ioctl_mutex);
+			break;
+		default:
+			err = sock_do_ioctl(net, sock, cmd, arg);
+			break;
+		}
+	return err;
+}
+
+int sock_create_lite(int family, int type, int protocol, struct socket **res)
+{
+	int err;
+	struct socket *sock = NULL;
+
+	err = security_socket_create(family, type, protocol, 1);
+	if (err)
+		goto out;
+
+	sock = sock_alloc();
+	if (!sock) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	sock->type = type;
+	err = security_socket_post_create(sock, family, type, protocol, 1);
+	if (err)
+		goto out_release;
+
+out:
+	*res = sock;
+	return err;
+out_release:
+	sock_release(sock);
+	sock = NULL;
+	goto out;
+}
+EXPORT_SYMBOL(sock_create_lite);
+
+/* No kernel lock held - perfect */
+static unsigned int sock_poll(struct file *file, poll_table *wait)
+{
+	struct socket *sock;
+
+	/*
+	 *      We can't return errors to poll, so it's either yes or no.
+	 */
+	sock = file->private_data;
+	return sock->ops->poll(file, sock, wait);
+}
+
+static int sock_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct socket *sock = file->private_data;
+
+	return sock->ops->mmap(file, sock, vma);
+}
+
+static int sock_close(struct inode *inode, struct file *filp)
+{
+	/*
+	 *      It was possible the inode is NULL we were
+	 *      closing an unfinished socket.
+	 */
+
+	if (!inode) {
+		printk(KERN_DEBUG "sock_close: NULL inode\n");
+		return 0;
+	}
+	sock_release(SOCKET_I(inode));
+	return 0;
+}
+
+/*
+ *	Update the socket async list
+ *
+ *	Fasync_list locking strategy.
+ *
+ *	1. fasync_list is modified only under process context socket lock
+ *	   i.e. under semaphore.
+ *	2. fasync_list is used under read_lock(&sk->sk_callback_lock)
+ *	   or under socket lock
+ */
+
+static int sock_fasync(int fd, struct file *filp, int on)
+{
+	struct socket *sock = filp->private_data;
+	struct sock *sk = sock->sk;
+	struct socket_wq *wq;
+
+	if (sk == NULL)
+		return -EINVAL;
+
+	lock_sock(sk);
+	wq = rcu_dereference_protected(sock->wq, sock_owned_by_user(sk));
+	fasync_helper(fd, filp, on, &wq->fasync_list);
+
+	if (!wq->fasync_list)
+		sock_reset_flag(sk, SOCK_FASYNC);
+	else
+		sock_set_flag(sk, SOCK_FASYNC);
+
+	release_sock(sk);
+	return 0;
+}
+
+/* This function may be called only under socket lock or callback_lock or rcu_lock */
+
+int sock_wake_async(struct socket *sock, int how, int band)
+{
+	struct socket_wq *wq;
+
+	if (!sock)
+		return -1;
+	rcu_read_lock();
+	wq = rcu_dereference(sock->wq);
+	if (!wq || !wq->fasync_list) {
+		rcu_read_unlock();
+		return -1;
+	}
+	switch (how) {
+	case SOCK_WAKE_WAITD:
+		if (test_bit(SOCK_ASYNC_WAITDATA, &sock->flags))
+			break;
+		goto call_kill;
+	case SOCK_WAKE_SPACE:
+		if (!test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sock->flags))
+			break;
+		/* fall through */
+	case SOCK_WAKE_IO:
+call_kill:
+		kill_fasync(&wq->fasync_list, SIGIO, band);
+		break;
+	case SOCK_WAKE_URG:
+		kill_fasync(&wq->fasync_list, SIGURG, band);
+	}
+	rcu_read_unlock();
+	return 0;
+}
+EXPORT_SYMBOL(sock_wake_async);
+
+int __sock_create(struct net *net, int family, int type, int protocol,
+			 struct socket **res, int kern)
+{
+	int err;
+	struct socket *sock;
+	const struct net_proto_family *pf;
+
+	/*
+	 *      Check protocol is in range
+	 */
+	if (family < 0 || family >= NPROTO)
+		return -EAFNOSUPPORT;
+	if (type < 0 || type >= SOCK_MAX)
+		return -EINVAL;
+
+	/* Compatibility.
+
+	   This uglymoron is moved from INET layer to here to avoid
+	   deadlock in module load.
+	 */
+	if (family == PF_INET && type == SOCK_PACKET) {
+		static int warned;
+		if (!warned) {
+			warned = 1;
+			printk(KERN_INFO "%s uses obsolete (PF_INET,SOCK_PACKET)\n",
+			       current->comm);
+		}
+		family = PF_PACKET;
+	}
+
+	err = security_socket_create(family, type, protocol, kern);
+	if (err)
+		return err;
+
+	/*
+	 *	Allocate the socket and allow the family to set things up. if
+	 *	the protocol is 0, the family is instructed to select an appropriate
+	 *	default.
+	 */
+	sock = sock_alloc();
+	if (!sock) {
+		if (net_ratelimit())
+			printk(KERN_WARNING "socket: no more sockets\n");
+		return -ENFILE;	/* Not exactly a match, but its the
+				   closest posix thing */
+	}
+
+	sock->type = type;
+
+#ifdef CONFIG_MODULES
+	/* Attempt to load a protocol module if the find failed.
+	 *
+	 * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user
+	 * requested real, full-featured networking support upon configuration.
+	 * Otherwise module support will break!
+	 */
+	if (rcu_access_pointer(net_families[family]) == NULL)
+		request_module("net-pf-%d", family);
+#endif
+
+	rcu_read_lock();
+	pf = rcu_dereference(net_families[family]);
+	err = -EAFNOSUPPORT;
+	if (!pf)
+		goto out_release;
+
+	/*
+	 * We will call the ->create function, that possibly is in a loadable
+	 * module, so we have to bump that loadable module refcnt first.
+	 */
+	if (!try_module_get(pf->owner))
+		goto out_release;
+
+	/* Now protected by module ref count */
+	rcu_read_unlock();
+
+	err = pf->create(net, sock, protocol, kern);
+	if (err < 0)
+		goto out_module_put;
+
+	/*
+	 * Now to bump the refcnt of the [loadable] module that owns this
+	 * socket at sock_release time we decrement its refcnt.
+	 */
+	if (!try_module_get(sock->ops->owner))
+		goto out_module_busy;
+
+	/*
+	 * Now that we're done with the ->create function, the [loadable]
+	 * module can have its refcnt decremented
+	 */
+	module_put(pf->owner);
+	err = security_socket_post_create(sock, family, type, protocol, kern);
+	if (err)
+		goto out_sock_release;
+	*res = sock;
+
+	return 0;
+
+out_module_busy:
+	err = -EAFNOSUPPORT;
+out_module_put:
+	sock->ops = NULL;
+	module_put(pf->owner);
+out_sock_release:
+	sock_release(sock);
+	return err;
+
+out_release:
+	rcu_read_unlock();
+	goto out_sock_release;
+}
+EXPORT_SYMBOL(__sock_create);
+
+int sock_create(int family, int type, int protocol, struct socket **res)
+{
+	return __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);
+}
+EXPORT_SYMBOL(sock_create);
+
+int sock_create_kern(int family, int type, int protocol, struct socket **res)
+{
+	return __sock_create(&init_net, family, type, protocol, res, 1);
+}
+EXPORT_SYMBOL(sock_create_kern);
+
+SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
+{
+	int retval;
+	struct socket *sock;
+	int flags;
+
+	/* Check the SOCK_* constants for consistency.  */
+	BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);
+	BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);
+	BUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);
+	BUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);
+
+	flags = type & ~SOCK_TYPE_MASK;
+	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
+		return -EINVAL;
+	type &= SOCK_TYPE_MASK;
+
+	if (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))
+		flags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;
+
+	retval = sock_create(family, type, protocol, &sock);
+	if (retval < 0)
+		goto out;
+
+	retval = sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));
+	if (retval < 0)
+		goto out_release;
+
+out:
+	/* It may be already another descriptor 8) Not kernel problem. */
+	return retval;
+
+out_release:
+	sock_release(sock);
+	return retval;
+}
+
+/*
+ *	Create a pair of connected sockets.
+ */
+
+SYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,
+		int __user *, usockvec)
+{
+	struct socket *sock1, *sock2;
+	int fd1, fd2, err;
+	struct file *newfile1, *newfile2;
+	int flags;
+
+	flags = type & ~SOCK_TYPE_MASK;
+	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
+		return -EINVAL;
+	type &= SOCK_TYPE_MASK;
+
+	if (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))
+		flags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;
+
+	/*
+	 * Obtain the first socket and check if the underlying protocol
+	 * supports the socketpair call.
+	 */
+
+	err = sock_create(family, type, protocol, &sock1);
+	if (err < 0)
+		goto out;
+
+	err = sock_create(family, type, protocol, &sock2);
+	if (err < 0)
+		goto out_release_1;
+
+	err = sock1->ops->socketpair(sock1, sock2);
+	if (err < 0)
+		goto out_release_both;
+
+	fd1 = sock_alloc_file(sock1, &newfile1, flags);
+	if (unlikely(fd1 < 0)) {
+		err = fd1;
+		goto out_release_both;
+	}
+
+	fd2 = sock_alloc_file(sock2, &newfile2, flags);
+	if (unlikely(fd2 < 0)) {
+		err = fd2;
+		fput(newfile1);
+		put_unused_fd(fd1);
+		sock_release(sock2);
+		goto out;
+	}
+
+	audit_fd_pair(fd1, fd2);
+	fd_install(fd1, newfile1);
+	fd_install(fd2, newfile2);
+	/* fd1 and fd2 may be already another descriptors.
+	 * Not kernel problem.
+	 */
+
+	err = put_user(fd1, &usockvec[0]);
+	if (!err)
+		err = put_user(fd2, &usockvec[1]);
+	if (!err)
+		return 0;
+
+	sys_close(fd2);
+	sys_close(fd1);
+	return err;
+
+out_release_both:
+	sock_release(sock2);
+out_release_1:
+	sock_release(sock1);
+out:
+	return err;
+}
+
+/*
+ *	Bind a name to a socket. Nothing much to do here since it's
+ *	the protocol's responsibility to handle the local address.
+ *
+ *	We move the socket address to kernel space before we call
+ *	the protocol layer (having also checked the address is ok).
+ */
+
+SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)
+{
+	struct socket *sock;
+	struct sockaddr_storage address;
+	int err, fput_needed;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (sock) {
+		err = move_addr_to_kernel(umyaddr, addrlen, (struct sockaddr *)&address);
+		if (err >= 0) {
+			err = security_socket_bind(sock,
+						   (struct sockaddr *)&address,
+						   addrlen);
+			if (!err)
+				err = sock->ops->bind(sock,
+						      (struct sockaddr *)
+						      &address, addrlen);
+		}
+		fput_light(sock->file, fput_needed);
+	}
+	return err;
+}
+
+/*
+ *	Perform a listen. Basically, we allow the protocol to do anything
+ *	necessary for a listen, and if that works, we mark the socket as
+ *	ready for listening.
+ */
+
+SYSCALL_DEFINE2(listen, int, fd, int, backlog)
+{
+	struct socket *sock;
+	int err, fput_needed;
+	int somaxconn;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (sock) {
+		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
+		if ((unsigned)backlog > somaxconn)
+			backlog = somaxconn;
+
+		err = security_socket_listen(sock, backlog);
+		if (!err)
+			err = sock->ops->listen(sock, backlog);
+
+		fput_light(sock->file, fput_needed);
+	}
+	return err;
+}
+
+/*
+ *	For accept, we attempt to create a new socket, set up the link
+ *	with the client, wake up the client, then return the new
+ *	connected fd. We collect the address of the connector in kernel
+ *	space and move it to user at the very end. This is unclean because
+ *	we open the socket then return an error.
+ *
+ *	1003.1g adds the ability to recvmsg() to query connection pending
+ *	status to recvmsg. We need to add that support in a way thats
+ *	clean when we restucture accept also.
+ */
+
+SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,
+		int __user *, upeer_addrlen, int, flags)
+{
+	struct socket *sock, *newsock;
+	struct file *newfile;
+	int err, len, newfd, fput_needed;
+	struct sockaddr_storage address;
+
+	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
+		return -EINVAL;
+
+	if (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))
+		flags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (!sock)
+		goto out;
+
+	err = -ENFILE;
+	newsock = sock_alloc();
+	if (!newsock)
+		goto out_put;
+
+	newsock->type = sock->type;
+	newsock->ops = sock->ops;
+
+	/*
+	 * We don't need try_module_get here, as the listening socket (sock)
+	 * has the protocol module (sock->ops->owner) held.
+	 */
+	__module_get(newsock->ops->owner);
+
+	newfd = sock_alloc_file(newsock, &newfile, flags);
+	if (unlikely(newfd < 0)) {
+		err = newfd;
+		sock_release(newsock);
+		goto out_put;
+	}
+
+	err = security_socket_accept(sock, newsock);
+	if (err)
+		goto out_fd;
+
+	err = sock->ops->accept(sock, newsock, sock->file->f_flags);
+	if (err < 0)
+		goto out_fd;
+
+	if (upeer_sockaddr) {
+		if (newsock->ops->getname(newsock, (struct sockaddr *)&address,
+					  &len, 2) < 0) {
+			err = -ECONNABORTED;
+			goto out_fd;
+		}
+		err = move_addr_to_user((struct sockaddr *)&address,
+					len, upeer_sockaddr, upeer_addrlen);
+		if (err < 0)
+			goto out_fd;
+	}
+
+	/* File flags are not inherited via accept() unlike another OSes. */
+
+	fd_install(newfd, newfile);
+	err = newfd;
+
+out_put:
+	fput_light(sock->file, fput_needed);
+out:
+	return err;
+out_fd:
+	fput(newfile);
+	put_unused_fd(newfd);
+	goto out_put;
+}
+
+SYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,
+		int __user *, upeer_addrlen)
+{
+	return sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);
+}
+
+/*
+ *	Attempt to connect to a socket with the server address.  The address
+ *	is in user space so we verify it is OK and move it to kernel space.
+ *
+ *	For 1003.1g we need to add clean support for a bind to AF_UNSPEC to
+ *	break bindings
+ *
+ *	NOTE: 1003.1g draft 6.3 is broken with respect to AX.25/NetROM and
+ *	other SEQPACKET protocols that take time to connect() as it doesn't
+ *	include the -EINPROGRESS status for such sockets.
+ */
+
+SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
+		int, addrlen)
+{
+	struct socket *sock;
+	struct sockaddr_storage address;
+	int err, fput_needed;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (!sock)
+		goto out;
+	err = move_addr_to_kernel(uservaddr, addrlen, (struct sockaddr *)&address);
+	if (err < 0)
+		goto out_put;
+
+	err =
+	    security_socket_connect(sock, (struct sockaddr *)&address, addrlen);
+	if (err)
+		goto out_put;
+
+	err = sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,
+				 sock->file->f_flags);
+out_put:
+	fput_light(sock->file, fput_needed);
+out:
+	return err;
+}
+
+/*
+ *	Get the local address ('name') of a socket object. Move the obtained
+ *	name to user space.
+ */
+
+SYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,
+		int __user *, usockaddr_len)
+{
+	struct socket *sock;
+	struct sockaddr_storage address;
+	int len, err, fput_needed;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (!sock)
+		goto out;
+
+	err = security_socket_getsockname(sock);
+	if (err)
+		goto out_put;
+
+	err = sock->ops->getname(sock, (struct sockaddr *)&address, &len, 0);
+	if (err)
+		goto out_put;
+	err = move_addr_to_user((struct sockaddr *)&address, len, usockaddr, usockaddr_len);
+
+out_put:
+	fput_light(sock->file, fput_needed);
+out:
+	return err;
+}
+
+/*
+ *	Get the remote address ('name') of a socket object. Move the obtained
+ *	name to user space.
+ */
+
+SYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,
+		int __user *, usockaddr_len)
+{
+	struct socket *sock;
+	struct sockaddr_storage address;
+	int len, err, fput_needed;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (sock != NULL) {
+		err = security_socket_getpeername(sock);
+		if (err) {
+			fput_light(sock->file, fput_needed);
+			return err;
+		}
+
+		err =
+		    sock->ops->getname(sock, (struct sockaddr *)&address, &len,
+				       1);
+		if (!err)
+			err = move_addr_to_user((struct sockaddr *)&address, len, usockaddr,
+						usockaddr_len);
+		fput_light(sock->file, fput_needed);
+	}
+	return err;
+}
+
+/*
+ *	Send a datagram to a given address. We move the address into kernel
+ *	space and check the user space data area is readable before invoking
+ *	the protocol.
+ */
+
+SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,
+		unsigned, flags, struct sockaddr __user *, addr,
+		int, addr_len)
+{
+	struct socket *sock;
+	struct sockaddr_storage address;
+	int err;
+	struct msghdr msg;
+	struct iovec iov;
+	int fput_needed;
+
+	if (len > INT_MAX)
+		len = INT_MAX;
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (!sock)
+		goto out;
+
+	iov.iov_base = buff;
+	iov.iov_len = len;
+	msg.msg_name = NULL;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_namelen = 0;
+	if (addr) {
+		err = move_addr_to_kernel(addr, addr_len, (struct sockaddr *)&address);
+		if (err < 0)
+			goto out_put;
+		msg.msg_name = (struct sockaddr *)&address;
+		msg.msg_namelen = addr_len;
+	}
+	if (sock->file->f_flags & O_NONBLOCK)
+		flags |= MSG_DONTWAIT;
+	msg.msg_flags = flags;
+	err = sock_sendmsg(sock, &msg, len);
+
+out_put:
+	fput_light(sock->file, fput_needed);
+out:
+	return err;
+}
+
+/*
+ *	Send a datagram down a socket.
+ */
+
+SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,
+		unsigned, flags)
+{
+	return sys_sendto(fd, buff, len, flags, NULL, 0);
+}
+
+/*
+ *	Receive a frame from the socket and optionally record the address of the
+ *	sender. We verify the buffers are writable and if needed move the
+ *	sender address from kernel to user space.
+ */
+
+SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,
+		unsigned, flags, struct sockaddr __user *, addr,
+		int __user *, addr_len)
+{
+	struct socket *sock;
+	struct iovec iov;
+	struct msghdr msg;
+	struct sockaddr_storage address;
+	int err, err2;
+	int fput_needed;
+
+	if (size > INT_MAX)
+		size = INT_MAX;
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (!sock)
+		goto out;
+
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_iovlen = 1;
+	msg.msg_iov = &iov;
+	iov.iov_len = size;
+	iov.iov_base = ubuf;
+	msg.msg_name = (struct sockaddr *)&address;
+	msg.msg_namelen = sizeof(address);
+	if (sock->file->f_flags & O_NONBLOCK)
+		flags |= MSG_DONTWAIT;
+	err = sock_recvmsg(sock, &msg, size, flags);
+
+	if (err >= 0 && addr != NULL) {
+		err2 = move_addr_to_user((struct sockaddr *)&address,
+					 msg.msg_namelen, addr, addr_len);
+		if (err2 < 0)
+			err = err2;
+	}
+
+	fput_light(sock->file, fput_needed);
+out:
+	return err;
+}
+
+/*
+ *	Receive a datagram from a socket.
+ */
+
+asmlinkage long sys_recv(int fd, void __user *ubuf, size_t size,
+			 unsigned flags)
+{
+	return sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);
+}
+
+/*
+ *	Set a socket option. Because we don't know the option lengths we have
+ *	to pass the user mode parameter for the protocols to sort out.
+ */
+
+SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,
+		char __user *, optval, int, optlen)
+{
+	int err, fput_needed;
+	struct socket *sock;
+
+	if (optlen < 0)
+		return -EINVAL;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (sock != NULL) {
+		err = security_socket_setsockopt(sock, level, optname);
+		if (err)
+			goto out_put;
+
+		if (level == SOL_SOCKET)
+			err =
+			    sock_setsockopt(sock, level, optname, optval,
+					    optlen);
+		else
+			err =
+			    sock->ops->setsockopt(sock, level, optname, optval,
+						  optlen);
+out_put:
+		fput_light(sock->file, fput_needed);
+	}
+	return err;
+}
+
+/*
+ *	Get a socket option. Because we don't know the option lengths we have
+ *	to pass a user mode parameter for the protocols to sort out.
+ */
+
+SYSCALL_DEFINE5(getsockopt, int, fd, int, level, int, optname,
+		char __user *, optval, int __user *, optlen)
+{
+	int err, fput_needed;
+	struct socket *sock;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (sock != NULL) {
+		err = security_socket_getsockopt(sock, level, optname);
+		if (err)
+			goto out_put;
+
+		if (level == SOL_SOCKET)
+			err =
+			    sock_getsockopt(sock, level, optname, optval,
+					    optlen);
+		else
+			err =
+			    sock->ops->getsockopt(sock, level, optname, optval,
+						  optlen);
+out_put:
+		fput_light(sock->file, fput_needed);
+	}
+	return err;
+}
+
+/*
+ *	Shutdown a socket.
+ */
+
+SYSCALL_DEFINE2(shutdown, int, fd, int, how)
+{
+	int err, fput_needed;
+	struct socket *sock;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (sock != NULL) {
+		err = security_socket_shutdown(sock, how);
+		if (!err)
+			err = sock->ops->shutdown(sock, how);
+		fput_light(sock->file, fput_needed);
+	}
+	return err;
+}
+
+/* A couple of helpful macros for getting the address of the 32/64 bit
+ * fields which are the same type (int / unsigned) on our platforms.
+ */
+#define COMPAT_MSG(msg, member)	((MSG_CMSG_COMPAT & flags) ? &msg##_compat->member : &msg->member)
+#define COMPAT_NAMELEN(msg)	COMPAT_MSG(msg, msg_namelen)
+#define COMPAT_FLAGS(msg)	COMPAT_MSG(msg, msg_flags)
+
+static int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,
+			 struct msghdr *msg_sys, unsigned flags, int nosec)
+{
+	struct compat_msghdr __user *msg_compat =
+	    (struct compat_msghdr __user *)msg;
+	struct sockaddr_storage address;
+	struct iovec iovstack[UIO_FASTIOV], *iov = iovstack;
+	unsigned char ctl[sizeof(struct cmsghdr) + 20]
+	    __attribute__ ((aligned(sizeof(__kernel_size_t))));
+	/* 20 is size of ipv6_pktinfo */
+	unsigned char *ctl_buf = ctl;
+	int err, ctl_len, iov_size, total_len;
+
+	err = -EFAULT;
+	if (MSG_CMSG_COMPAT & flags) {
+		if (get_compat_msghdr(msg_sys, msg_compat))
+			return -EFAULT;
+	} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))
+		return -EFAULT;
+
+	/* do not move before msg_sys is valid */
+	err = -EMSGSIZE;
+	if (msg_sys->msg_iovlen > UIO_MAXIOV)
+		goto out;
+
+	/* Check whether to allocate the iovec area */
+	err = -ENOMEM;
+	iov_size = msg_sys->msg_iovlen * sizeof(struct iovec);
+	if (msg_sys->msg_iovlen > UIO_FASTIOV) {
+		iov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);
+		if (!iov)
+			goto out;
+	}
+
+	/* This will also move the address data into kernel space */
+	if (MSG_CMSG_COMPAT & flags) {
+		err = verify_compat_iovec(msg_sys, iov,
+					  (struct sockaddr *)&address,
+					  VERIFY_READ);
+	} else
+		err = verify_iovec(msg_sys, iov,
+				   (struct sockaddr *)&address,
+				   VERIFY_READ);
+	if (err < 0)
+		goto out_freeiov;
+	total_len = err;
+
+	err = -ENOBUFS;
+
+	if (msg_sys->msg_controllen > INT_MAX)
+		goto out_freeiov;
+	ctl_len = msg_sys->msg_controllen;
+	if ((MSG_CMSG_COMPAT & flags) && ctl_len) {
+		err =
+		    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,
+						     sizeof(ctl));
+		if (err)
+			goto out_freeiov;
+		ctl_buf = msg_sys->msg_control;
+		ctl_len = msg_sys->msg_controllen;
+	} else if (ctl_len) {
+		if (ctl_len > sizeof(ctl)) {
+			ctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);
+			if (ctl_buf == NULL)
+				goto out_freeiov;
+		}
+		err = -EFAULT;
+		/*
+		 * Careful! Before this, msg_sys->msg_control contains a user pointer.
+		 * Afterwards, it will be a kernel pointer. Thus the compiler-assisted
+		 * checking falls down on this.
+		 */
+		if (copy_from_user(ctl_buf,
+				   (void __user __force *)msg_sys->msg_control,
+				   ctl_len))
+			goto out_freectl;
+		msg_sys->msg_control = ctl_buf;
+	}
+	msg_sys->msg_flags = flags;
+
+	if (sock->file->f_flags & O_NONBLOCK)
+		msg_sys->msg_flags |= MSG_DONTWAIT;
+	err = (nosec ? sock_sendmsg_nosec : sock_sendmsg)(sock, msg_sys,
+							  total_len);
+
+out_freectl:
+	if (ctl_buf != ctl)
+		sock_kfree_s(sock->sk, ctl_buf, ctl_len);
+out_freeiov:
+	if (iov != iovstack)
+		sock_kfree_s(sock->sk, iov, iov_size);
+out:
+	return err;
+}
+
+/*
+ *	BSD sendmsg interface
+ */
+
+SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned, flags)
+{
+	int fput_needed, err;
+	struct msghdr msg_sys;
+	struct socket *sock = sockfd_lookup_light(fd, &err, &fput_needed);
+
+	if (!sock)
+		goto out;
+
+	err = __sys_sendmsg(sock, msg, &msg_sys, flags, 0);
+
+	fput_light(sock->file, fput_needed);
+out:
+	return err;
+}
+
+/*
+ *	Linux sendmmsg interface
+ */
+
+int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
+		   unsigned int flags)
+{
+	int fput_needed, err, datagrams;
+	struct socket *sock;
+	struct mmsghdr __user *entry;
+	struct compat_mmsghdr __user *compat_entry;
+	struct msghdr msg_sys;
+
+	datagrams = 0;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (!sock)
+		return err;
+
+	err = sock_error(sock->sk);
+	if (err)
+		goto out_put;
+
+	entry = mmsg;
+	compat_entry = (struct compat_mmsghdr __user *)mmsg;
+
+	while (datagrams < vlen) {
+		/*
+		 * No need to ask LSM for more than the first datagram.
+		 */
+		if (MSG_CMSG_COMPAT & flags) {
+			err = __sys_sendmsg(sock, (struct msghdr __user *)compat_entry,
+					    &msg_sys, flags, datagrams);
+			if (err < 0)
+				break;
+			err = __put_user(err, &compat_entry->msg_len);
+			++compat_entry;
+		} else {
+			err = __sys_sendmsg(sock, (struct msghdr __user *)entry,
+					    &msg_sys, flags, datagrams);
+			if (err < 0)
+				break;
+			err = put_user(err, &entry->msg_len);
+			++entry;
+		}
+
+		if (err)
+			break;
+		++datagrams;
+	}
+
+out_put:
+	fput_light(sock->file, fput_needed);
+
+	if (err == 0)
+		return datagrams;
+
+	if (datagrams != 0) {
+		/*
+		 * We may send less entries than requested (vlen) if the
+		 * sock is non blocking...
+		 */
+		if (err != -EAGAIN) {
+			/*
+			 * ... or if sendmsg returns an error after we
+			 * send some datagrams, where we record the
+			 * error to return on the next call or if the
+			 * app asks about it using getsockopt(SO_ERROR).
+			 */
+			sock->sk->sk_err = -err;
+		}
+
+		return datagrams;
+	}
+
+	return err;
+}
+
+SYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg,
+		unsigned int, vlen, unsigned int, flags)
+{
+	return __sys_sendmmsg(fd, mmsg, vlen, flags);
+}
+
+static int __sys_recvmsg(struct socket *sock, struct msghdr __user *msg,
+			 struct msghdr *msg_sys, unsigned flags, int nosec)
+{
+	struct compat_msghdr __user *msg_compat =
+	    (struct compat_msghdr __user *)msg;
+	struct iovec iovstack[UIO_FASTIOV];
+	struct iovec *iov = iovstack;
+	unsigned long cmsg_ptr;
+	int err, iov_size, total_len, len;
+
+	/* kernel mode address */
+	struct sockaddr_storage addr;
+
+	/* user mode address pointers */
+	struct sockaddr __user *uaddr;
+	int __user *uaddr_len;
+
+	if (MSG_CMSG_COMPAT & flags) {
+		if (get_compat_msghdr(msg_sys, msg_compat))
+			return -EFAULT;
+	} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))
+		return -EFAULT;
+
+	err = -EMSGSIZE;
+	if (msg_sys->msg_iovlen > UIO_MAXIOV)
+		goto out;
+
+	/* Check whether to allocate the iovec area */
+	err = -ENOMEM;
+	iov_size = msg_sys->msg_iovlen * sizeof(struct iovec);
+	if (msg_sys->msg_iovlen > UIO_FASTIOV) {
+		iov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);
+		if (!iov)
+			goto out;
+	}
+
+	/*
+	 *      Save the user-mode address (verify_iovec will change the
+	 *      kernel msghdr to use the kernel address space)
+	 */
+
+	uaddr = (__force void __user *)msg_sys->msg_name;
+	uaddr_len = COMPAT_NAMELEN(msg);
+	if (MSG_CMSG_COMPAT & flags) {
+		err = verify_compat_iovec(msg_sys, iov,
+					  (struct sockaddr *)&addr,
+					  VERIFY_WRITE);
+	} else
+		err = verify_iovec(msg_sys, iov,
+				   (struct sockaddr *)&addr,
+				   VERIFY_WRITE);
+	if (err < 0)
+		goto out_freeiov;
+	total_len = err;
+
+	cmsg_ptr = (unsigned long)msg_sys->msg_control;
+	msg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);
+
+	if (sock->file->f_flags & O_NONBLOCK)
+		flags |= MSG_DONTWAIT;
+	err = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,
+							  total_len, flags);
+	if (err < 0)
+		goto out_freeiov;
+	len = err;
+
+	if (uaddr != NULL) {
+		err = move_addr_to_user((struct sockaddr *)&addr,
+					msg_sys->msg_namelen, uaddr,
+					uaddr_len);
+		if (err < 0)
+			goto out_freeiov;
+	}
+	err = __put_user((msg_sys->msg_flags & ~MSG_CMSG_COMPAT),
+			 COMPAT_FLAGS(msg));
+	if (err)
+		goto out_freeiov;
+	if (MSG_CMSG_COMPAT & flags)
+		err = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,
+				 &msg_compat->msg_controllen);
+	else
+		err = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,
+				 &msg->msg_controllen);
+	if (err)
+		goto out_freeiov;
+	err = len;
+
+out_freeiov:
+	if (iov != iovstack)
+		sock_kfree_s(sock->sk, iov, iov_size);
+out:
+	return err;
+}
+
+/*
+ *	BSD recvmsg interface
+ */
+
+SYSCALL_DEFINE3(recvmsg, int, fd, struct msghdr __user *, msg,
+		unsigned int, flags)
+{
+	int fput_needed, err;
+	struct msghdr msg_sys;
+	struct socket *sock = sockfd_lookup_light(fd, &err, &fput_needed);
+
+	if (!sock)
+		goto out;
+
+	err = __sys_recvmsg(sock, msg, &msg_sys, flags, 0);
+
+	fput_light(sock->file, fput_needed);
+out:
+	return err;
+}
+
+/*
+ *     Linux recvmmsg interface
+ */
+
+int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
+		   unsigned int flags, struct timespec *timeout)
+{
+	int fput_needed, err, datagrams;
+	struct socket *sock;
+	struct mmsghdr __user *entry;
+	struct compat_mmsghdr __user *compat_entry;
+	struct msghdr msg_sys;
+	struct timespec end_time;
+
+	if (timeout &&
+	    poll_select_set_timeout(&end_time, timeout->tv_sec,
+				    timeout->tv_nsec))
+		return -EINVAL;
+
+	datagrams = 0;
+
+	sock = sockfd_lookup_light(fd, &err, &fput_needed);
+	if (!sock)
+		return err;
+
+	err = sock_error(sock->sk);
+	if (err)
+		goto out_put;
+
+	entry = mmsg;
+	compat_entry = (struct compat_mmsghdr __user *)mmsg;
+
+	while (datagrams < vlen) {
+		/*
+		 * No need to ask LSM for more than the first datagram.
+		 */
+		if (MSG_CMSG_COMPAT & flags) {
+			err = __sys_recvmsg(sock, (struct msghdr __user *)compat_entry,
+					    &msg_sys, flags & ~MSG_WAITFORONE,
+					    datagrams);
+			if (err < 0)
+				break;
+			err = __put_user(err, &compat_entry->msg_len);
+			++compat_entry;
+		} else {
+			err = __sys_recvmsg(sock, (struct msghdr __user *)entry,
+					    &msg_sys, flags & ~MSG_WAITFORONE,
+					    datagrams);
+			if (err < 0)
+				break;
+			err = put_user(err, &entry->msg_len);
+			++entry;
+		}
+
+		if (err)
+			break;
+		++datagrams;
+
+		/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */
+		if (flags & MSG_WAITFORONE)
+			flags |= MSG_DONTWAIT;
+
+		if (timeout) {
+			ktime_get_ts(timeout);
+			*timeout = timespec_sub(end_time, *timeout);
+			if (timeout->tv_sec < 0) {
+				timeout->tv_sec = timeout->tv_nsec = 0;
+				break;
+			}
+
+			/* Timeout, return less than vlen datagrams */
+			if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
+				break;
+		}
+
+		/* Out of band data, return right away */
+		if (msg_sys.msg_flags & MSG_OOB)
+			break;
+	}
+
+out_put:
+	fput_light(sock->file, fput_needed);
+
+	if (err == 0)
+		return datagrams;
+
+	if (datagrams != 0) {
+		/*
+		 * We may return less entries than requested (vlen) if the
+		 * sock is non block and there aren't enough datagrams...
+		 */
+		if (err != -EAGAIN) {
+			/*
+			 * ... or  if recvmsg returns an error after we
+			 * received some datagrams, where we record the
+			 * error to return on the next call or if the
+			 * app asks about it using getsockopt(SO_ERROR).
+			 */
+			sock->sk->sk_err = -err;
+		}
+
+		return datagrams;
+	}
+
+	return err;
+}
+
+SYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,
+		unsigned int, vlen, unsigned int, flags,
+		struct timespec __user *, timeout)
+{
+	int datagrams;
+	struct timespec timeout_sys;
+
+	if (!timeout)
+		return __sys_recvmmsg(fd, mmsg, vlen, flags, NULL);
+
+	if (copy_from_user(&timeout_sys, timeout, sizeof(timeout_sys)))
+		return -EFAULT;
+
+	datagrams = __sys_recvmmsg(fd, mmsg, vlen, flags, &timeout_sys);
+
+	if (datagrams > 0 &&
+	    copy_to_user(timeout, &timeout_sys, sizeof(timeout_sys)))
+		datagrams = -EFAULT;
+
+	return datagrams;
+}
+
+#ifdef __ARCH_WANT_SYS_SOCKETCALL
+/* Argument list sizes for sys_socketcall */
+#define AL(x) ((x) * sizeof(unsigned long))
+static const unsigned char nargs[21] = {
+	AL(0), AL(3), AL(3), AL(3), AL(2), AL(3),
+	AL(3), AL(3), AL(4), AL(4), AL(4), AL(6),
+	AL(6), AL(2), AL(5), AL(5), AL(3), AL(3),
+	AL(4), AL(5), AL(4)
+};
+
+#undef AL
+
+/*
+ *	System call vectors.
+ *
+ *	Argument checking cleaned up. Saved 20% in size.
+ *  This function doesn't need to set the kernel lock because
+ *  it is set by the callees.
+ */
+
+SYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)
+{
+	unsigned long a[6];
+	unsigned long a0, a1;
+	int err;
+	unsigned int len;
+
+	if (call < 1 || call > SYS_SENDMMSG)
+		return -EINVAL;
+
+	len = nargs[call];
+	if (len > sizeof(a))
+		return -EINVAL;
+
+	/* copy_from_user should be SMP safe. */
+	if (copy_from_user(a, args, len))
+		return -EFAULT;
+
+	audit_socketcall(nargs[call] / sizeof(unsigned long), a);
+
+	a0 = a[0];
+	a1 = a[1];
+
+	switch (call) {
+	case SYS_SOCKET:
+		err = sys_socket(a0, a1, a[2]);
+		break;
+	case SYS_BIND:
+		err = sys_bind(a0, (struct sockaddr __user *)a1, a[2]);
+		break;
+	case SYS_CONNECT:
+		err = sys_connect(a0, (struct sockaddr __user *)a1, a[2]);
+		break;
+	case SYS_LISTEN:
+		err = sys_listen(a0, a1);
+		break;
+	case SYS_ACCEPT:
+		err = sys_accept4(a0, (struct sockaddr __user *)a1,
+				  (int __user *)a[2], 0);
+		break;
+	case SYS_GETSOCKNAME:
+		err =
+		    sys_getsockname(a0, (struct sockaddr __user *)a1,
+				    (int __user *)a[2]);
+		break;
+	case SYS_GETPEERNAME:
+		err =
+		    sys_getpeername(a0, (struct sockaddr __user *)a1,
+				    (int __user *)a[2]);
+		break;
+	case SYS_SOCKETPAIR:
+		err = sys_socketpair(a0, a1, a[2], (int __user *)a[3]);
+		break;
+	case SYS_SEND:
+		err = sys_send(a0, (void __user *)a1, a[2], a[3]);
+		break;
+	case SYS_SENDTO:
+		err = sys_sendto(a0, (void __user *)a1, a[2], a[3],
+				 (struct sockaddr __user *)a[4], a[5]);
+		break;
+	case SYS_RECV:
+		err = sys_recv(a0, (void __user *)a1, a[2], a[3]);
+		break;
+	case SYS_RECVFROM:
+		err = sys_recvfrom(a0, (void __user *)a1, a[2], a[3],
+				   (struct sockaddr __user *)a[4],
+				   (int __user *)a[5]);
+		break;
+	case SYS_SHUTDOWN:
+		err = sys_shutdown(a0, a1);
+		break;
+	case SYS_SETSOCKOPT:
+		err = sys_setsockopt(a0, a1, a[2], (char __user *)a[3], a[4]);
+		break;
+	case SYS_GETSOCKOPT:
+		err =
+		    sys_getsockopt(a0, a1, a[2], (char __user *)a[3],
+				   (int __user *)a[4]);
+		break;
+	case SYS_SENDMSG:
+		err = sys_sendmsg(a0, (struct msghdr __user *)a1, a[2]);
+		break;
+	case SYS_SENDMMSG:
+		err = sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3]);
+		break;
+	case SYS_RECVMSG:
+		err = sys_recvmsg(a0, (struct msghdr __user *)a1, a[2]);
+		break;
+	case SYS_RECVMMSG:
+		err = sys_recvmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3],
+				   (struct timespec __user *)a[4]);
+		break;
+	case SYS_ACCEPT4:
+		err = sys_accept4(a0, (struct sockaddr __user *)a1,
+				  (int __user *)a[2], a[3]);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	return err;
+}
+
+#endif				/* __ARCH_WANT_SYS_SOCKETCALL */
+
+/**
+ *	sock_register - add a socket protocol handler
+ *	@ops: description of protocol
+ *
+ *	This function is called by a protocol handler that wants to
+ *	advertise its address family, and have it linked into the
+ *	socket interface. The value ops->family coresponds to the
+ *	socket system call protocol family.
+ */
+int sock_register(const struct net_proto_family *ops)
+{
+	int err;
+
+	if (ops->family >= NPROTO) {
+		printk(KERN_CRIT "protocol %d >= NPROTO(%d)\n", ops->family,
+		       NPROTO);
+		return -ENOBUFS;
+	}
+
+	spin_lock(&net_family_lock);
+	if (rcu_dereference_protected(net_families[ops->family],
+				      lockdep_is_held(&net_family_lock)))
+		err = -EEXIST;
+	else {
+		rcu_assign_pointer(net_families[ops->family], ops);
+		err = 0;
+	}
+	spin_unlock(&net_family_lock);
+
+	printk(KERN_INFO "NET: Registered protocol family %d\n", ops->family);
+	return err;
+}
+EXPORT_SYMBOL(sock_register);
+
+/**
+ *	sock_unregister - remove a protocol handler
+ *	@family: protocol family to remove
+ *
+ *	This function is called by a protocol handler that wants to
+ *	remove its address family, and have it unlinked from the
+ *	new socket creation.
+ *
+ *	If protocol handler is a module, then it can use module reference
+ *	counts to protect against new references. If protocol handler is not
+ *	a module then it needs to provide its own protection in
+ *	the ops->create routine.
+ */
+void sock_unregister(int family)
+{
+	BUG_ON(family < 0 || family >= NPROTO);
+
+	spin_lock(&net_family_lock);
+	rcu_assign_pointer(net_families[family], NULL);
+	spin_unlock(&net_family_lock);
+
+	synchronize_rcu();
+
+	printk(KERN_INFO "NET: Unregistered protocol family %d\n", family);
+}
+EXPORT_SYMBOL(sock_unregister);
+
+static int __init sock_init(void)
+{
+	int err;
+
+	/*
+	 *      Initialize sock SLAB cache.
+	 */
+
+	sk_init();
+
+	/*
+	 *      Initialize skbuff SLAB cache
+	 */
+	skb_init();
+
+	/*
+	 *      Initialize the protocols module.
+	 */
+
+	init_inodecache();
+
+	err = register_filesystem(&sock_fs_type);
+	if (err)
+		goto out_fs;
+	sock_mnt = kern_mount(&sock_fs_type);
+	if (IS_ERR(sock_mnt)) {
+		err = PTR_ERR(sock_mnt);
+		goto out_mount;
+	}
+
+	/* The real protocol initialization is performed in later initcalls.
+	 */
+
+#ifdef CONFIG_NETFILTER
+	netfilter_init();
+#endif
+
+#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING
+	skb_timestamping_init();
+#endif
+
+out:
+	return err;
+
+out_mount:
+	unregister_filesystem(&sock_fs_type);
+out_fs:
+	goto out;
+}
+
+core_initcall(sock_init);	/* early initcall */
+
+#ifdef CONFIG_PROC_FS
+void socket_seq_show(struct seq_file *seq)
+{
+	int cpu;
+	int counter = 0;
+
+	for_each_possible_cpu(cpu)
+	    counter += per_cpu(sockets_in_use, cpu);
+
+	/* It can be negative, by the way. 8) */
+	if (counter < 0)
+		counter = 0;
+
+	seq_printf(seq, "sockets: used %d\n", counter);
+}
+#endif				/* CONFIG_PROC_FS */
+
+#ifdef CONFIG_COMPAT
+static int do_siocgstamp(struct net *net, struct socket *sock,
+			 unsigned int cmd, struct compat_timeval __user *up)
+{
+	mm_segment_t old_fs = get_fs();
+	struct timeval ktv;
+	int err;
+
+	set_fs(KERNEL_DS);
+	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);
+	set_fs(old_fs);
+	if (!err) {
+		err = put_user(ktv.tv_sec, &up->tv_sec);
+		err |= __put_user(ktv.tv_usec, &up->tv_usec);
+	}
+	return err;
+}
+
+static int do_siocgstampns(struct net *net, struct socket *sock,
+			 unsigned int cmd, struct compat_timespec __user *up)
+{
+	mm_segment_t old_fs = get_fs();
+	struct timespec kts;
+	int err;
+
+	set_fs(KERNEL_DS);
+	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);
+	set_fs(old_fs);
+	if (!err) {
+		err = put_user(kts.tv_sec, &up->tv_sec);
+		err |= __put_user(kts.tv_nsec, &up->tv_nsec);
+	}
+	return err;
+}
+
+static int dev_ifname32(struct net *net, struct compat_ifreq __user *uifr32)
+{
+	struct ifreq __user *uifr;
+	int err;
+
+	uifr = compat_alloc_user_space(sizeof(struct ifreq));
+	if (copy_in_user(uifr, uifr32, sizeof(struct compat_ifreq)))
+		return -EFAULT;
+
+	err = dev_ioctl(net, SIOCGIFNAME, uifr);
+	if (err)
+		return err;
+
+	if (copy_in_user(uifr32, uifr, sizeof(struct compat_ifreq)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int dev_ifconf(struct net *net, struct compat_ifconf __user *uifc32)
+{
+	struct compat_ifconf ifc32;
+	struct ifconf ifc;
+	struct ifconf __user *uifc;
+	struct compat_ifreq __user *ifr32;
+	struct ifreq __user *ifr;
+	unsigned int i, j;
+	int err;
+
+	if (copy_from_user(&ifc32, uifc32, sizeof(struct compat_ifconf)))
+		return -EFAULT;
+
+	if (ifc32.ifcbuf == 0) {
+		ifc32.ifc_len = 0;
+		ifc.ifc_len = 0;
+		ifc.ifc_req = NULL;
+		uifc = compat_alloc_user_space(sizeof(struct ifconf));
+	} else {
+		size_t len = ((ifc32.ifc_len / sizeof(struct compat_ifreq)) + 1) *
+			sizeof(struct ifreq);
+		uifc = compat_alloc_user_space(sizeof(struct ifconf) + len);
+		ifc.ifc_len = len;
+		ifr = ifc.ifc_req = (void __user *)(uifc + 1);
+		ifr32 = compat_ptr(ifc32.ifcbuf);
+		for (i = 0; i < ifc32.ifc_len; i += sizeof(struct compat_ifreq)) {
+			if (copy_in_user(ifr, ifr32, sizeof(struct compat_ifreq)))
+				return -EFAULT;
+			ifr++;
+			ifr32++;
+		}
+	}
+	if (copy_to_user(uifc, &ifc, sizeof(struct ifconf)))
+		return -EFAULT;
+
+	err = dev_ioctl(net, SIOCGIFCONF, uifc);
+	if (err)
+		return err;
+
+	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))
+		return -EFAULT;
+
+	ifr = ifc.ifc_req;
+	ifr32 = compat_ptr(ifc32.ifcbuf);
+	for (i = 0, j = 0;
+	     i + sizeof(struct compat_ifreq) <= ifc32.ifc_len && j < ifc.ifc_len;
+	     i += sizeof(struct compat_ifreq), j += sizeof(struct ifreq)) {
+		if (copy_in_user(ifr32, ifr, sizeof(struct compat_ifreq)))
+			return -EFAULT;
+		ifr32++;
+		ifr++;
+	}
+
+	if (ifc32.ifcbuf == 0) {
+		/* Translate from 64-bit structure multiple to
+		 * a 32-bit one.
+		 */
+		i = ifc.ifc_len;
+		i = ((i / sizeof(struct ifreq)) * sizeof(struct compat_ifreq));
+		ifc32.ifc_len = i;
+	} else {
+		ifc32.ifc_len = i;
+	}
+	if (copy_to_user(uifc32, &ifc32, sizeof(struct compat_ifconf)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int ethtool_ioctl(struct net *net, struct compat_ifreq __user *ifr32)
+{
+	struct compat_ethtool_rxnfc __user *compat_rxnfc;
+	bool convert_in = false, convert_out = false;
+	size_t buf_size = ALIGN(sizeof(struct ifreq), 8);
+	struct ethtool_rxnfc __user *rxnfc;
+	struct ifreq __user *ifr;
+	u32 rule_cnt = 0, actual_rule_cnt;
+	u32 ethcmd;
+	u32 data;
+	int ret;
+
+	if (get_user(data, &ifr32->ifr_ifru.ifru_data))
+		return -EFAULT;
+
+	compat_rxnfc = compat_ptr(data);
+
+	if (get_user(ethcmd, &compat_rxnfc->cmd))
+		return -EFAULT;
+
+	/* Most ethtool structures are defined without padding.
+	 * Unfortunately struct ethtool_rxnfc is an exception.
+	 */
+	switch (ethcmd) {
+	default:
+		break;
+	case ETHTOOL_GRXCLSRLALL:
+		/* Buffer size is variable */
+		if (get_user(rule_cnt, &compat_rxnfc->rule_cnt))
+			return -EFAULT;
+		if (rule_cnt > KMALLOC_MAX_SIZE / sizeof(u32))
+			return -ENOMEM;
+		buf_size += rule_cnt * sizeof(u32);
+		/* fall through */
+	case ETHTOOL_GRXRINGS:
+	case ETHTOOL_GRXCLSRLCNT:
+	case ETHTOOL_GRXCLSRULE:
+		convert_out = true;
+		/* fall through */
+	case ETHTOOL_SRXCLSRLDEL:
+	case ETHTOOL_SRXCLSRLINS:
+		buf_size += sizeof(struct ethtool_rxnfc);
+		convert_in = true;
+		break;
+	}
+
+	ifr = compat_alloc_user_space(buf_size);
+	rxnfc = (void *)ifr + ALIGN(sizeof(struct ifreq), 8);
+
+	if (copy_in_user(&ifr->ifr_name, &ifr32->ifr_name, IFNAMSIZ))
+		return -EFAULT;
+
+	if (put_user(convert_in ? rxnfc : compat_ptr(data),
+		     &ifr->ifr_ifru.ifru_data))
+		return -EFAULT;
+
+	if (convert_in) {
+		/* We expect there to be holes between fs.m_ext and
+		 * fs.ring_cookie and at the end of fs, but nowhere else.
+		 */
+		BUILD_BUG_ON(offsetof(struct compat_ethtool_rxnfc, fs.m_ext) +
+			     sizeof(compat_rxnfc->fs.m_ext) !=
+			     offsetof(struct ethtool_rxnfc, fs.m_ext) +
+			     sizeof(rxnfc->fs.m_ext));
+		BUILD_BUG_ON(
+			offsetof(struct compat_ethtool_rxnfc, fs.location) -
+			offsetof(struct compat_ethtool_rxnfc, fs.ring_cookie) !=
+			offsetof(struct ethtool_rxnfc, fs.location) -
+			offsetof(struct ethtool_rxnfc, fs.ring_cookie));
+
+		if (copy_in_user(rxnfc, compat_rxnfc,
+				 (void *)(&rxnfc->fs.m_ext + 1) -
+				 (void *)rxnfc) ||
+		    copy_in_user(&rxnfc->fs.ring_cookie,
+				 &compat_rxnfc->fs.ring_cookie,
+				 (void *)(&rxnfc->fs.location + 1) -
+				 (void *)&rxnfc->fs.ring_cookie) ||
+		    copy_in_user(&rxnfc->rule_cnt, &compat_rxnfc->rule_cnt,
+				 sizeof(rxnfc->rule_cnt)))
+			return -EFAULT;
+	}
+
+	ret = dev_ioctl(net, SIOCETHTOOL, ifr);
+	if (ret)
+		return ret;
+
+	if (convert_out) {
+		if (copy_in_user(compat_rxnfc, rxnfc,
+				 (const void *)(&rxnfc->fs.m_ext + 1) -
+				 (const void *)rxnfc) ||
+		    copy_in_user(&compat_rxnfc->fs.ring_cookie,
+				 &rxnfc->fs.ring_cookie,
+				 (const void *)(&rxnfc->fs.location + 1) -
+				 (const void *)&rxnfc->fs.ring_cookie) ||
+		    copy_in_user(&compat_rxnfc->rule_cnt, &rxnfc->rule_cnt,
+				 sizeof(rxnfc->rule_cnt)))
+			return -EFAULT;
+
+		if (ethcmd == ETHTOOL_GRXCLSRLALL) {
+			/* As an optimisation, we only copy the actual
+			 * number of rules that the underlying
+			 * function returned.  Since Mallory might
+			 * change the rule count in user memory, we
+			 * check that it is less than the rule count
+			 * originally given (as the user buffer size),
+			 * which has been range-checked.
+			 */
+			if (get_user(actual_rule_cnt, &rxnfc->rule_cnt))
+				return -EFAULT;
+			if (actual_rule_cnt < rule_cnt)
+				rule_cnt = actual_rule_cnt;
+			if (copy_in_user(&compat_rxnfc->rule_locs[0],
+					 &rxnfc->rule_locs[0],
+					 rule_cnt * sizeof(u32)))
+				return -EFAULT;
+		}
+	}
+
+	return 0;
+}
+
+static int compat_siocwandev(struct net *net, struct compat_ifreq __user *uifr32)
+{
+	void __user *uptr;
+	compat_uptr_t uptr32;
+	struct ifreq __user *uifr;
+
+	uifr = compat_alloc_user_space(sizeof(*uifr));
+	if (copy_in_user(uifr, uifr32, sizeof(struct compat_ifreq)))
+		return -EFAULT;
+
+	if (get_user(uptr32, &uifr32->ifr_settings.ifs_ifsu))
+		return -EFAULT;
+
+	uptr = compat_ptr(uptr32);
+
+	if (put_user(uptr, &uifr->ifr_settings.ifs_ifsu.raw_hdlc))
+		return -EFAULT;
+
+	return dev_ioctl(net, SIOCWANDEV, uifr);
+}
+
+static int bond_ioctl(struct net *net, unsigned int cmd,
+			 struct compat_ifreq __user *ifr32)
+{
+	struct ifreq kifr;
+	struct ifreq __user *uifr;
+	mm_segment_t old_fs;
+	int err;
+	u32 data;
+	void __user *datap;
+
+	switch (cmd) {
+	case SIOCBONDENSLAVE:
+	case SIOCBONDRELEASE:
+	case SIOCBONDSETHWADDR:
+	case SIOCBONDCHANGEACTIVE:
+		if (copy_from_user(&kifr, ifr32, sizeof(struct compat_ifreq)))
+			return -EFAULT;
+
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		err = dev_ioctl(net, cmd,
+				(struct ifreq __user __force *) &kifr);
+		set_fs(old_fs);
+
+		return err;
+	case SIOCBONDSLAVEINFOQUERY:
+	case SIOCBONDINFOQUERY:
+		uifr = compat_alloc_user_space(sizeof(*uifr));
+		if (copy_in_user(&uifr->ifr_name, &ifr32->ifr_name, IFNAMSIZ))
+			return -EFAULT;
+
+		if (get_user(data, &ifr32->ifr_ifru.ifru_data))
+			return -EFAULT;
+
+		datap = compat_ptr(data);
+		if (put_user(datap, &uifr->ifr_ifru.ifru_data))
+			return -EFAULT;
+
+		return dev_ioctl(net, cmd, uifr);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int siocdevprivate_ioctl(struct net *net, unsigned int cmd,
+				 struct compat_ifreq __user *u_ifreq32)
+{
+	struct ifreq __user *u_ifreq64;
+	char tmp_buf[IFNAMSIZ];
+	void __user *data64;
+	u32 data32;
+
+	if (copy_from_user(&tmp_buf[0], &(u_ifreq32->ifr_ifrn.ifrn_name[0]),
+			   IFNAMSIZ))
+		return -EFAULT;
+	if (__get_user(data32, &u_ifreq32->ifr_ifru.ifru_data))
+		return -EFAULT;
+	data64 = compat_ptr(data32);
+
+	u_ifreq64 = compat_alloc_user_space(sizeof(*u_ifreq64));
+
+	/* Don't check these user accesses, just let that get trapped
+	 * in the ioctl handler instead.
+	 */
+	if (copy_to_user(&u_ifreq64->ifr_ifrn.ifrn_name[0], &tmp_buf[0],
+			 IFNAMSIZ))
+		return -EFAULT;
+	if (__put_user(data64, &u_ifreq64->ifr_ifru.ifru_data))
+		return -EFAULT;
+
+	return dev_ioctl(net, cmd, u_ifreq64);
+}
+
+static int dev_ifsioc(struct net *net, struct socket *sock,
+			 unsigned int cmd, struct compat_ifreq __user *uifr32)
+{
+	struct ifreq __user *uifr;
+	int err;
+
+	uifr = compat_alloc_user_space(sizeof(*uifr));
+	if (copy_in_user(uifr, uifr32, sizeof(*uifr32)))
+		return -EFAULT;
+
+	err = sock_do_ioctl(net, sock, cmd, (unsigned long)uifr);
+
+	if (!err) {
+		switch (cmd) {
+		case SIOCGIFFLAGS:
+		case SIOCGIFMETRIC:
+		case SIOCGIFMTU:
+		case SIOCGIFMEM:
+		case SIOCGIFHWADDR:
+		case SIOCGIFINDEX:
+		case SIOCGIFADDR:
+		case SIOCGIFBRDADDR:
+		case SIOCGIFDSTADDR:
+		case SIOCGIFNETMASK:
+		case SIOCGIFPFLAGS:
+		case SIOCGIFTXQLEN:
+		case SIOCGMIIPHY:
+		case SIOCGMIIREG:
+			if (copy_in_user(uifr32, uifr, sizeof(*uifr32)))
+				err = -EFAULT;
+			break;
+		}
+	}
+	return err;
+}
+
+static int compat_sioc_ifmap(struct net *net, unsigned int cmd,
+			struct compat_ifreq __user *uifr32)
+{
+	struct ifreq ifr;
+	struct compat_ifmap __user *uifmap32;
+	mm_segment_t old_fs;
+	int err;
+
+	uifmap32 = &uifr32->ifr_ifru.ifru_map;
+	err = copy_from_user(&ifr, uifr32, sizeof(ifr.ifr_name));
+	err |= __get_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);
+	err |= __get_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);
+	err |= __get_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);
+	err |= __get_user(ifr.ifr_map.irq, &uifmap32->irq);
+	err |= __get_user(ifr.ifr_map.dma, &uifmap32->dma);
+	err |= __get_user(ifr.ifr_map.port, &uifmap32->port);
+	if (err)
+		return -EFAULT;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	err = dev_ioctl(net, cmd, (void  __user __force *)&ifr);
+	set_fs(old_fs);
+
+	if (cmd == SIOCGIFMAP && !err) {
+		err = copy_to_user(uifr32, &ifr, sizeof(ifr.ifr_name));
+		err |= __put_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);
+		err |= __put_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);
+		err |= __put_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);
+		err |= __put_user(ifr.ifr_map.irq, &uifmap32->irq);
+		err |= __put_user(ifr.ifr_map.dma, &uifmap32->dma);
+		err |= __put_user(ifr.ifr_map.port, &uifmap32->port);
+		if (err)
+			err = -EFAULT;
+	}
+	return err;
+}
+
+static int compat_siocshwtstamp(struct net *net, struct compat_ifreq __user *uifr32)
+{
+	void __user *uptr;
+	compat_uptr_t uptr32;
+	struct ifreq __user *uifr;
+
+	uifr = compat_alloc_user_space(sizeof(*uifr));
+	if (copy_in_user(uifr, uifr32, sizeof(struct compat_ifreq)))
+		return -EFAULT;
+
+	if (get_user(uptr32, &uifr32->ifr_data))
+		return -EFAULT;
+
+	uptr = compat_ptr(uptr32);
+
+	if (put_user(uptr, &uifr->ifr_data))
+		return -EFAULT;
+
+	return dev_ioctl(net, SIOCSHWTSTAMP, uifr);
+}
+
+struct rtentry32 {
+	u32		rt_pad1;
+	struct sockaddr rt_dst;         /* target address               */
+	struct sockaddr rt_gateway;     /* gateway addr (RTF_GATEWAY)   */
+	struct sockaddr rt_genmask;     /* target network mask (IP)     */
+	unsigned short	rt_flags;
+	short		rt_pad2;
+	u32		rt_pad3;
+	unsigned char	rt_tos;
+	unsigned char	rt_class;
+	short		rt_pad4;
+	short		rt_metric;      /* +1 for binary compatibility! */
+	/* char * */ u32 rt_dev;        /* forcing the device at add    */
+	u32		rt_mtu;         /* per route MTU/Window         */
+	u32		rt_window;      /* Window clamping              */
+	unsigned short  rt_irtt;        /* Initial RTT                  */
+};
+
+struct in6_rtmsg32 {
+	struct in6_addr		rtmsg_dst;
+	struct in6_addr		rtmsg_src;
+	struct in6_addr		rtmsg_gateway;
+	u32			rtmsg_type;
+	u16			rtmsg_dst_len;
+	u16			rtmsg_src_len;
+	u32			rtmsg_metric;
+	u32			rtmsg_info;
+	u32			rtmsg_flags;
+	s32			rtmsg_ifindex;
+};
+
+static int routing_ioctl(struct net *net, struct socket *sock,
+			 unsigned int cmd, void __user *argp)
+{
+	int ret;
+	void *r = NULL;
+	struct in6_rtmsg r6;
+	struct rtentry r4;
+	char devname[16];
+	u32 rtdev;
+	mm_segment_t old_fs = get_fs();
+
+	if (sock && sock->sk && sock->sk->sk_family == AF_INET6) { /* ipv6 */
+		struct in6_rtmsg32 __user *ur6 = argp;
+		ret = copy_from_user(&r6.rtmsg_dst, &(ur6->rtmsg_dst),
+			3 * sizeof(struct in6_addr));
+		ret |= __get_user(r6.rtmsg_type, &(ur6->rtmsg_type));
+		ret |= __get_user(r6.rtmsg_dst_len, &(ur6->rtmsg_dst_len));
+		ret |= __get_user(r6.rtmsg_src_len, &(ur6->rtmsg_src_len));
+		ret |= __get_user(r6.rtmsg_metric, &(ur6->rtmsg_metric));
+		ret |= __get_user(r6.rtmsg_info, &(ur6->rtmsg_info));
+		ret |= __get_user(r6.rtmsg_flags, &(ur6->rtmsg_flags));
+		ret |= __get_user(r6.rtmsg_ifindex, &(ur6->rtmsg_ifindex));
+
+		r = (void *) &r6;
+	} else { /* ipv4 */
+		struct rtentry32 __user *ur4 = argp;
+		ret = copy_from_user(&r4.rt_dst, &(ur4->rt_dst),
+					3 * sizeof(struct sockaddr));
+		ret |= __get_user(r4.rt_flags, &(ur4->rt_flags));
+		ret |= __get_user(r4.rt_metric, &(ur4->rt_metric));
+		ret |= __get_user(r4.rt_mtu, &(ur4->rt_mtu));
+		ret |= __get_user(r4.rt_window, &(ur4->rt_window));
+		ret |= __get_user(r4.rt_irtt, &(ur4->rt_irtt));
+		ret |= __get_user(rtdev, &(ur4->rt_dev));
+		if (rtdev) {
+			ret |= copy_from_user(devname, compat_ptr(rtdev), 15);
+			r4.rt_dev = (char __user __force *)devname;
+			devname[15] = 0;
+		} else
+			r4.rt_dev = NULL;
+
+		r = (void *) &r4;
+	}
+
+	if (ret) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	set_fs(KERNEL_DS);
+	ret = sock_do_ioctl(net, sock, cmd, (unsigned long) r);
+	set_fs(old_fs);
+
+out:
+	return ret;
+}
+
+/* Since old style bridge ioctl's endup using SIOCDEVPRIVATE
+ * for some operations; this forces use of the newer bridge-utils that
+ * use compatible ioctls
+ */
+static int old_bridge_ioctl(compat_ulong_t __user *argp)
+{
+	compat_ulong_t tmp;
+
+	if (get_user(tmp, argp))
+		return -EFAULT;
+	if (tmp == BRCTL_GET_VERSION)
+		return BRCTL_VERSION + 1;
+	return -EINVAL;
+}
+
+static int compat_sock_ioctl_trans(struct file *file, struct socket *sock,
+			 unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = compat_ptr(arg);
+	struct sock *sk = sock->sk;
+	struct net *net = sock_net(sk);
+
+	if (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))
+		return siocdevprivate_ioctl(net, cmd, argp);
+
+	switch (cmd) {
+	case SIOCSIFBR:
+	case SIOCGIFBR:
+		return old_bridge_ioctl(argp);
+	case SIOCGIFNAME:
+		return dev_ifname32(net, argp);
+	case SIOCGIFCONF:
+		return dev_ifconf(net, argp);
+	case SIOCETHTOOL:
+		return ethtool_ioctl(net, argp);
+	case SIOCWANDEV:
+		return compat_siocwandev(net, argp);
+	case SIOCGIFMAP:
+	case SIOCSIFMAP:
+		return compat_sioc_ifmap(net, cmd, argp);
+	case SIOCBONDENSLAVE:
+	case SIOCBONDRELEASE:
+	case SIOCBONDSETHWADDR:
+	case SIOCBONDSLAVEINFOQUERY:
+	case SIOCBONDINFOQUERY:
+	case SIOCBONDCHANGEACTIVE:
+		return bond_ioctl(net, cmd, argp);
+	case SIOCADDRT:
+	case SIOCDELRT:
+		return routing_ioctl(net, sock, cmd, argp);
+	case SIOCGSTAMP:
+		return do_siocgstamp(net, sock, cmd, argp);
+	case SIOCGSTAMPNS:
+		return do_siocgstampns(net, sock, cmd, argp);
+	case SIOCSHWTSTAMP:
+		return compat_siocshwtstamp(net, argp);
+
+	case FIOSETOWN:
+	case SIOCSPGRP:
+	case FIOGETOWN:
+	case SIOCGPGRP:
+	case SIOCBRADDBR:
+	case SIOCBRDELBR:
+	case SIOCGIFVLAN:
+	case SIOCSIFVLAN:
+	case SIOCADDDLCI:
+	case SIOCDELDLCI:
+		return sock_ioctl(file, cmd, arg);
+
+	case SIOCGIFFLAGS:
+	case SIOCSIFFLAGS:
+	case SIOCGIFMETRIC:
+	case SIOCSIFMETRIC:
+	case SIOCGIFMTU:
+	case SIOCSIFMTU:
+	case SIOCGIFMEM:
+	case SIOCSIFMEM:
+	case SIOCGIFHWADDR:
+	case SIOCSIFHWADDR:
+	case SIOCADDMULTI:
+	case SIOCDELMULTI:
+	case SIOCGIFINDEX:
+	case SIOCGIFADDR:
+	case SIOCSIFADDR:
+	case SIOCSIFHWBROADCAST:
+	case SIOCDIFADDR:
+	case SIOCGIFBRDADDR:
+	case SIOCSIFBRDADDR:
+	case SIOCGIFDSTADDR:
+	case SIOCSIFDSTADDR:
+	case SIOCGIFNETMASK:
+	case SIOCSIFNETMASK:
+	case SIOCSIFPFLAGS:
+	case SIOCGIFPFLAGS:
+	case SIOCGIFTXQLEN:
+	case SIOCSIFTXQLEN:
+	case SIOCBRADDIF:
+	case SIOCBRDELIF:
+	case SIOCSIFNAME:
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		return dev_ifsioc(net, sock, cmd, argp);
+
+	case SIOCSARP:
+	case SIOCGARP:
+	case SIOCDARP:
+	case SIOCATMARK:
+		return sock_do_ioctl(net, sock, cmd, arg);
+	}
+
+	/* Prevent warning from compat_sys_ioctl, these always
+	 * result in -EINVAL in the native case anyway. */
+	switch (cmd) {
+	case SIOCRTMSG:
+	case SIOCGIFCOUNT:
+	case SIOCSRARP:
+	case SIOCGRARP:
+	case SIOCDRARP:
+	case SIOCSIFLINK:
+	case SIOCGIFSLAVE:
+	case SIOCSIFSLAVE:
+		return -EINVAL;
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+static long compat_sock_ioctl(struct file *file, unsigned cmd,
+			      unsigned long arg)
+{
+	struct socket *sock = file->private_data;
+	int ret = -ENOIOCTLCMD;
+	struct sock *sk;
+	struct net *net;
+
+	sk = sock->sk;
+	net = sock_net(sk);
+
+	if (sock->ops->compat_ioctl)
+		ret = sock->ops->compat_ioctl(sock, cmd, arg);
+
+	if (ret == -ENOIOCTLCMD &&
+	    (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST))
+		ret = compat_wext_handle_ioctl(net, cmd, arg);
+
+	if (ret == -ENOIOCTLCMD)
+		ret = compat_sock_ioctl_trans(file, sock, cmd, arg);
+
+	return ret;
+}
+#endif
+
+int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)
+{
+	return sock->ops->bind(sock, addr, addrlen);
+}
+EXPORT_SYMBOL(kernel_bind);
+
+int kernel_listen(struct socket *sock, int backlog)
+{
+	return sock->ops->listen(sock, backlog);
+}
+EXPORT_SYMBOL(kernel_listen);
+
+int kernel_accept(struct socket *sock, struct socket **newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	int err;
+
+	err = sock_create_lite(sk->sk_family, sk->sk_type, sk->sk_protocol,
+			       newsock);
+	if (err < 0)
+		goto done;
+
+	err = sock->ops->accept(sock, *newsock, flags);
+	if (err < 0) {
+		sock_release(*newsock);
+		*newsock = NULL;
+		goto done;
+	}
+
+	(*newsock)->ops = sock->ops;
+	__module_get((*newsock)->ops->owner);
+
+done:
+	return err;
+}
+EXPORT_SYMBOL(kernel_accept);
+
+int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
+		   int flags)
+{
+	return sock->ops->connect(sock, addr, addrlen, flags);
+}
+EXPORT_SYMBOL(kernel_connect);
+
+int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
+			 int *addrlen)
+{
+	return sock->ops->getname(sock, addr, addrlen, 0);
+}
+EXPORT_SYMBOL(kernel_getsockname);
+
+int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
+			 int *addrlen)
+{
+	return sock->ops->getname(sock, addr, addrlen, 1);
+}
+EXPORT_SYMBOL(kernel_getpeername);
+
+int kernel_getsockopt(struct socket *sock, int level, int optname,
+			char *optval, int *optlen)
+{
+	mm_segment_t oldfs = get_fs();
+	char __user *uoptval;
+	int __user *uoptlen;
+	int err;
+
+	uoptval = (char __user __force *) optval;
+	uoptlen = (int __user __force *) optlen;
+
+	set_fs(KERNEL_DS);
+	if (level == SOL_SOCKET)
+		err = sock_getsockopt(sock, level, optname, uoptval, uoptlen);
+	else
+		err = sock->ops->getsockopt(sock, level, optname, uoptval,
+					    uoptlen);
+	set_fs(oldfs);
+	return err;
+}
+EXPORT_SYMBOL(kernel_getsockopt);
+
+int kernel_setsockopt(struct socket *sock, int level, int optname,
+			char *optval, unsigned int optlen)
+{
+	mm_segment_t oldfs = get_fs();
+	char __user *uoptval;
+	int err;
+
+	uoptval = (char __user __force *) optval;
+
+	set_fs(KERNEL_DS);
+	if (level == SOL_SOCKET)
+		err = sock_setsockopt(sock, level, optname, uoptval, optlen);
+	else
+		err = sock->ops->setsockopt(sock, level, optname, uoptval,
+					    optlen);
+	set_fs(oldfs);
+	return err;
+}
+EXPORT_SYMBOL(kernel_setsockopt);
+
+int kernel_sendpage(struct socket *sock, struct page *page, int offset,
+		    size_t size, int flags)
+{
+	sock_update_classid(sock->sk);
+
+	if (sock->ops->sendpage)
+		return sock->ops->sendpage(sock, page, offset, size, flags);
+
+	return sock_no_sendpage(sock, page, offset, size, flags);
+}
+EXPORT_SYMBOL(kernel_sendpage);
+
+int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg)
+{
+	mm_segment_t oldfs = get_fs();
+	int err;
+
+	set_fs(KERNEL_DS);
+	err = sock->ops->ioctl(sock, cmd, arg);
+	set_fs(oldfs);
+
+	return err;
+}
+EXPORT_SYMBOL(kernel_sock_ioctl);
+
+int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how)
+{
+	return sock->ops->shutdown(sock, how);
+}
+EXPORT_SYMBOL(kernel_sock_shutdown);
Binary files linux/scripts/basic/fixdep and linux-3.0/scripts/basic/fixdep differ
Binary files linux/scripts/conmakehash and linux-3.0/scripts/conmakehash differ
Binary files linux/scripts/kallsyms and linux-3.0/scripts/kallsyms differ
Binary files linux/scripts/kconfig/conf and linux-3.0/scripts/kconfig/conf differ
diff -Nurp linux/scripts/kconfig/lex.zconf.c linux-3.0/scripts/kconfig/lex.zconf.c
--- linux/scripts/kconfig/lex.zconf.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/scripts/kconfig/lex.zconf.c	2014-02-19 21:06:21.043250588 -0500
@@ -0,0 +1,2435 @@
+
+#line 3 "scripts/kconfig/lex.zconf.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *iter;
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(file->name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n",
+		    zconf_curname(), zconf_lineno(), file->name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	for (iter = current_file->parent; iter; iter = iter->parent ) {
+		if (!strcmp(current_file->name,iter->name) ) {
+			printf("%s:%d: recursive inclusion detected. "
+			       "Inclusion path:\n  current file : '%s'\n",
+			       zconf_curname(), zconf_lineno(),
+			       zconf_curname());
+			iter = current_file->parent;
+			while (iter && \
+			       strcmp(iter->name,current_file->name)) {
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno-1);
+				iter = iter->parent;
+			}
+			if (iter)
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno+1);
+			exit(1);
+		}
+	}
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+const char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
Binary files linux/scripts/kconfig/mconf and linux-3.0/scripts/kconfig/mconf differ
diff -Nurp linux/scripts/kconfig/zconf.hash.c linux-3.0/scripts/kconfig/zconf.hash.c
--- linux/scripts/kconfig/zconf.hash.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/scripts/kconfig/zconf.hash.c	2014-02-19 21:06:21.390258413 -0500
@@ -0,0 +1,245 @@
+/* ANSI-C code produced by gperf version 3.0.3 */
+/* Command-line: gperf  */
+/* Computed positions: -k'1,3' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+struct kconf_id;
+
+static struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 50, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static unsigned char asso_values[] =
+    {
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 40,  5,
+       0,  0,  5, 52,  0, 20, 52, 52, 10, 20,
+       5,  0, 35, 52,  0, 30,  0, 15,  0, 52,
+      15, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval;
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("on")];
+    char kconf_id_strings_str3[sizeof("env")];
+    char kconf_id_strings_str5[sizeof("endif")];
+    char kconf_id_strings_str6[sizeof("option")];
+    char kconf_id_strings_str7[sizeof("endmenu")];
+    char kconf_id_strings_str8[sizeof("optional")];
+    char kconf_id_strings_str9[sizeof("endchoice")];
+    char kconf_id_strings_str10[sizeof("range")];
+    char kconf_id_strings_str11[sizeof("choice")];
+    char kconf_id_strings_str12[sizeof("default")];
+    char kconf_id_strings_str13[sizeof("def_bool")];
+    char kconf_id_strings_str14[sizeof("help")];
+    char kconf_id_strings_str16[sizeof("config")];
+    char kconf_id_strings_str17[sizeof("def_tristate")];
+    char kconf_id_strings_str18[sizeof("hex")];
+    char kconf_id_strings_str19[sizeof("defconfig_list")];
+    char kconf_id_strings_str22[sizeof("if")];
+    char kconf_id_strings_str23[sizeof("int")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str28[sizeof("tristate")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str32[sizeof("comment")];
+    char kconf_id_strings_str35[sizeof("menuconfig")];
+    char kconf_id_strings_str36[sizeof("string")];
+    char kconf_id_strings_str37[sizeof("visible")];
+    char kconf_id_strings_str41[sizeof("prompt")];
+    char kconf_id_strings_str42[sizeof("depends")];
+    char kconf_id_strings_str44[sizeof("bool")];
+    char kconf_id_strings_str46[sizeof("select")];
+    char kconf_id_strings_str47[sizeof("boolean")];
+    char kconf_id_strings_str48[sizeof("mainmenu")];
+    char kconf_id_strings_str51[sizeof("source")];
+  };
+static struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "on",
+    "env",
+    "endif",
+    "option",
+    "endmenu",
+    "optional",
+    "endchoice",
+    "range",
+    "choice",
+    "default",
+    "def_bool",
+    "help",
+    "config",
+    "def_tristate",
+    "hex",
+    "defconfig_list",
+    "if",
+    "int",
+    "modules",
+    "tristate",
+    "menu",
+    "comment",
+    "menuconfig",
+    "string",
+    "visible",
+    "prompt",
+    "depends",
+    "bool",
+    "select",
+    "boolean",
+    "mainmenu",
+    "source"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 32,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 51
+    };
+
+  static struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_ON,		TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_OPT_ENV,	TF_OPTION},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str6,		T_OPTION,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_ENDMENU,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_OPTIONAL,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str10,		T_RANGE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str11,		T_CHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,		T_HELP,		TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str16,		T_CONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,		T_TYPE,		TF_COMMAND, S_HEX},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str19,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,		T_IF,		TF_COMMAND|TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,		T_TYPE,		TF_COMMAND, S_INT},
+      {-1}, {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str28,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,	T_MENUCONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_TYPE,		TF_COMMAND, S_STRING},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str37,	T_VISIBLE,	TF_COMMAND},
+      {-1}, {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_PROMPT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_DEPENDS,	TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str44,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_SELECT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str47,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str48,	T_MAINMENU,	TF_COMMAND},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str51,		T_SOURCE,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+
diff -Nurp linux/scripts/kconfig/zconf.tab.c linux-3.0/scripts/kconfig/zconf.tab.c
--- linux/scripts/kconfig/zconf.tab.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/scripts/kconfig/zconf.tab.c	2014-02-19 21:06:21.424259180 -0500
@@ -0,0 +1,2505 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         zconfparse
+#define yylex           zconflex
+#define yyerror         zconferror
+#define yylval          zconflval
+#define yychar          zconfchar
+#define yydebug         zconfdebug
+#define yynerrs         zconfnerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[SYMBOL_HASHSIZE];
+
+static struct menu *current_menu, *current_entry;
+
+#define YYDEBUG 0
+#if YYDEBUG
+#define YYERROR_VERBOSE
+#endif
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_TYPE = 274,
+     T_DEFAULT = 275,
+     T_SELECT = 276,
+     T_RANGE = 277,
+     T_VISIBLE = 278,
+     T_OPTION = 279,
+     T_ON = 280,
+     T_WORD = 281,
+     T_WORD_QUOTE = 282,
+     T_UNEQUAL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_EOL = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	struct kconf_id *id;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Include zconf.hash.c here so it can see the token constants. */
+#include "zconf.hash.c"
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  11
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   290
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  50
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  118
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  191
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    11,    13,    14,    17,    20,
+      23,    26,    31,    36,    40,    42,    44,    46,    48,    50,
+      52,    54,    56,    58,    60,    62,    64,    66,    68,    72,
+      75,    79,    82,    86,    89,    90,    93,    96,    99,   102,
+     105,   108,   112,   117,   122,   127,   133,   137,   138,   142,
+     143,   146,   150,   153,   155,   159,   160,   163,   166,   169,
+     172,   175,   180,   184,   187,   192,   193,   196,   200,   202,
+     206,   207,   210,   213,   216,   220,   224,   228,   230,   234,
+     235,   238,   241,   244,   248,   252,   255,   258,   261,   262,
+     265,   268,   271,   276,   277,   280,   283,   286,   287,   290,
+     292,   294,   297,   300,   303,   305,   308,   309,   312,   314,
+     318,   322,   326,   329,   333,   337,   339,   341,   342
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      37,     0,    -1,    81,    38,    -1,    38,    -1,    63,    39,
+      -1,    39,    -1,    -1,    39,    41,    -1,    39,    55,    -1,
+      39,    67,    -1,    39,    80,    -1,    39,    26,     1,    31,
+      -1,    39,    40,     1,    31,    -1,    39,     1,    31,    -1,
+      16,    -1,    18,    -1,    19,    -1,    21,    -1,    17,    -1,
+      22,    -1,    20,    -1,    23,    -1,    31,    -1,    61,    -1,
+      71,    -1,    44,    -1,    46,    -1,    69,    -1,    26,     1,
+      31,    -1,     1,    31,    -1,    10,    26,    31,    -1,    43,
+      47,    -1,    11,    26,    31,    -1,    45,    47,    -1,    -1,
+      47,    48,    -1,    47,    49,    -1,    47,    75,    -1,    47,
+      73,    -1,    47,    42,    -1,    47,    31,    -1,    19,    78,
+      31,    -1,    18,    79,    82,    31,    -1,    20,    83,    82,
+      31,    -1,    21,    26,    82,    31,    -1,    22,    84,    84,
+      82,    31,    -1,    24,    50,    31,    -1,    -1,    50,    26,
+      51,    -1,    -1,    34,    79,    -1,     7,    85,    31,    -1,
+      52,    56,    -1,    80,    -1,    53,    58,    54,    -1,    -1,
+      56,    57,    -1,    56,    75,    -1,    56,    73,    -1,    56,
+      31,    -1,    56,    42,    -1,    18,    79,    82,    31,    -1,
+      19,    78,    31,    -1,    17,    31,    -1,    20,    26,    82,
+      31,    -1,    -1,    58,    41,    -1,    14,    83,    81,    -1,
+      80,    -1,    59,    62,    60,    -1,    -1,    62,    41,    -1,
+      62,    67,    -1,    62,    55,    -1,     3,    79,    81,    -1,
+       4,    79,    31,    -1,    64,    76,    74,    -1,    80,    -1,
+      65,    68,    66,    -1,    -1,    68,    41,    -1,    68,    67,
+      -1,    68,    55,    -1,     6,    79,    31,    -1,     9,    79,
+      31,    -1,    70,    74,    -1,    12,    31,    -1,    72,    13,
+      -1,    -1,    74,    75,    -1,    74,    31,    -1,    74,    42,
+      -1,    16,    25,    83,    31,    -1,    -1,    76,    77,    -1,
+      76,    31,    -1,    23,    82,    -1,    -1,    79,    82,    -1,
+      26,    -1,    27,    -1,     5,    31,    -1,     8,    31,    -1,
+      15,    31,    -1,    31,    -1,    81,    31,    -1,    -1,    14,
+      83,    -1,    84,    -1,    84,    34,    84,    -1,    84,    28,
+      84,    -1,    30,    83,    29,    -1,    35,    83,    -1,    83,
+      32,    83,    -1,    83,    33,    83,    -1,    26,    -1,    27,
+      -1,    -1,    26,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   108,   108,   108,   110,   110,   112,   114,   115,   116,
+     117,   118,   119,   123,   127,   127,   127,   127,   127,   127,
+     127,   127,   131,   132,   133,   134,   135,   136,   140,   141,
+     147,   155,   161,   169,   179,   181,   182,   183,   184,   185,
+     186,   189,   197,   203,   213,   219,   225,   228,   230,   241,
+     242,   247,   256,   261,   269,   272,   274,   275,   276,   277,
+     278,   281,   287,   298,   304,   314,   316,   321,   329,   337,
+     340,   342,   343,   344,   349,   356,   363,   368,   376,   379,
+     381,   382,   383,   386,   394,   401,   408,   414,   421,   423,
+     424,   425,   428,   436,   438,   439,   442,   449,   451,   456,
+     457,   460,   461,   462,   466,   467,   470,   471,   474,   475,
+     476,   477,   478,   479,   480,   483,   484,   487,   488
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+  "T_VISIBLE", "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+  "T_NOT", "$accept", "input", "start", "stmt_list", "option_name",
+  "common_stmt", "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "mainmenu_stmt", "menu",
+  "menu_entry", "menu_end", "menu_stmt", "menu_block", "source_stmt",
+  "comment", "comment_stmt", "help_start", "help", "depends_list",
+  "depends", "visibility_list", "visible", "prompt_stmt_opt", "prompt",
+  "end", "nl", "if_expr", "expr", "symbol", "word_opt", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    36,    37,    37,    38,    38,    39,    39,    39,    39,
+      39,    39,    39,    39,    40,    40,    40,    40,    40,    40,
+      40,    40,    41,    41,    41,    41,    41,    41,    42,    42,
+      43,    44,    45,    46,    47,    47,    47,    47,    47,    47,
+      47,    48,    48,    48,    48,    48,    49,    50,    50,    51,
+      51,    52,    53,    54,    55,    56,    56,    56,    56,    56,
+      56,    57,    57,    57,    57,    58,    58,    59,    60,    61,
+      62,    62,    62,    62,    63,    64,    65,    66,    67,    68,
+      68,    68,    68,    69,    70,    71,    72,    73,    74,    74,
+      74,    74,    75,    76,    76,    76,    77,    78,    78,    79,
+      79,    80,    80,    80,    81,    81,    82,    82,    83,    83,
+      83,    83,    83,    83,    83,    84,    84,    85,    85
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     2,     1,     0,     2,     2,     2,
+       2,     4,     4,     3,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     2,
+       3,     2,     3,     2,     0,     2,     2,     2,     2,     2,
+       2,     3,     4,     4,     4,     5,     3,     0,     3,     0,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     2,
+       2,     4,     3,     2,     4,     0,     2,     3,     1,     3,
+       0,     2,     2,     2,     3,     3,     3,     1,     3,     0,
+       2,     2,     2,     3,     3,     2,     2,     2,     0,     2,
+       2,     2,     4,     0,     2,     2,     2,     0,     2,     1,
+       1,     2,     2,     2,     1,     2,     0,     2,     1,     3,
+       3,     3,     2,     3,     3,     1,     1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       6,     0,   104,     0,     3,     0,     6,     6,    99,   100,
+       0,     1,     0,     0,     0,     0,   117,     0,     0,     0,
+       0,     0,     0,    14,    18,    15,    16,    20,    17,    19,
+      21,     0,    22,     0,     7,    34,    25,    34,    26,    55,
+      65,     8,    70,    23,    93,    79,     9,    27,    88,    24,
+      10,     0,   105,     2,    74,    13,     0,   101,     0,   118,
+       0,   102,     0,     0,     0,   115,   116,     0,     0,     0,
+     108,   103,     0,     0,     0,     0,     0,     0,     0,    88,
+       0,     0,    75,    83,    51,    84,    30,    32,     0,   112,
+       0,     0,    67,     0,     0,    11,    12,     0,     0,     0,
+       0,    97,     0,     0,     0,    47,     0,    40,    39,    35,
+      36,     0,    38,    37,     0,     0,    97,     0,    59,    60,
+      56,    58,    57,    66,    54,    53,    71,    73,    69,    72,
+      68,   106,    95,     0,    94,    80,    82,    78,    81,    77,
+      90,    91,    89,   111,   113,   114,   110,   109,    29,    86,
+       0,   106,     0,   106,   106,   106,     0,     0,     0,    87,
+      63,   106,     0,   106,     0,    96,     0,     0,    41,    98,
+       0,     0,   106,    49,    46,    28,     0,    62,     0,   107,
+      92,    42,    43,    44,     0,     0,    48,    61,    64,    45,
+      50
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     3,     4,     5,    33,    34,   108,    35,    36,    37,
+      38,    74,   109,   110,   157,   186,    39,    40,   124,    41,
+      76,   120,    77,    42,   128,    43,    78,     6,    44,    45,
+     137,    46,    80,    47,    48,    49,   111,   112,    81,   113,
+      79,   134,   152,   153,    50,     7,   165,    69,    70,    60
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -90
+static const yytype_int16 yypact[] =
+{
+       4,    42,   -90,    96,   -90,   111,   -90,    15,   -90,   -90,
+      75,   -90,    82,    42,   104,    42,   110,   107,    42,   115,
+     125,    -4,   121,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   162,   -90,   163,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   139,   -90,   -90,   138,   -90,   142,   -90,   143,   -90,
+     152,   -90,   164,   167,   168,   -90,   -90,    -4,    -4,    77,
+     -18,   -90,   177,   185,    33,    71,   195,   247,   236,    -2,
+     236,   171,   -90,   -90,   -90,   -90,   -90,   -90,    41,   -90,
+      -4,    -4,   138,    97,    97,   -90,   -90,   186,   187,   194,
+      42,    42,    -4,   196,    97,   -90,   219,   -90,   -90,   -90,
+     -90,   210,   -90,   -90,   204,    42,    42,   199,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   222,   -90,   223,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   215,   -90,   -90,   -90,   -90,   -90,
+      -4,   222,   228,   222,    -5,   222,    97,    35,   229,   -90,
+     -90,   222,   232,   222,    -4,   -90,   135,   233,   -90,   -90,
+     234,   235,   222,   240,   -90,   -90,   237,   -90,   239,   -13,
+     -90,   -90,   -90,   -90,   244,    42,   -90,   -90,   -90,   -90,
+     -90
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -90,   -90,   269,   271,   -90,    23,   -70,   -90,   -90,   -90,
+     -90,   243,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -48,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -20,   -90,   -90,   -90,   -90,   -90,   206,   205,   -68,
+     -90,   -90,   169,    -1,    27,    -7,   118,   -66,   -89,   -90
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -86
+static const yytype_int16 yytable[] =
+{
+      10,    88,    89,    54,   146,   147,   119,     1,   122,   164,
+      93,   141,    56,   142,    58,   156,    94,    62,     1,    90,
+      91,   131,    65,    66,   144,   145,    67,    90,    91,   132,
+     127,    68,   136,   -31,    97,     2,   154,   -31,   -31,   -31,
+     -31,   -31,   -31,   -31,   -31,    98,    52,   -31,   -31,    99,
+     -31,   100,   101,   102,   103,   104,   -31,   105,   129,   106,
+     138,   173,    92,   141,   107,   142,   174,   172,     8,     9,
+     143,   -33,    97,    90,    91,   -33,   -33,   -33,   -33,   -33,
+     -33,   -33,   -33,    98,   166,   -33,   -33,    99,   -33,   100,
+     101,   102,   103,   104,   -33,   105,    11,   106,   179,   151,
+     123,   126,   107,   135,   125,   130,     2,   139,     2,    90,
+      91,    -5,    12,    55,   161,    13,    14,    15,    16,    17,
+      18,    19,    20,    65,    66,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    57,    59,    31,    61,    -4,
+      12,    63,    32,    13,    14,    15,    16,    17,    18,    19,
+      20,    64,    71,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    72,    73,    31,   180,    90,    91,    52,
+      32,   -85,    97,    82,    83,   -85,   -85,   -85,   -85,   -85,
+     -85,   -85,   -85,    84,   190,   -85,   -85,    99,   -85,   -85,
+     -85,   -85,   -85,   -85,   -85,    85,    97,   106,    86,    87,
+     -52,   -52,   140,   -52,   -52,   -52,   -52,    98,    95,   -52,
+     -52,    99,   114,   115,   116,   117,    96,   148,   149,   150,
+     158,   106,   155,   159,    97,   163,   118,   -76,   -76,   -76,
+     -76,   -76,   -76,   -76,   -76,   160,   164,   -76,   -76,    99,
+      13,    14,    15,    16,    17,    18,    19,    20,    91,   106,
+      21,    22,    14,    15,   140,    17,    18,    19,    20,   168,
+     175,    21,    22,   177,   181,   182,   183,    32,   187,   167,
+     188,   169,   170,   171,   185,   189,    53,    51,    32,   176,
+      75,   178,   121,     0,   133,   162,     0,     0,     0,     0,
+     184
+};
+
+static const yytype_int16 yycheck[] =
+{
+       1,    67,    68,    10,    93,    94,    76,     3,    76,    14,
+      28,    81,    13,    81,    15,   104,    34,    18,     3,    32,
+      33,    23,    26,    27,    90,    91,    30,    32,    33,    31,
+      78,    35,    80,     0,     1,    31,   102,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    31,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    78,    26,
+      80,    26,    69,   133,    31,   133,    31,   156,    26,    27,
+      29,     0,     1,    32,    33,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,   150,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,     0,    26,   164,   100,
+      77,    78,    31,    80,    77,    78,    31,    80,    31,    32,
+      33,     0,     1,    31,   115,     4,     5,     6,     7,     8,
+       9,    10,    11,    26,    27,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,    26,    26,    31,     0,
+       1,    26,    31,     4,     5,     6,     7,     8,     9,    10,
+      11,    26,    31,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,     1,     1,    26,    31,    32,    33,    31,
+      31,     0,     1,    31,    31,     4,     5,     6,     7,     8,
+       9,    10,    11,    31,   185,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,     1,    26,    31,    31,
+       5,     6,    31,     8,     9,    10,    11,    12,    31,    14,
+      15,    16,    17,    18,    19,    20,    31,    31,    31,    25,
+       1,    26,    26,    13,     1,    26,    31,     4,     5,     6,
+       7,     8,     9,    10,    11,    31,    14,    14,    15,    16,
+       4,     5,     6,     7,     8,     9,    10,    11,    33,    26,
+      14,    15,     5,     6,    31,     8,     9,    10,    11,    31,
+      31,    14,    15,    31,    31,    31,    31,    31,    31,   151,
+      31,   153,   154,   155,    34,    31,     7,     6,    31,   161,
+      37,   163,    76,    -1,    79,   116,    -1,    -1,    -1,    -1,
+     172
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    31,    37,    38,    39,    63,    81,    26,    27,
+      79,     0,     1,     4,     5,     6,     7,     8,     9,    10,
+      11,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    26,    31,    40,    41,    43,    44,    45,    46,    52,
+      53,    55,    59,    61,    64,    65,    67,    69,    70,    71,
+      80,    39,    31,    38,    81,    31,    79,    31,    79,    26,
+      85,    31,    79,    26,    26,    26,    27,    30,    35,    83,
+      84,    31,     1,     1,    47,    47,    56,    58,    62,    76,
+      68,    74,    31,    31,    31,    31,    31,    31,    83,    83,
+      32,    33,    81,    28,    34,    31,    31,     1,    12,    16,
+      18,    19,    20,    21,    22,    24,    26,    31,    42,    48,
+      49,    72,    73,    75,    17,    18,    19,    20,    31,    42,
+      57,    73,    75,    41,    54,    80,    41,    55,    60,    67,
+      80,    23,    31,    74,    77,    41,    55,    66,    67,    80,
+      31,    42,    75,    29,    83,    83,    84,    84,    31,    31,
+      25,    79,    78,    79,    83,    26,    84,    50,     1,    13,
+      31,    79,    78,    26,    14,    82,    83,    82,    31,    82,
+      82,    82,    84,    26,    31,    31,    82,    31,    82,    83,
+      31,    31,    31,    31,    82,    34,    51,    31,    31,    31,
+      79
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 53: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 59: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 65: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 10:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 11:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+    break;
+
+  case 12:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+;}
+    break;
+
+  case 13:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 28:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); ;}
+    break;
+
+  case 29:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 30:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 31:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 32:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 33:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].id)->stype);
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 43:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].id)->stype);
+;}
+    break;
+
+  case 44:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 48:
+
+    {
+	struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 49:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 50:
+
+    { (yyval.string) = (yyvsp[(2) - (2)].string); ;}
+    break;
+
+  case 51:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_AUTO;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 52:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 53:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 61:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 62:
+
+    {
+	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[(1) - (3)].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 63:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 64:
+
+    {
+	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 67:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 68:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 74:
+
+    {
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+;}
+    break;
+
+  case 75:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 76:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 77:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 83:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 84:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 85:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 86:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 87:
+
+    {
+	current_entry->help = (yyvsp[(2) - (2)].string);
+;}
+    break;
+
+  case 92:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 96:
+
+    {
+	menu_add_visibility((yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 98:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 101:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 102:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 103:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 107:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+    break;
+
+  case 108:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 110:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 111:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+    break;
+
+  case 112:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+    break;
+
+  case 113:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 114:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 115:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 116:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 117:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	_menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+#if YYDEBUG
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+#endif
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+
+	rootmenu.prompt->text = _(rootmenu.prompt->text);
+	rootmenu.prompt->text = sym_expand_string_value(rootmenu.prompt->text);
+
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			zconfnerrs++;
+        }
+	if (zconfnerrs)
+		exit(1);
+	sym_set_change_count(1);
+}
+
+static const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	case T_VISIBLE:		return "visible";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+#if YYDEBUG
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+#endif
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "\nchoice\n");
+	else
+		fprintf(out, "\nconfig %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		case P_SELECT:
+			fputs( "  select ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_RANGE:
+			fputs( "  range ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_MENU:
+			fputs( "  menu ", out);
+			print_quoted_string(out, prop->text);
+			fputc('\n', out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff -Nurp linux/scripts/mod/elfconfig.h linux-3.0/scripts/mod/elfconfig.h
--- linux/scripts/mod/elfconfig.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/scripts/mod/elfconfig.h	2014-02-19 21:06:21.797267592 -0500
@@ -0,0 +1,4 @@
+#define KERNEL_ELFCLASS ELFCLASS64
+#define KERNEL_ELFDATA ELFDATA2LSB
+#define HOST_ELFCLASS ELFCLASS64
+#define HOST_ELFDATA ELFDATA2LSB
Binary files linux/scripts/mod/mk_elfconfig and linux-3.0/scripts/mod/mk_elfconfig differ
Binary files linux/scripts/mod/modpost and linux-3.0/scripts/mod/modpost differ
diff -Nurp linux/.version linux-3.0/.version
--- linux/.version	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.0/.version	2014-02-19 20:59:15.385633893 -0500
@@ -0,0 +1 @@
+6
